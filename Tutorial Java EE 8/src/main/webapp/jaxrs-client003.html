<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8"/>
    <title>Características Avanzadas de la La IPA de Cliente</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="css/style.css" rel="stylesheet">
    <script src="https://use.fontawesome.com/96c4d89611.js"></script>
  </head>
  <body>
    <table id="doc-title" cellspacing="0" cellpadding="0">
      <tr>
        <td align="left" valign="top">
          <b>Plataforma Java, Edición Empresarial (Java EE) 8</b><br />
          <b>El Tutorial de Java EE</b>
        </td>
      </tr>
    </table>
    <hr />
    <table width="90%" id="top-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>
        <td align="left">
          <a href="jaxrs-client002.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="jaxrs-advanced.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class=" vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <div class="sect1" id="BABCDDGH">
      <h2 id="advanced-features-of-the-client-api">Características Avanzadas de la La IPA de Cliente</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>
            Esta sección describe algunas de las funciones avanzadas de la IPA Cliente de JAX-RS.
          </p>
        </div>
        <div class="paragraph">
          <p>Aquí se tratan los siguientes temas:</p>
        </div>
        <div class="ulist">
          <ul>
            <li>
              <p><a href="#CHDGBBCC">Configurando la Petición del Cliente</a></p>
            </li>
            <li>
              <p><a href="#CHDEBIGG">Invocaciones Asíncronas en la IPA de Cliente</a></p>
            </li>
          </ul>
        </div>
        <div class="sect2" id="CHDGBBCC">
          <h3 id="configuring-the-client-request">Configurando la Petición del Cliente</h3>
          <div class="paragraph">
            <p>
              Se pueden agregar opciones de configuración adicionales a la solicitud del cliente después de 
              crearla, pero antes de invocarla.
            </p>
          </div>
          <div class="paragraph">
            <p>Aquí se tratan los siguientes temas:</p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p><a href="#CHDHAFBG">Estableciendo las Cabeceras del Mensaje en la Petición del Cliente</a></p>
              </li>
              <li>
                <p><a href="#CHDHFFDJ">Estableciendo Cookies en la Petición del Cliente</a></p>
              </li>
              <li>
                <p><a href="#CHDJEFID">Agregando Flitros al Cliente</a></p>
              </li>
            </ul>
          </div>
          <div class="sect3" id="CHDHAFBG">
            <h4 id="setting-message-headers-in-the-client-request">
              Estableciendo las Cabeceras del Mensaje en la Petición del Cliente
            </h4>
            <div class="paragraph">
              <p>
                Puede establecer encabezados HTTP en la solicitud llamando al método 
                <code>Invocation.Builder.header</code>.
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
Client client = ClientBuilder.newClient();
WebTarget myResource = client.target("http://example.com/webapi/read");
String response = myResource.request(MediaType.TEXT_PLAIN)
        .header("myHeader", "The header value")
        .get(String.class);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Si necesita establecer varios encabezados en la solicitud, llame al método 
                <code>Invocation.Builder.headers</code> y pase una instancia de 
                <code>javax.ws.rs.core.MultivaluedMap</code> con el nombre pares de valores de los encabezados 
                HTTP. Llamar al método <code>headers</code> reemplaza todos los encabezados existentes con 
                los encabezados proporcionados en la instancia de <code>MultivaluedMap</code>.
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
Client client = ClientBuilder.newClient();
WebTarget myResource = client.target("http://example.com/webapi/read");
MultivaluedMap&lt;String, Object&gt; myHeaders =
    new MultivaluedMap&lt;&gt;("myHeader", "The header value");
myHeaders.add(...);
String response = myResource.request(MediaType.TEXT_PLAIN)
        .headers(myHeaders)
        .get(String.class);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                La interfaz <code>MultivaluedMap</code> le permite especificar varios valores para una clave 
                determinada.
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
MultivaluedMap&lt;String, Object&gt; myHeaders =
    new MultivaluedMap&lt;String, Object&gt;();
List&lt;String&gt; values = new ArrayList&lt;&gt;();
values.add(...)
myHeaders.add("myHeader", values
                  </code>
                </pre>
              </div>
            </div>
          </div>
          <div class="sect3" id="CHDHFFDJ">
            <h4 id="setting-cookies-in-the-client-request">
              Estableciendo Cookies en la Petición del Cliente
            </h4>
            <div class="paragraph">
              <p>
                Puede agregar cookies HTTP a la solicitud llamando al método 
                <code>Invocation.Builder.cookie</code>, que toma un par de nombre y valor como parámetros.
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
Client client = ClientBuilder.newClient();
WebTarget myResource = client.target("http://example.com/webapi/read");
String response = myResource.request(MediaType.TEXT_PLAIN)
        .cookie("myCookie", "The cookie value")
        .get(String.class);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                La clase <code>javax.ws.rs.core.Cookie</code> encapsula los atributos de una cookie HTTP, 
                incluidos el nombre, el valor, la ruta, el dominio y la versión de especificación RFC de la cookie. En el siguiente ejemplo, el objeto <code>Cookie</code> está configurado con un par nombre-valor, una ruta y un dominio.
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
Client client = ClientBuilder.newClient();
WebTarget myResource = client.target("http://example.com/webapi/read");
Cookie myCookie = new Cookie("myCookie", "The cookie value",
    "/webapi/read", "example.com");
String response = myResource.request(MediaType.TEXT_PLAIN)
        .cookie(myCookie)
        .get(String.class);
                  </code>
                </pre>
              </div>
            </div>
          </div>
          <div class="sect3" id="CHDJEFID">
            <h4 id="adding-filters-to-the-client">Agregando Flitros al Cliente</h4>
            <div class="paragraph">
              <p>
                Puede registrar filtros personalizados con la solicitud del cliente o la respuesta recibida 
                del recurso de destino. Para registrar clases de filtro cuando se crea la instancia de 
                <code>Client</code>, llame al método <code>Client.register</code>.
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
Client client = ClientBuilder.newClient().register(MyLoggingFilter.class);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                En el ejemplo anterior, todas las invocaciones que usan esta instancia de <code>Client</code> 
                tienen el filtro <code>MyLoggingFilter</code> registrado con ellas.
              </p>
            </div>
            <div class="paragraph">
              <p>
                También puede registrar las clases de filtro en el objetivo llamando a 
                <code>WebTarget.register</code>.
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
Client client = ClientBuilder.newClient().register(MyLoggingFilter.class);
WebTarget target = client.target("http://example.com/webapi/secure")
        .register(MyAuthenticationFilter.class);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                En el ejemplo anterior, los filtros <code>MyLoggingFilter</code> y 
                <code>MyAuthenticationFilter</code> se adjuntan a la invocación.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Las clases de filtro de solicitud y respuesta implementan las interfaces 
                <code>javax.ws.rs.client.ClientRequestFilter</code> y 
                <code>javax.ws.rs.client.ClientResponseFilter</code>, respectivamente. Ambas interfaces 
                definen un único método, <code>filter</code>. Todos los filtros se deben anotar con 
                <code>javax.ws.rs.ext.Provider</code>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                La siguiente clase es un filtro de registro tanto para solicitudes de clientes como para 
                respuestas de clientes.
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Provider
public class MyLoggingFilter implements ClientRequestFilter,
        ClientResponseFilter {
    static final Logger logger = Logger.getLogger(...);
    // implementa el método ClientRequestFilter.filter
    @Override
    public void filter(ClientRequestContext requestContext)
            throws IOException {
        logger.log(...);
        ...
    }
    // implementa el método ClientResponseFilter.filter
    @Override
    public void filter(ClientRequestContext requestContext,
           ClientResponseContext responseContext) throws IOException {
        logger.log(...);
        ...
    }
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Si la invocación debe detenerse mientras el filtro está activo, llame al método 
                <code>abortWith</code> del objeto de contexto y pase una instancia 
                <code>javax.ws.rs.core.Response</code> desde dentro del filtrar.
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Override
public void filter(ClientRequestContext requestContext) throws IOException {
    ...
    Response response = new Response();
    response.status(500);
    requestContext.abortWith(response);
}
                  </code>
                </pre>
              </div>
            </div>
          </div>
        </div>
        <div class="sect2" id="CHDEBIGG">
          <h3 id="asynchronous-invocations-in-the-client-api">
            Invocaciones Asíncronas en la IPA de Cliente
          </h3>
          <div class="paragraph">
            <p>
              En aplicaciones en red, los problemas de red pueden afectar el rendimiento percibido de la 
              aplicación, particularmente en llamadas de red complicadas o de larga duración. El procesamiento 
              asíncrono ayuda a evitar el bloqueo y hace un mejor uso de los recursos de una aplicación.
            </p>
          </div>
          <div class="paragraph">
            <p>
              En la IPA de cliente JAX-RS, el método <code>Invocation.Builder.async</code> se utiliza cuando 
              se construye una solicitud de cliente para indicar que la llamada al servicio debe realizarse de 
              forma asíncrona. Una invocación asíncrona devuelve el control a la persona que llama 
              inmediatamente, con un tipo de retorno de 
              <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html?is-external=true">
                <code>java.util.concurrent.Future&lt;T&gt;</code>
              </a> (parte de la IPA de concurrencia de Java SE) y con el tipo establecido en el tipo de 
              retorno de la llamada de servicio. Los objetos <code>Future&lt;T&gt;</code> tienen métodos para 
              comprobar si la llamada asincrónica se ha completado, para recuperar el resultado final, para 
              cancelar la invocación y para comprobar si la invocación se ha cancelado.
            </p>
          </div>
          <div class="paragraph">
            <p>El siguiente ejemplo muestra cómo invocar una solicitud asíncrona en un recurso.</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
Client client = ClientBuilder.newClient();
WebTarget myResource = client.target("http://example.com/webapi/read");
Future&lt;String&gt; response = myResource.request(MediaType.TEXT_PLAIN)
        .async()
        .get(String.class);
                </code>
              </pre>
            </div>
          </div>
          <div class="sect3" id="sthref140">
            <h4 id="using-custom-callbacks-in-asynchronous-invocations">
              Usando Retrollamadas Personalizadas en Invocaciones Asíncronas
            </h4>
            <div class="paragraph">
              <p>
                La interfaz <code>InvocationCallback</code> define dos métodos, <code>completed</code> y 
                <code>failed</code>, que se llaman cuando una invocación asincrónica se completa correctamente 
                o falla, respectivamente. Puede registrar una instancia de <code>InvocationCallback</code> en 
                su solicitud creando una nueva instancia al especificar el método de solicitud.
              </p>
            </div>
            <div class="paragraph">
              <p>
                El siguiente ejemplo muestra cómo registrar un objeto de devolución de llamada en una 
                invocación asincrónica.
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
Client client = ClientBuilder.newClient();
WebTarget myResource = client.target("http://example.com/webapi/read");
Future&lt;Customer&gt; fCustomer = myResource.request(MediaType.TEXT_PLAIN)
        .async()
        .get(new InvocationCallback&lt;Customer&gt;() {
            @Override
            public void completed(Customer customer) {
            // Hacer algo con el objeto del cliente.
            }
            @Override
             public void failed(Throwable throwable) {
            // manejar el error
            }
    });
                  </code>
                </pre>
              </div>
            </div>
          </div>
          <div class="sect3" id="sthref141">
            <h4 id="using-reactive-approach-in-asynchronous-invocations">
              Uso del Enfoque Reactivo en Invocaciones Asíncronas
            </h4>
            <div class="paragraph">
              <p>
                El uso de devoluciones de llamada personalizadas en invocaciones asincrónicas es fácil en 
                casos simples y cuando hay muchas llamadas independientes para realizar. En llamadas anidadas, 
                el uso de devoluciones de llamada personalizadas se vuelve muy difícil de implementar, depurar 
                y mantener.
              </p>
            </div>
            <div class="paragraph">
              <p>
                JAX-RS define un nuevo tipo de invocador llamado <code>RxInvoker</code> y una implementación 
                predeterminada de este tipo es <code>CompletionStageRxInvoker</code>. El nuevo método 
                <code>rx</code> se usa como en el siguiente ejemplo:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
CompletionStage&lt;String&gt; csf = client.target("forecast/{destination}") resolveTemplate("destination", "mars").request().rx().get(String.class);
csf.thenAccept(System.out::println);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                En el ejemplo, se crea un procesamiento asíncrono de la interfaz 
                <code>CompletionStage&lt;String&gt;</code> y espera hasta que se completa y se muestra el 
                resultado. El <code>CompletionStage</code> que se devuelve se puede usar solo para recuperar 
                el resultado como se muestra en el ejemplo anterior o se puede combinar con otras etapas de 
                finalización para facilitar y mejorar el procesamiento de tareas asincrónicas.
              </p>
            </div>
          </div>
        </div>
        <div class="sect2" id="sthref142">
          <h3 id="using-server-sent-events">Usando Eventos Enviados-por-el-Servidor</h3>
          <div class="paragraph">
            <p>
              La tecnología de Eventos Enviados por el Servidor (SSE o Server-sent Events, en inglés) se 
              utiliza para enviar notificaciones de forma asíncrona al cliente a través del protocolo HTTP o 
              HTTPS estándar. Los clientes pueden suscribirse a las notificaciones de eventos que se originan 
              en un servidor. El servidor genera eventos y envía estos eventos a los clientes que están 
              suscritos para recibir las notificaciones. La conexión del canal de comunicación unidireccional 
              la establece el cliente. Una vez que se establece la conexión, el servidor envía eventos al 
              cliente cada vez que hay nuevos datos disponibles.
            </p>
          </div>
          <div class="paragraph">
            <p>
              El canal de comunicación establecido por el cliente dura hasta que el cliente cierra la conexión 
              y también es reutilizado por el servidor para enviar múltiples eventos desde el servidor.
            </p>
          </div>
        </div>
        <div class="sect2" id="sthref143">
          <h3 id="overview-of-the-sse-api">Descripción General de la IPA SSE</h3>
          <div class="paragraph">
            <p>
              La IPA de SSE se define en el paquete <code>javax.ws.rs.sse</code> que incluye las interfaces 
              <code>SseEventSink</code>, <code>SseEvent</code>, <code>Sse</code> y 
              <code>SseEventSource</code>. Para aceptar conexiones y enviar eventos a uno o más clientes, 
              inserte un <code>SseEventSink</code> en el método de recurso que produce el tipo de medio 
              <code>text/event-stream</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              El siguiente ejemplo muestra cómo aceptar las conexiones SSE y enviar eventos a los clientes:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
@GET
@Path("eventStream")
@Produces(MediaType.SERVER_SENT_EVENTS)
public void eventStream(@Context SseEventSink eventSink,
@Context Sse sse) {
executor.execute(() -&gt; {
try (SseEventSink sink = eventSink) {
eventSink.send(sse.newEvent("evento1"));
eventSink.send(sse.newEvent("evento2"));
eventSink.send(sse.newEvent("evento3"));
}
});
}
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              El <code>SseEventsink</code> se inyecta en el método de recurso y la conexión del cliente 
              subyacente se mantiene abierta y se usa para enviar eventos. La conexión persiste hasta que el 
              cliente se desconecta del servidor. El método <code>send</code> devuelve una instancia de 
              <code>CompletionStage&lt;T&gt;</code> que indica que la acción de enviar un mensaje de forma 
              asíncrona a un cliente está habilitada.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Los eventos que se transmiten a los clientes se pueden definir con detalles como 
              <code>event</code>, <code>data</code>, <code>id</code>, <code>retry</code >, y 
              <code>comentario</code>.
            </p>
          </div>
        </div>
        <div class="sect2" id="sthref144">
          <h3 id="broadcasting-using-sse">Transmisión Usando SSE</h3>
          <div class="paragraph">
            <p>
              La transmisión es la acción de enviar eventos a múltiples clientes simultáneamente. La IPA de 
              JAX-RS SSE proporciona <code>SseBroadcaster</code> para registrar todas las instancias de 
              <code>SseEventSink</code> y enviar eventos a todas las salidas de eventos registradas. El ciclo 
              de vida y el alcance de un <code>SseBroadcaster</code> están totalmente controlados por las 
              aplicaciones y no por el tiempo de ejecución de JAX-RS. El seguimiento ejemplo muestran el uso 
              de las emisoras:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Path("/")
@Singleton
public class SseResource {
@Context
private Sse sse;
private volatile SseBroadcaster sseBroadcaster;
@PostConstruct
public init() {
this.sseBroadcaster = sse.newBroadcaster();
}
@GET
@Path("register")
@Produces(MediaType.SERVER_SENT_EVENTS)
public void register(@Context SseEventSink eventSink) {
eventSink.send(sse.newEvent("&iexcl;Bienvenido!"));
sseBroadcaster.register(eventSink);
}
@POST
@Path("broadcast")
@Consumes(MediaType.MULTIPART_FORM_DATA)
public void broadcast(@FormParam("event") String event) {
sseBroadcaster.broadcast(sse.newEvent(event));
}
}
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              La anotación <code>@Singleton</code> se define para la clase de recurso que restringe la 
              creación de múltiples instancias de la clase. El método <code>register</code> en una emisora se 
              usa para agregar un nuevo <code>SseEventSink</code>; el método <code>broadcast</code> se utiliza 
              para enviar un evento SSE a todos los clientes registrados.
            </p>
          </div>
        </div>
        <div class="sect2" id="sthref145">
          <h3 id="listening-and-receiving-events">Escuchando y Recibiendo Eventos</h3>
          <div class="paragraph">
            <p>
              JAX-RS SSE proporciona la interfaz <code>SseEventSource</code> para que el cliente se suscriba a 
              las notificaciones. El cliente puede recibir notificaciones asincrónicas sobre eventos entrantes 
              invocando uno de los métodos <code>subscribe</code> en 
              <code>javax.ws.rs.sse.SseEventSource</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              El siguiente ejemplo muestra cómo usar la IPA <code>SseEventSource</code> para abrir una 
              conexión SSE y leer algunos de los mensajes durante un período:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
WebTarget target = client.target("http://...");
try (SseEventSource source = SseEventSource.target(target).build()) {
source.register(System.out::println);
source.open();
Thread.sleep(500); // Consume eventos por solo 500 ms
source.close();
} catch (InterruptedException e) {
// cae a través
}
                </code>
              </pre>
            </div>
          </div>
        </div>
      </div>
    </div>
    <hr />
    <table width="90%" id="bottom-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>		
        <td align="left">
          <a href="jaxrs-client002.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="jaxrs-advanced.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class="vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <span id="copyright">
      <a href="img/cpyr.adoc">
        <img src="img/oracle.gif" height="10" alt="Logo de Oracle" />&nbsp;			
        <span>
          Copyright&nbsp;&copy;&nbsp;2017,&nbsp;Oracle&nbsp;y/o&nbsp;sus&nbsp;afiliados.&nbsp;Todos&nbsp;los&nbsp;
          derechos&nbsp;reservados.
        </span>
      </a>
    </span>
  </body>
</html>
