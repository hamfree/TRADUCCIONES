<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8"/>
    <title>La Aplicación order</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="css/style.css" rel="stylesheet">
    <script src="https://use.fontawesome.com/96c4d89611.js"></script>
  </head>
  <body>
    <table id="doc-title" cellspacing="0" cellpadding="0">
      <tr>
        <td align="left" valign="top">
          <b>Plataforma Java, Edición Empresarial (Java EE) 8</b><br />
          <b>El Tutorial de Java EE</b>
        </td>
      </tr>
    </table>
    <hr />
    <table width="90%" id="top-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>
        <td align="left">
          <a href="persistence-basicexamples001.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="persistence-basicexamples003.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class=" vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <div class="sect1" id="GIQST">
      <h2 id="the-order-application">La Aplicación order</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>
            La aplicación <code>order</code> es una sencilla aplicación de inventario y pedido para mantener 
            un catálogo de piezas y realizar un pedido detallado de esas piezas. La aplicación tiene entidades 
            que representan piezas, proveedores, pedidos y elementos de línea. Se accede a estas entidades 
            mediante un bean de sesión con estado que contiene la lógica de negocio de la aplicación. Un 
            simple bean de sesión singleton crea las entidades iniciales en el despliegue de la aplicación. 
            Una aplicación web de Facelets manipula los datos y muestra los datos del catálogo.
          </p>
        </div>
        <div class="paragraph">
          <p>
            La información contenida en un pedido se puede dividir en elementos. 
            ¿Cuál es el número de pedido? ¿Qué piezas están incluidas en el pedido? ¿Qué partes componen esa 
            parte? ¿Quién hace la parte? ¿Cuáles son las especificaciones de la pieza? ¿Hay algún esquema para 
            la pieza? La aplicación <code>order</code> es una versión simplificada de un sistema de pedidos 
            que tiene todos estos elementos.
          </p>
        </div>
        <div class="paragraph">
          <p>
            La aplicación <code>order</code> consta de un solo módulo WAR que incluye las clases de enterprise 
            bean, las entidades, las clases de soporte y los archivos Facelets XHTML y de clase.
          </p>
        </div>
        <div class="paragraph">
          <p>
            El esquema de la base de datos en la base de datos Derby para <code>order</code> se muestra en la 
            <a href="#CHDGGDIA">Figura 41-1</a>.
          </p>
        </div>
        <div id="CHDGGDIA" class="paragraph">
          <div class="title">
            <strong>Figura 41-1 Esquema de Base de Datos para la Aplicación order</strong>
          </div>
          <p>
            <span class="image">
              <img src="img/javaeett_dt_024.png" 
                   alt="Diagrama que muestra el esquema de la base de datos para la aplicación de pedidos">
            </span>
          </p>
        </div>
        <table class="tableblock frame-all grid-all spread">
          <colgroup>
            <col style="width: 100%;">
          </colgroup>
          <tbody>
            <tr>
              <td class="tableblock halign-left valign-top">
                <div>
                  <div class="paragraph">
                    <p>Nota:</p>
                  </div>
                  <div class="paragraph">
                    <p>
                      En este diagrama, por simplicidad, el prefijo <code>PERSISTENCE_ORDER_</code> se omite 
                      de los nombres de las tablas.
                    </p>
                  </div>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
        <div class="sect2" id="GIQRH">
          <h3 id="entity-relationships-in-the-order-application">
            Relaciones Entre Entidades en la Aplicacion order
          </h3>
          <div class="paragraph">
            <p>
              La aplicación <code>order</code> demuestra varios tipos de relaciones entre entidades: 
              relaciones autorreferenciales, uno a uno, uno a muchos, muchos a uno y unidireccionales.
            </p>
          </div>
          <div class="paragraph">
            <p>Aquí se tratan los siguientes temas:</p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p><a href="#GIQQR">Relaciones Autorreferenciales</a></p>
              </li>
              <li>
                <p><a href="#GIQSR">Relaciones Uno a Uno</a></p>
              </li>
              <li>
                <p>
                  <a href="#GIQTJ">
                    Relación Uno a Varios Asignada a Claves Primarias y Externas Superpuestas
                  </a>
                </p>
              </li>
              <li>
                <p><a href="#GIQUD">Relaciones Unidireccionales</a></p>
              </li>
            </ul>
          </div>
          <div class="sect3" id="GIQQR">
            <h4 id="self-referential-relationships">Relaciones Autorreferenciales</h4>
            <div class="paragraph">
              <p>
                Una relación autorreferencial ocurre entre campos de relación en la misma entidad. 
                <code>Part</code> tiene un campo, <code>bomPart</code>, que tiene una relación de uno a muchos 
                con el campo <code>parts</code>, que también está en <code>Part</code>. Es decir, una parte 
                puede estar formada por muchas partes, y cada una de esas partes tiene exactamente una parte 
                de la lista de materiales.
              </p>
            </div>
            <div class="paragraph">
              <p>
                La clave principal para <code>Part</code> es una clave principal compuesta, una combinación de 
                los campos <code>partNumber</code> y <code>revision</code>. Esta clave está asignada a las 
                columnas <code>PARTNUMBER</code> y <code>REVISION</code> en la tabla 
                <code>PERSISTENCE_ORDER_PART</code>:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
...
@ManyToOne
@JoinColumns({
    @JoinColumn(name="BOMPARTNUMBER", referencedColumnName="PARTNUMBER"),
    @JoinColumn(name="BOMREVISION", referencedColumnName="REVISION")
})
public Part getBomPart() {
    return bomPart;
}
...
@OneToMany(mappedBy="bomPart")
public Collection&lt;Part&gt; getParts() {
    return parts;
}
...
                  </code>
                </pre>
              </div>
            </div>
          </div>
          <div class="sect3" id="GIQSR">
            <h4 id="one-to-one-relationships">Relaciones Uno a Uno</h4>
            <div class="paragraph">
              <p>
                <code>Part</code> tiene un campo, <code>vendorPart</code>, que tiene una relación uno a uno 
                con el campo <code>VendorPart</code> de <code>VendorPart</code>. Es decir, cada pieza tiene 
                exactamente una pieza de proveedor y viceversa.
              </p>
            </div>
            <div class="paragraph">
              <p>Aquí está el mapeo de relaciones en <code>Part</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@OneToOne(mappedBy="part")
public VendorPart getVendorPart() {
    return vendorPart;
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>Aquí está el mapeo de relaciones en <code>VendorPart</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@OneToOne
@JoinColumns({
    @JoinColumn(name="PARTNUMBER", referencedColumnName="PARTNUMBER"),
    @JoinColumn(name="PARTREVISION", referencedColumnName="REVISION")
})
public Part getPart() {
    return part;
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Tenga en cuenta que, dado que <code>Part</code> utiliza una clave principal compuesta, la 
                anotación <code>@JoinColumns</code> se utiliza para asignar las columnas de la tabla 
                <code>PERSISTENCE_ORDER_VENDOR_PART</code> a las columnas de 
                <code>PERSISTENCE_ORDER_PART</code>. La columna <code>PARTREVISION</code> de la tabla 
                <code>PERSISTENCE_ORDER_VENDOR_PART</code> hace referencia a la columna 
                <code>PERSISTENCE_ORDER_PART</code> de <code>REVISION</code>.
              </p>
            </div>
          </div>
          <div class="sect3" id="GIQTJ">
            <h4 id="one-to-many-relationship-mapped-to-overlapping-primary-and-foreign-keys">
              Relación Uno a Varios Asignada a Claves Primarias y Externas Superpuestas
            </h4>
            <div class="paragraph">
              <p>
                <code>CustomerOrder</code> tiene un campo, <code>lineItems</code>, que tiene una relación de 
                uno a varios con el campo <code>CustomerOrder</code> de <code>LineItem</code>. Es decir, cada 
                pedido tiene una o más líneas de pedido.
              </p>
            </div>
            <div class="paragraph">
              <p>
                <code>LineItem</code> utiliza una clave principal compuesta que se compone de los campos 
                <code>orderId</code> e <code>itemId</code>. Esta clave principal compuesta se asigna a las 
                columnas <code>ORDERID</code> e <code>ITEMID</code> en la tabla 
                <code>PERSISTENCE_ORDER_LINEITEM</code>. <code>ORDERID</code> es una clave externa a la 
                columna <code>ORDERID</code> en la tabla <code>PERSISTENCE_ORDER_CUSTOMERORDER</code>. Esto 
                significa que la columna <code>ORDERID</code> se asigna dos veces: una vez como campo de clave 
                principal, <code>orderId</code>; y nuevamente como un campo de relación, <code>order</code>.
              </p>
            </div>
            <div class="paragraph">
              <p>Aquí está el mapeo de relaciones en <code>CustomerOrder</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@OneToMany(cascade=ALL, mappedBy="customerOrder")
public Collection&lt;LineItem&gt; getLineItems() {
    return lineItems;
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>Aquí está el mapeo de relaciones en <code>LineItem</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Id
@ManyToOne
@JoinColumn(name="ORDERID")
public CustomerOrder getCustomerOrder() {
    return customerOrder;
}
                  </code>
                </pre>
              </div>
            </div>
          </div>
          <div class="sect3" id="GIQUD">
            <h4 id="unidirectional-relationships">Relaciones Unidireccionales</h4>
            <div class="paragraph">
              <p>
                <code>LineItem</code> tiene un campo, <code>vendorPart</code>, que tiene una relación 
                unidireccional de muchos a uno con <code>VendorPart</code>. Es decir, no hay ningún campo en 
                la entidad de destino en esta relación:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@JoinColumn(name="VENDORPARTNUMBER")
@ManyToOne
public VendorPart getVendorPart() {
    return vendorPart;
}
                  </code>
                </pre>
              </div>
            </div>
          </div>
        </div>
        <div class="sect2" id="GIQQY">
          <h3 id="primary-keys-in-the-order-application">Claves Primarias en la Aplicación order</h3>
          <div class="paragraph">
            <p>
              La aplicación <code>order</code> utiliza varios tipos de claves primarias: claves primarias de 
              un solo valor, claves primarias generadas y claves primarias compuestas.
            </p>
          </div>
          <div class="paragraph">
            <p>Aquí se tratan los siguientes temas:</p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p><a href="#GIQUV">Claves Primarias Generadas</a></p>
              </li>
              <li>
                <p><a href="#GIQUF">Claves Primarias Compuestas</a></p>
              </li>
            </ul>
          </div>
          <div class="sect3" id="GIQUV">
            <h4 id="generated-primary-keys">Claves Primarias Generadas</h4>
            <div class="paragraph">
              <p>
                <code>VendorPart</code> utiliza un valor de clave principal generado. Es decir, la aplicación 
                no asigna valores de clave principal para las entidades, sino que depende del proveedor de 
                persistencia para generar los valores de clave principal. La anotación <code
                  >@GeneratedValue</code> se usa para especificar que una entidad usará una clave primaria 
                generada.
              </p>
            </div>
            <div class="paragraph">
              <p>
                En <code>VendorPart</code>, el siguiente código especifica la configuración para generar 
                valores de clave principal:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@TableGenerator(
    name="vendorPartGen",
    table="PERSISTENCE_ORDER_SEQUENCE_GENERATOR",
    pkColumnName="GEN_KEY",
    valueColumnName="GEN_VALUE",
    pkColumnValue="VENDOR_PART_ID",
    allocationSize=10)
@Id
@GeneratedValue(strategy=GenerationType.TABLE, generator="vendorPartGen")
public Long getVendorPartNumber() {
    return vendorPartNumber;
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                La anotación <code>@TableGenerator</code> se utiliza junto con el elemento 
                <code>strategy=TABLE</code> de <code>@GeneratedValue</code>. Es decir, la estrategia utilizada 
                para generar las claves primarias es utilizar una tabla en la base de datos. La anotación 
                <code>@TableGenerator</code> se utiliza para configurar los ajustes de la tabla generadora. El 
                elemento de nombre establece el nombre del generador, que es <code>vendorPartGen</code> en 
                <code>VendorPart</code>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                La tabla <code>PERSISTENCE_ORDER_SEQUENCE_GENERATOR</code>, cuyas dos columnas son 
                <code>GEN_KEY</code> y <code>GEN_VALUE</code>, almacenará los valores de clave principal 
                generados. Esta tabla podría usarse para generar las claves principales de otras entidades, 
                por lo que el elemento <code>pkColumnValue</code> se establece en <code>VENDOR_PART_ID</code> 
                para distinguir las claves principales generadas por esta entidad de las claves principales 
                generadas por otras entidades. El elemento <code>allocationSize</code> especifica la cantidad 
                a incrementar cuando se asignan valores de clave principal. En este caso, la clave principal 
                de cada <code>VendorPart</code> se incrementará en 10.
              </p>
            </div>
            <div class="paragraph">
              <p>
                El campo de clave principal <code>vendorPartNumber</code> es de tipo <code>Long</code>, ya que 
                el campo de clave principal generado debe ser de tipo integral.
              </p>
            </div>
          </div>
          <div class="sect3" id="GIQUF">
            <h4 id="compound-primary-keys">Claves Primarias Compuestas</h4>
            <div class="paragraph">
              <p>
                Una clave primaria compuesta se compone de varios campos y sigue los requisitos descritos en 
                <a href="persistence-intro002.html#BNBQF">Claves Primarias en las Entidades</a>. Para usar una 
                clave principal compuesta, debe crear una clase contenedora.
              </p>
            </div>
            <div class="paragraph">
              <p>
                En <code>order</code>, dos entidades usan claves primarias compuestas: <code>Part</code> y 
                <code>LineItem</code>.
              </p>
            </div>
            <div class="ulist">
              <ul>
                <li>
                  <p>
                    <code>Part</code> utiliza la clase contenedora <code>PartKey</code>. La clave principal de 
                    <code>Part</code> es una combinación del número de pieza y el número de revisión. 
                    <code>PartKey</code> encapsula esta clave principal.
                  </p>
                </li>
                <li>
                  <p>
                    <code>LineItem</code> usa la clase <code>LineItemKey</code>. La clave principal de 
                    <code>LineItem</code> es una combinación del número de pedido y el número de artículo. 
                    <code>LineItemKey</code> encapsula esta clave principal.
                  </p>
                </li>
              </ul>
            </div>
            <div class="paragraph">
              <p>Esta es la clase contenedora de clave primaria compuesta <code>LineItemKey</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
package javaeetutorial.order.entity;
import java.io.Serializable;
public final class LineItemKey implements Serializable {
    private Integer customerOrder;
    private int itemId;
    public LineItemKey() {}
    public LineItemKey(Integer order, int itemId) {
        this.setCustomerOrder(order);
        this.setItemId(itemId);
    }
    @Override
    public int hashCode() {
        return ((this.getCustomerOrder() == null
                ? 0 : this.getCustomerOrder().hashCode())
                ^ ((int) this.getItemId()));
    }
    @Override
    public boolean equals(Object otherOb) {
        if (this == otherOb) {
            return true;
        }
        if (!(otherOb instanceof LineItemKey)) {
            return false;
        }
        LineItemKey other = (LineItemKey) otherOb;
        return ((this.getCustomerOrder() == null
                ? other.getCustomerOrder == null : this.getOrderId()
                .equals(other.getCustomerOrder()))
                &amp;&amp; (this.getItemId == oother.getItemId()));
    }
    @Override
    public String toString() {
        return "" + getCustomerOrder() + "-" + getItemId();
    }
    public Integer getCustomerOrder() {
        return customerOrder;
    }
    public void setCustomerOrder(Integer order) {
        this.customerOrder = order;
    }
    public int getItemId() {
        return itemId;
    }
    public void setItemId(int itemId) {
        this.itemId = itemId;
    }
}
                </code></pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                La anotación <code>@IdClass</code> se utiliza para especificar la clase de clave principal en 
                la clase de entidad. En <code>LineItem</code>, <code>@IdClass</code> se usa de la siguiente 
                manera:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@IdClass(LineItemKey.class)
@Entity
...
public class LineItem implements Serializable {
    ...
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Los dos campos en <code>LineItem</code> están etiquetados con la anotación <code>@Id</code> 
                para marcar esos campos como parte de la clave principal compuesta:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Id
public int getItemId() {
    return itemId;
}
...
@Id
@ManyToOne
@JoinColumn(name="ORDERID")
public CustomerOrder getCustomerOrder() {
    return customerOrder;
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Para <code>customerOrder</code>, también usa la anotación <code>@JoinColumn</code> para 
                especificar el nombre de la columna en la tabla y que esta columna es una clave externa 
                superpuesta que apunta a <code>PERSISTENCE_ORDER_CUSTOMERORDER</code> columna 
                <code>ORDERID</code> de la tabla (ver 
                <a href="#GIQTJ">
                  Relación Uno a Varios Asignada a Claves Primarias y Externas Superpuestas</a>). Es decir, 
                <code>customerOrder</code> será establecido por la entidad <code>CustomerOrder</code>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                En el constructor de <code>LineItem</code>, el número de línea de artículo 
                (<code>LineItem.itemId</code>) se establece mediante el método <code
                  >CustomerOrder.getNextId</code>:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
public LineItem(CustomerOrder order, int quantity, VendorPart vendorPart) {
    this.customerOrder = order;
    this.itemId = order.getNextId();
    this.quantity = quantity;
    this.vendorPart = vendorPart;
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                <code>CustomerOrder.getNextId</code> cuenta el número de elementos de línea actuales, agrega 1 
                y devuelve ese número:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Transient
public int getNextId() {
    return this.lineItems.size() + 1;
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                <code>Part</code> requiere la anotación <code>@Column</code> en los dos campos que componen la 
                clave primaria compuesta de <code>Part</code>, porque la clave principal compuesta de 
                <code>Part</code> es una clave principal superpuesta/clave externa:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@IdClass(PartKey.class)
@Entity
...
public class Part implements Serializable {
    ...
    @Id
    @Column(nullable=false)
    public String getPartNumber() {
        return partNumber;
    }
    ...
    @Id
    @Column(nullable=false)
    public int getRevision() {
        return revision;
    }
    ...
}
                </code></pre>
              </div>
            </div>
          </div>
        </div>
        <div class="sect2" id="GIQTL">
          <h3 id="entity-mapped-to-more-than-one-database-table">
            Entidad Asignada a Más de Una Tabla de Base de Datos
          </h3>
          <div class="paragraph">
            <p>
              Los campos de <code>Part</code> se asignan a más de una tabla de base de datos: 
              <code>PERSISTENCE_ORDER_PART</code> y <code>PERSISTENCE_ORDER_PART_DETAIL</code>. La tabla 
              <code>PERSISTENCE_ORDER_PART_DETAIL</code> contiene la especificación y los esquemas de la 
              pieza. La anotación <code>@SecondaryTable</code> se usa para especificar la tabla secundaria:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
...
@Entity
@Table(name="PERSISTENCE_ORDER_PART")
@SecondaryTable(name="PERSISTENCE_ORDER_PART_DETAIL", pkJoinColumns={
    @PrimaryKeyJoinColumn(name="PARTNUMBER",
        referencedColumnName="PARTNUMBER"),
    @PrimaryKeyJoinColumn(name="REVISION",
        referencedColumnName="REVISION")
})
public class Part implements Serializable {
    ...
}
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              <code>PERSISTENCE_ORDER_PART_DETAIL</code> y <code>PERSISTENCE_ORDER_PART</code> comparten los 
              mismos valores de clave principal. El elemento <code>pkJoinColumns</code> de 
              <code>@SecondaryTable</code> se usa para especificar que las columnas de clave principal de 
              <code>PERSISTENCE_ORDER_PART_DETAIL</code> son claves externas para 
              <code>PERSISTENCE_ORDER_PART</code>. La anotación <code>@PrimaryKeyJoinColumn</code> establece 
              los nombres de las columnas de la clave principal y especifica a qué columna de la tabla 
              principal hace referencia la columna. En este caso, los nombres de las columnas de clave 
              principal para <code>PERSISTENCE_ORDER_PART_DETAIL</code> y <code>PERSISTENCE_ORDER_PART</code> 
              son los mismos: <code>PARTNUMBER</code> y <code>REVISION</code>, respectivamente.
            </p>
          </div>
        </div>
        <div class="sect2" id="GIQUE">
          <h3 id="cascade-operations-in-the-order-application">
            Operaciones en Cascada en la Aplicación order
          </h3>
          <div class="paragraph">
            <p>
              Las entidades que tienen relaciones con otras entidades a menudo dependen de la existencia de la 
              otra entidad en la relación. Por ejemplo, una línea de pedido es parte de un pedido; si se 
              elimina el pedido, también se debe eliminar la línea de pedido. Esto se denomina relación de 
              eliminación en cascada.
            </p>
          </div>
          <div class="paragraph">
            <p>
              En <code>order</code>, hay dos dependencias de eliminación en cascada en las relaciones de 
              entidad. Si se elimina el <code>CustomerOrder</code> con el que está relacionado un 
              <code>LineItem</code>, el <code>LineItem</code> también debe eliminarse. Si se elimina el 
              <code>Vendor</code> con el que está relacionado un <code>VendorPart</code>, también se debe 
              eliminar el <code>VendorPart</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Las operaciones en cascada para las relaciones entre entidades se especifican configurando el 
              elemento <code>cascade</code> en el lado inverso (no propietario) de la relación. El elemento de 
              cascada se establece en <code>ALL</code> en el caso de <code>CustomerOrder.lineItems</code>. 
              Esto significa que todas las operaciones de persistencia (eliminaciones, actualizaciones, etc.) 
              se distribuyen en cascada desde los pedidos hasta las líneas de pedido.
            </p>
          </div>
          <div class="paragraph">
            <p>Aquí está el mapeo de relaciones en <code>CustomerOrder</code>:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
@OneToMany(cascade=ALL, mappedBy="customerOrder")
public Collection&lt;LineItem&gt; getLineItems() {
    return lineItems;
}
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>Aquí está el mapeo de relaciones en <code>LineItem</code>:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Id
@ManyToOne
@JoinColumn(name="ORDERID")
public CustomerOrder getCustomerOrder() {
    return customerOrder;
}
                </code>
              </pre>
            </div>
          </div>
        </div>
        <div class="sect2" id="GIQSC">
          <h3 id="blob-and-clob-database-types-in-the-order-application">
            Tipos de Base de Datos BLOB y CLOB en la Aplicación order
          </h3>
          <div class="paragraph">
            <p>
              La tabla <code>PARTDETAIL</code> en la base de datos tiene una columna, <code>DRAWING</code>, 
              de tipo <code>BLOB</code>. <code>BLOB</code> significa objetos binarios grandes, que se utilizan 
              para almacenar datos binarios, como una imagen. La columna <code>DRAWING</code> se asigna al 
              campo <code>Part.drawing</code> de tipo <code>java.io.Serializable</code>. La anotación 
              <code>@Lob</code> se usa para indicar que el campo es un objeto grande:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Column(table="PERSISTENCE_ORDER_PART_DETAIL")
@Lob
public Serializable getDrawing() {
    return drawing;
}
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              <code>PERSISTENCE_ORDER_PART_DETAIL</code> también tiene una columna, 
              <code>SPECIFICATION</code>, de tipo <code>CLOB</code>. <code>CLOB</code> significa objetos de 
              caracteres grandes, que se utilizan para almacenar cadenas de datos demasiado grandes para 
              almacenarse en una columna <code>VARCHAR</code>. <code>SPECIFICATION</code> se asigna al campo 
              <code>Part.specification</code> de tipo <code>java.lang.String</code>. La anotación 
              <code>@Lob</code> también se usa aquí para indicar que el campo es un objeto grande:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Column(table="PERSISTENCE_ORDER_PART_DETAIL")
@Lob
public String getSpecification() {
    return specification;
}
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Ambos campos usan la anotación <code>@Column</code> y establecen el elemento <code>table</code> 
              en la tabla secundaria.
            </p>
          </div>
        </div>
        <div class="sect2" id="GIQUM">
          <h3 id="temporal-types-in-the-order-application">Tipos Temporales en la Aplicación order</h3>
          <div class="paragraph">
            <p>
              La propiedad persistente <code>CustomerOrder.lastUpdate</code>, que es de tipo 
              <code>java.util.Date</code>, se asigna al campo de base de datos 
              <code>PERSISTENCE_ORDER_CUSTOMERORDER.LASTUPDATE</code>, que es del tipo SQL 
              <code>TIMESTAMP</code>. Para garantizar la asignación adecuada entre estos tipos, debe utilizar 
              la anotación <code>@Temporal</code> con el tipo temporal adecuado especificado en el elemento de 
              <code>@Temporal</code>. Los elementos de <code>@Temporal</code> son del tipo 
              <code>javax.persistence.TemporalType</code>. Los posibles valores son
            </p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p><code>DATE</code>, que se asigna a <code>java.sql.Date</code></p>
              </li>
              <li>
                <p><code>TIME</code>, que se asigna a <code>java.sql.Time</code></p>
              </li>
              <li>
                <p><code>TIMESTAMP</code>, que se asigna a <code>java.sql.Timestamp</code></p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>Aquí está la sección relevante de <code>CustomerOrder</code>:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Temporal(TIMESTAMP)
public Date getLastUpdate() {
    return lastUpdate;
}
                </code>
              </pre>
            </div>
          </div>
        </div>
        <div class="sect2" id="GIQQV">
          <h3 id="managing-the-order-applications-entities">
            Gestionando las Entidades de la Aplicación order
          </h3>
          <div class="paragraph">
            <p>
              El bean de sesión con estado <code>RequestBean</code> contiene la lógica de negocio y gestiona 
              las entidades de <code>order</code>. <code>RequestBean</code> usa la anotación 
              <code>@PersistenceContext</code> para recuperar una instancia del administrador de entidades, 
              que se usa para administrar las entidades de <code>order</code> en los métodos de negocio de 
              <code>RequestBean</code>:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
@PersistenceContext
private EntityManager em;
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Esta instancia de <code>EntityManager</code> es un administrador de entidades gestionado por 
              contenedor, por lo que el contenedor se encarga de todas las transacciones involucradas en la 
              administración de las entidades de <code>order</code>.
            </p>
          </div>
          <div class="sect3" id="GIQRR">
            <h4 id="creating-entities">Crear Entidades</h4>
            <div class="paragraph">
              <p>
                El método de negocio <code>RequestBean.createPart</code> crea una nueva entidad 
                <code>Part</code>. El método <code>EntityManager.persist</code> se usa para conservar la 
                entidad recién creada en la base de datos:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
Part part = new Part(partNumber,
        revision,
        description,
        revisionDate,
        specification,
        drawing);
em.persist(part);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El bean de sesión singleton <code>ConfigBean</code> se utiliza para inicializar los datos en 
                <code>order</code>. <code>ConfigBean</code> se anota con <code>@Startup</code>, lo que indica 
                que el contenedor EJB debe crear <code>ConfigBean</code> cuando se implementa 
                <code>order</code>. El método <code>createData</code> se anota con 
                <code>@PostConstruct</code> y crea las entidades iniciales utilizadas por <code>order</code> 
                llamando a los métodos de negocio de <code>RequestBean</code>.
              </p>
            </div>
          </div>
          <div class="sect3" id="GIQQC">
            <h4 id="finding-entities">Buscar Entidades</h4>
            <div class="paragraph">
              <p>
                El método de negocio <code>RequestBean.getOrderPrice</code> devuelve el precio de un pedido 
                determinado en función del <code>orderId</code>. El método <code>EntityManager.find</code> se 
                utiliza para recuperar la entidad de la base de datos:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
CustomerOrder order = em.find(CustomerOrder.class, orderId);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El primer argumento de <code>EntityManager.find</code> es la clase de entidad y el segundo es 
                la clave principal.
              </p>
            </div>
          </div>
          <div class="sect3" id="GIQUK">
            <h4 id="setting-entity-relationships">Establecer Relaciones Entre Entidades</h4>
            <div class="paragraph">
              <p>
                El método de negocio <code>RequestBean.createVendorPart</code> crea un 
                <code>VendorPart</code> asociado con un <code>Vendor</code> en particular. El método 
                <code>EntityManager.persist</code> se usa para conservar la entidad <code>VendorPart</code> 
                recién creada en la base de datos, y los métodos <code>VendorPart.setVendor</code> y 
                <code>Vendor.setVendorPart</code> se utilizan para asociar el <code>VendorPart</code> con el 
                <code>Vendor</code>:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
PartKey pkey = new PartKey();
pkey.setPartNumber(partNumber);
pkey.setRevision(revision);
Part part = em.find(Part.class, pkey);
VendorPart vendorPart = new VendorPart(description, price, part);
em.persist(vendorPart);
Vendor vendor = em.find(Vendor.class, vendorId);
vendor.addVendorPart(vendorPart);
vendorPart.setVendor(vendor);
                  </code>
                </pre>
              </div>
            </div>
          </div>
          <div class="sect3" id="GIQSV">
            <h4 id="using-queries">Usar Consultas</h4>
            <div class="paragraph">
              <p>
                El método de negocio <code>RequestBean.adjustOrderDiscount</code> actualiza el descuento 
                aplicado a todos los pedidos. Este método utiliza la consulta con nombre 
                <code>findAllOrders</code>, definida en <code>CustomerOrder</code>:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@NamedQuery(
    name="findAllOrders",
    query="SELECT co FROM CustomerOrder co " +
          "ORDER BY co.orderId"
)
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El método <code>EntityManager.createNamedQuery</code> se utiliza para ejecutar la consulta. 
                Debido a que la consulta devuelve una <code>List</code> de todas las órdenes, se usa el 
                método <code>Query.getResultList</code>:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
List orders = em.createNamedQuery(
        "findAllOrders")
        .getResultList();
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El método de negocio <code>RequestBean.getTotalPricePerVendor</code> devuelve el precio total 
                de todas las piezas para un proveedor en particular. Este método utiliza un parámetro con 
                nombre, <code>id</code>, definido en la consulta con nombre 
                <code>findTotalVendorPartPricePerVendor</code> definida en <code>VendorPart</code>:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@NamedQuery(
    name="findTotalVendorPartPricePerVendor",
    query="SELECT SUM(vp.price) " +
    "FROM VendorPart vp " +
    "WHERE vp.vendor.vendorId = :id"
)
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Al ejecutar la consulta, se utiliza el método <code>Query.setParameter</code> para establecer 
                el parámetro con nombre <code>id</code> en el valor de <code>vendorId</code>, el parámetro en 
                <code>RequestBean.getTotalPricePerVendor</code>:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
return (Double) em.createNamedQuery(
    "findTotalVendorPartPricePerVendor")
    .setParameter("id", vendorId)
    .getSingleResult();
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El método <code>Query.getSingleResult</code> se usa para esta consulta porque la consulta 
                devuelve un solo valor.
              </p>
            </div>
          </div>
          <div class="sect3" id="GIQTW">
            <h4 id="removing-entities">Eliminar Entidades</h4>
            <div class="paragraph">
              <p>
                El método de negocio <code>RequestBean.removeOrder</code> elimina un pedido determinado de la 
                base de datos. Este método utiliza el método <code>EntityManager.remove</code> para eliminar 
                la entidad de la base de datos:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
CustomerOrder order = em.find(CustomerOrder.class, orderId);
em.remove(order);
                  </code>
                </pre>
              </div>
            </div>
          </div>
        </div>
        <div class="sect2" id="GIQUP">
          <h3 id="running-the-order-example">Ejecutar el Ejemplo order</h3>
          <div class="paragraph">
            <p>
              Puede usar el EID NetBeans o Maven para compilar, empaquetar, implementar y ejecutar la 
              aplicación <code>order</code>. Primero, creará las tablas de la base de datos en Apache Derby.
            </p>
          </div>
          <div class="paragraph">
            <p>Aquí se tratan los siguientes temas:</p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p><a href="#GIQSG">Para Ejecutar el Ejemplo order Usando el EID NetBeans</a></p>
              </li>
              <li>
                <p><a href="#GIQTY">Para Ejecutar el Ejemplo order Usando Maven</a></p>
              </li>
            </ul>
          </div>
          <div class="sect3" id="GIQSG">
            <h4 id="to-run-the-order-example-using-netbeans-ide">
              Para Ejecutar el Ejemplo order Usando el EID NetBeans
            </h4>
            <div class="olist arabic">
              <ol class="arabic">
                <li>
                  <p>
                    Asegúrese de que el servidor GlassFish se haya iniciado (consulte 
                    <a href="usingexamples002.html#BNADI">Arrancando y Parando el Servidor GlassFish</a>).
                  </p>
                </li>
                <li>
                  <p>
                    Si el servidor de la base de datos aún no se está ejecutando, inícielo siguiendo las 
                    instrucciones en 
                    <a href="usingexamples004.html#BNADK">Arrancando y Parando Apache Derby</a>.
                  </p>
                </li>
                <li>
                  <p>En el menú Archivo, elija Abrir proyecto.</p>
                </li>
                <li>
                  <p>En el cuadro de diálogo Abrir proyecto, vaya a:</p>
                  <div class="listingblock">
                    <div class="content">
                      <pre class="prettyprint highlight">
                        <code class="language-oac_no_warn" data-lang="oac_no_warn">
tut-install/examples/persistence
                        </code>
                      </pre>
                    </div>
                  </div>
                </li>
                <li>
                  <p>Seleccione la carpeta <code>order</code>.</p>
                </li>
                <li>
                  <p>Haga clic en Abrir proyecto.</p>
                </li>
                <li>
                  <p>
                    En la pestaña Proyectos, haga clic con el botón derecho en el proyecto <code>order</code> 
                    y seleccione Ejecutar.
                  </p>
                  <div class="paragraph">
                    <p>El EID NetBeans abre un navegador web en la siguiente URL:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre class="prettyprint highlight">
                        <code class="language-oac_no_warn" data-lang="oac_no_warn">
http://localhost:8080/order/
                        </code>
                      </pre>
                    </div>
                  </div>
                </li>
              </ol>
            </div>
          </div>
          <div class="sect3" id="GIQTY">
            <h4 id="to-run-the-order-example-using-maven">
              Para Ejecutar el Ejemplo order Usando Maven
            </h4>
            <div class="olist arabic">
              <ol class="arabic">
                <li>
                  <p>
                    Asegúrese de que el servidor GlassFish se haya iniciado (consulte 
                    <a href="usingexamples002.html#BNADI">Arrancando y Parando el Servidor GlassFish</a>).
                  </p>
                </li>
                <li>
                  <p>
                    Si el servidor de la base de datos aún no se está ejecutando, inícielo siguiendo las 
                    instrucciones en 
                    <a href="usingexamples004.html#BNADK">Arrancando y Parando Apache Derby</a>.
                  </p>
                </li>
                <li>
                  <p>En una ventana de terminal, vaya a:</p>
                  <div class="listingblock">
                    <div class="content">
                      <pre class="prettyprint highlight">
                        <code class="language-oac_no_warn" data-lang="oac_no_warn">
tut-install/examples/persistence/order/
                        </code>
                      </pre>
                    </div>
                  </div>
                </li>
                <li>
                  <p>Introduzca el siguiente comando:</p>
                  <div class="listingblock">
                    <div class="content">
                      <pre class="prettyprint highlight">
                        <code class="language-oac_no_warn" data-lang="oac_no_warn">
mvn install
                        </code>
                      </pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>
                      Esto compila los archivos fuente y empaqueta la aplicación en un archivo WAR ubicado en 
                      tut-install`/examples/persistence/order/target/order.war`. Luego, el archivo WAR se 
                      implementa en su instancia de servidor GlassFish.
                    </p>
                  </div>
                </li>
                <li>
                  <p>
                    Para crear y actualizar los datos del pedido, abra un navegador web en la siguiente URL:
                  </p>
                  <div class="listingblock">
                    <div class="content">
                      <pre class="prettyprint highlight">
                        <code class="language-oac_no_warn" data-lang="oac_no_warn">
http://localhost:8080/order/
                        </code>
                      </pre>
                    </div>
                  </div>
                </li>
              </ol>
            </div>
          </div>
        </div>
      </div>
    </div>
    <hr />
    <table width="90%" id="bottom-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>		
        <td align="left">
          <a href="persistence-basicexamples001.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="persistence-basicexamples003.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class="vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <span id="copyright">
      <a href="img/cpyr.adoc">
        <img src="img/oracle.gif" height="10" alt="Logo de Oracle" />&nbsp;			
        <span>
          Copyright&nbsp;&copy;&nbsp;2017,&nbsp;Oracle&nbsp;y/o&nbsp;sus&nbsp;afiliados.&nbsp;Todos&nbsp;los&nbsp;
          derechos&nbsp;reservados.
        </span>
      </a>
    </span>
  </body>
</html>
