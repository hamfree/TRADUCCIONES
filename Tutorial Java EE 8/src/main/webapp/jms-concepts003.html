<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8"/>
    <title>El Modelo de Programación de la IPA de JMS</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="css/style.css" rel="stylesheet">
    <script src="https://use.fontawesome.com/96c4d89611.js"></script>
  </head>
  <body>
    <table id="doc-title" cellspacing="0" cellpadding="0">
      <tr>
        <td align="left" valign="top">
          <b>Plataforma Java, Edición Empresarial (Java EE) 8</b><br />
          <b>El Tutorial de Java EE</b>
        </td>
      </tr>
    </table>
    <hr />
    <table width="90%" id="top-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>
        <td align="left">
          <a href="jms-concepts002.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="jms-concepts004.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class=" vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <div class="sect1" id="BNCEH">
      <h2 id="the-jms-api-programming-model">El Modelo de Programación de la IPA de JMS</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>
            Los componentes básicos de una aplicación JMS son
          </p>
        </div>
        <div class="ulist">
          <ul>
            <li>
              <p>Objetos administrados: fábricas de conexiones y destinos</p>
            </li>
            <li>
              <p>Conexiones</p>
            </li>
            <li>
              <p>Sesiones</p>
            </li>
            <li>
              <p>Objetos <code>JMSContext</code>, que combinan una conexión y una sesión en un objeto</p>
            </li>
            <li>
              <p>Productores de mensajes</p>
            </li>
            <li>
              <p>Consumidores de mensajes</p>
            </li>
            <li>
              <p>Mensajes</p>
            </li>
          </ul>
        </div>
        <div class="paragraph">
          <p>
            La <a href="#BNCEI">Figura 48-5</a> muestra cómo encajan todos estos objetos en una aplicación 
            cliente JMS.
          </p>
        </div>
        <div id="BNCEI" class="paragraph">
          <div class="title"><strong>Figura 48-5 El Modelo de Programación de la IPA de JMS</strong></div>
          <p>
            <span class="image">
              <img src="img/javaeett_dt_030.png" 
                   alt="Diagrama del modelo de programación de la IPA de JMS: fábrica de conexiones, 
                   JMSContext, conexión, sesión, productor de mensajes, consumidor de mensajes, mensajes y 
                   destinos">
            </span>
          </p>
        </div>
        <div class="paragraph">
          <p>
            JMS también proporciona navegadores de colas, objetos que permiten que una aplicación busque 
            mensajes en una cola.
          </p>
        </div>
        <div class="paragraph">
          <p>
            Esta sección describe todos estos objetos brevemente y proporciona ejemplos de comandos y 
            fragmentos de código que muestran cómo crear y usar los objetos. La última subsección describe 
            brevemente el manejo de excepciones de la IPA de JMS.
          </p>
        </div>
        <div class="paragraph">
          <p>
            Los ejemplos que muestran cómo combinar todos estos objetos en aplicaciones aparecen en el 
            <a href="jms-examples.html#BNCGV">Capítulo 49, "Ejemplos del Servicio de Mensajería de Java,"</a> 
            comenzando con <a href= "jms-examples003.html#BNCFA">Escritura de Aplicaciones JMS Simples</a>. 
            Para obtener más detalles, consulte la documentación de la IPA de JMS, parte de la documentación 
            de la IPA de Java EE.
          </p>
        </div>
        <div class="sect2" id="BNCEJ">
          <h3 id="jms-administered-objects">Objetos Administrados por JMS</h3>
          <div class="paragraph">
            <p>
              Dos partes de una aplicación JMS, los destinos y las fábricas de conexiones, normalmente se 
              mantienen de forma administrativa en lugar de mediante programación. Es probable que la 
              tecnología subyacente a estos objetos sea muy diferente de una implementación de la IPA de JMS a 
              otra. Por lo tanto, la gestión de estos objetos pertenece a otras tareas administrativas que 
              varían de un proveedor a otro.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Los clientes de JMS acceden a objetos administrados a través de interfaces que son portables, 
              por lo que una aplicación de cliente puede ejecutarse con poco o ningún cambio en más de una 
              implementación de la IPA de JMS. Normalmente, un administrador configura los objetos 
              administrados en un espacio de nombres JNDI y los clientes JMS acceden a ellos mediante la 
              inyección de recursos.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Con el servidor GlassFish, puede usar el comando <code>asadmin create-jms-resource</code> o la 
              consola de administración para crear objetos administrados por JMS en forma de recursos de 
              conector. También puede especificar los recursos en un archivo llamado 
              <code>glassfish-resources.xml</code> que puede agrupar con una aplicación.
            </p>
          </div>
          <div class="paragraph">
            <p>
              El EID NetBeans proporciona un asistente que le permite crear recursos JMS para el servidor 
              GlassFish. Ver 
              <a href="jms-examples003.html#GKTJS">Creación de Objetos Administrados JMS</a> para más 
              detalles.
            </p>
          </div>
          <div class="paragraph">
            <p>
              La especificación de la plataforma Java EE permite que un desarrollador cree objetos 
              administrados utilizando anotaciones o elementos descriptores de implementación. Los objetos 
              creados de esta manera son específicos de la aplicación para la que se crean. Ver 
              <a href="jms-concepts005.html#BABHFBDH">Creación de Recursos para Aplicaciones de Java EE</a> 
              para más detalles. Las definiciones en un descriptor de implementación anulan las especificadas 
              por las anotaciones.
            </p>
          </div>
          <div class="sect3" id="BNCEK">
            <h4 id="jms-connection-factories">Factorías de Conexión de JMS</h4>
            <div class="paragraph">
              <p>
                Una fábrica de conexiones es el objeto que utiliza un cliente para crear una conexión con un 
                proveedor. Una fábrica de conexiones encapsula un conjunto de parámetros de configuración de 
                conexión que ha definido un administrador. Cada fábrica de conexiones es una instancia de la 
                interfaz <code>ConnectionFactory</code>, <code>QueueConnectionFactory</code> o 
                <code>TopicConnectionFactory</code>. Para aprender a crear fábricas de conexiones, consulte 
                <a href="jms-examples003.html#GKTJS">Creación de Objetos Administrados JMS</a>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Al comienzo de un programa de cliente JMS, generalmente inyecta un recurso de fábrica de 
                conexiones en un objeto <code>ConnectionFactory</code>. Un servidor Java EE debe proporcionar 
                una fábrica de conexiones JMS con el nombre JNDI lógico 
                <code>java:comp/DefaultJMSConnectionFactory</code>. El nombre JNDI real será específico de la 
                implementación.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Por ejemplo, el siguiente fragmento de código busca la fábrica de conexiones JMS 
                predeterminada y la asigna a un objeto <code>ConnectionFactory</code>:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Resource(lookup = "java:comp/DefaultJMSConnectionFactory")
private static ConnectionFactory connectionFactory;
                  </code>
                </pre>
              </div>
            </div>
          </div>
          <div class="sect3" id="BNCEL">
            <h4 id="jms-destinations">Destinos de JMS</h4>
            <div class="paragraph">
              <p>
                Un destino es el objeto que utiliza un cliente para especificar el destino de los mensajes que 
                produce y el origen de los mensajes que consume. En el estilo de mensajería PTP, los destinos 
                se denominan colas. En el estilo de mensajería pub/sub, los destinos se denominan temas. Una 
                aplicación JMS puede utilizar varias colas o temas (o ambos). Para aprender a crear recursos 
                de destino, consulte 
                <a href="jms-examples003.html#GKTJS">Creación de Objetos Administrados JMS</a>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Para crear un destino con el servidor GlassFish, cree un recurso de destino JMS que 
                especifique un nombre JNDI para el destino.
              </p>
            </div>
            <div class="paragraph">
              <p>
                En la implementación del servidor GlassFish de JMS, cada recurso de destino hace referencia a 
                un destino físico. Puede crear un destino físico de forma explícita, pero si no lo hace, el 
                servidor de aplicaciones lo crea cuando es necesario y lo elimina cuando elimina el recurso de 
                destino.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Además de inyectar un recurso de fábrica de conexiones en un programa cliente, normalmente 
                inyecta un recurso de destino. A diferencia de las fábricas de conexiones, los destinos son 
                específicos del estilo de mensajería PTP o pub/sub. Para crear una aplicación que le permita 
                usar el mismo código para temas y colas, asigne el destino a un objeto 
                <code>Destination</code>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                El código siguiente especifica dos recursos, una cola y un tema. Los nombres de los recursos 
                se asignan a los recursos de destino creados en el espacio de nombres JNDI:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Resource(lookup = "jms/MyQueue")
private static Queue queue;
@Resource(lookup = "jms/MyTopic")
private static Topic topic;
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                En una aplicación Java EE, los objetos administrados por JMS normalmente se colocan en el 
                subcontexto de nombres <code>jms</code>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Con las interfaces comunes, puede mezclar o combinar destinos y fábricas de conexiones. Es 
                decir, además de usar la interfaz <code>ConnectionFactory</code>, puede inyectar un recurso 
                <code>QueueConnectionFactory</code> y usarlo con un <code>Topic</code>, y puede inyectar un 
                recurso <code>TopicConnectionFactory</code> y utilícelo con una <code>Queue</code>. El 
                comportamiento de la aplicación dependerá del tipo de destino que utilice y no del tipo de 
                fábrica de conexiones que utilice.
              </p>
            </div>
          </div>
        </div>
        <div class="sect2" id="BNCEM">
          <h3 id="connections">Conexiones</h3>
          <div class="paragraph">
            <p>
              Una conexión encapsula una conexión virtual con un proveedor JMS. Por ejemplo, una conexión 
              podría representar un socket TCP/IP abierto entre un cliente y un demonio de servicio del 
              proveedor. Utilice una conexión para crear una o más sesiones.
            </p>
          </div>
          <table class="tableblock frame-all grid-all spread">
            <colgroup>
              <col style="width: 100%;">
            </colgroup>
            <tbody>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <div>
                    <div class="paragraph">
                      <p><strong>Nota</strong>:</p>
                    </div>
                    <div class="paragraph">
                      <p>
                        En la plataforma Java EE, la capacidad de crear varias sesiones desde una sola 
                        conexión está limitada a los clientes de aplicaciones. En los componentes web y 
                        Enterprise Bean, una conexión no puede crear más de una sesión.
                      </p>
                    </div>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
          <div class="paragraph">
            <p>
              Normalmente crea una conexión creando un objeto <code>JMSContext</code>. Ver 
              <a href="#BABGDFEA">Objetos JMSContext</a> para más detalles.
            </p>
          </div>
        </div>
        <div class="sect2" id="BNCEN">
          <h3 id="sessions">Sesiones</h3>
          <div class="paragraph">
            <p>
              Una sesión es un contexto de subproceso único para producir y consumir mensajes.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Normalmente crea una sesión (así como una conexión) creando un objeto <code>JMSContext</code>. 
              Ver <a href="#BABGDFEA">Objetos JMSContext</a> para más detalles. Las sesiones se utilizan para 
              crear productores de mensajes, consumidores de mensajes, mensajes, examinadores de colas y 
              destinos temporales.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Las sesiones serializan la ejecución de escuchas de mensajes; para más detalles, consulte 
              <a href="#BNCEQ">Oyentes de Mensajes de JMS</a>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Una sesión proporciona un contexto transaccional con el que agrupar un conjunto de envíos y 
              recepciones en una unidad atómica de trabajo. Para obtener más información, consulte 
              <a href="jms-concepts004.html#BNCGH">Uso de Transacciones Locales de JMS</a>.
            </p>
          </div>
        </div>
        <div class="sect2" id="BABGDFEA">
          <h3 id="jmscontext-objects">Objetos JMSContext</h3>
          <div class="paragraph">
            <p>
              Un objeto <code>JMSContext</code> combina una conexión y una sesión en un solo objeto. Es decir, 
              proporciona una conexión activa a un proveedor de JMS y un contexto de subproceso único para 
              enviar y recibir mensajes.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Utilice el <code>JMSContext</code> para crear los siguientes objetos:
            </p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>Productores de mensajes</p>
              </li>
              <li>
                <p>Consumidores de mensajes</p>
              </li>
              <li>
                <p>Mensajes</p>
              </li>
              <li>
                <p>Navegadores de colas</p>
              </li>
              <li>
                <p>
                  Colas y temas temporales (ver 
                  <a href="jms-concepts004.html#BNCGB">Creación de Destinos Temporales</a>)
                </p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>
              Puede crear un <code>JMSContext</code> en un bloque <code>try</code>-with-resources.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Para crear un <code>JMSContext</code>, llame al método <code>createContext</code> en la fábrica 
              de conexiones:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
JMSContext context = connectionFactory.createContext();
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Cuando se llama sin argumentos desde un cliente de aplicación o un cliente Java SE, o desde la 
              web Java EE o el contenedor EJB cuando no hay una transacción JTA activa en curso, el método 
              <code>createContext</code> crea una sesión sin transacción con un modo de reconocimiento de 
              <code>JMSContext.AUTO_ACKNOWLEDGE</code>. Cuando se llama sin argumentos desde la web o el 
              contenedor EJB cuando hay una transacción JTA activa en curso, el método 
              <code>createContext</code> crea una sesión con transacciones. Para obtener información sobre 
              cómo funcionan las transacciones JMS en aplicaciones Java EE, consulte 
              <a href="jms-concepts005.html#BNCGL">Uso de la IPA de JMS en Aplicaciones de Java EE</a>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Desde un cliente de aplicación o un cliente Java SE, también puede llamar al método 
              <code>createContext</code> con el argumento <code>JMSContext.SESSION_TRANSACTED</code> para 
              crear una sesión con transacciones:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
JMSContext context =
        connectionFactory.createContext(JMSContext.SESSION_TRANSACTED);
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              La sesión utiliza transacciones locales; consulte 
              <a href="jms-concepts004.html#BNCGH">Uso de Transacciones Locales de JMS</a> para obtener más 
              detalles.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Alternativamente, puede especificar un modo de reconocimiento no predeterminado; consulte 
              <a href="jms-concepts004.html#BNCFW">Control de la Confirmación del Mensaje</a> para obtener más 
              información.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Cuando usa un <code>JMSContext</code>, la entrega de mensajes normalmente comienza tan pronto 
              como crea un consumidor. Consulte <a href="#BNCEP">Consumidores de Mensajes de JMS</a> para 
              obtener más información.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Si crea un <code>JMSContext</code> en un bloque <code>try</code>-with-resources, no necesita 
              cerrarlo explícitamente. Se cerrará cuando el bloque <code>try</code> llegue a su fin. Asegúrese 
              de que su aplicación complete toda su actividad JMS dentro del bloque 
              <code>try</code>-with-resources. Si no usa un bloque <code>try</code>-with-resources, debe 
              llamar al método <code>close</code> en <code>JMSContext</code> para cerrar la conexión cuando la 
              aplicación ha terminado su trabajo.
            </p>
          </div>
        </div>
        <div class="sect2" id="BNCEO">
          <h3 id="jms-message-producers">Productores de Mensajes de JMS</h3>
          <div class="paragraph">
            <p>
              Un productor de mensajes es un objeto creado por un <code>JMSContext</code> o una sesión y se 
              usa para enviar mensajes a un destino. Un productor de mensajes creado por un 
              <code>JMSContext</code> implementa la interfaz <code>JMSProducer</code>. Podrías crearlo de esta 
              manera:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
try (JMSContext context = connectionFactory.createContext();) {
    JMSProducer producer = context.createProducer();
    ...
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Sin embargo, un <code>JMSProducer</code> es un objeto liviano que no consume recursos 
              significativos. Por esta razón, no necesita guardar el <code>JMSProducer</code> en una variable; 
              puede crear uno nuevo cada vez que envíe un mensaje. Envías mensajes a un destino específico 
              utilizando el método <code>send</code>. Por ejemplo:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
context.createProducer().send(dest, message);
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Puede crear el mensaje en una variable antes de enviarlo, como se muestra aquí, o puede crearlo 
              dentro de la llamada <code>send</code>. Consulte <a href="#BNCES">Mensajes de JMS</a> para 
              obtener más información.
            </p>
          </div>
        </div>
        <div class="sect2" id="BNCEP">
          <h3 id="jms-message-consumers">Consumidores de Mensajes de JMS</h3>
          <div class="paragraph">
            <p>
              Un consumidor de mensajes es un objeto creado por un <code>JMSContext</code> o una sesión y se 
              usa para recibir mensajes enviados a un destino. Un productor de mensajes creado por un 
              <code>JMSContext</code> implementa la interfaz <code>JMSConsumer</code>. La forma más sencilla 
              de crear un consumidor de mensajes es utilizar el método <code>JMSContext.createConsumer</code>:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
try (JMSContext context = connectionFactory.createContext();) {
    JMSConsumer consumer = context.createConsumer(dest);
    ...
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Un consumidor de mensajes permite que un cliente JMS registre interés en un destino con un 
              proveedor JMS. El proveedor de JMS gestiona la entrega de mensajes desde un destino a los 
              consumidores registrados del destino.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Cuando usa un <code>JMSContext</code> para crear un consumidor de mensajes, la entrega de 
              mensajes comienza tan pronto como haya creado el consumidor. Puede deshabilitar este 
              comportamiento llamando a <code>setAutoStart(false)</code> cuando crea el 
              <code>JMSContext</code> y luego llamando al método <code>start</code> explícitamente para 
              iniciar la entrega del mensaje. Si desea detener la entrega de mensajes temporalmente sin cerrar 
              la conexión, puede llamar al método <code>stop</code>; para reiniciar la entrega de mensajes, 
              llame a <code>start</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Utiliza el método <code>receive</code> para consumir un mensaje sincrónicamente. Puede usar este 
              método en cualquier momento después de crear el consumidor.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Si no especifica argumentos o un argumento de <code>0</code>, el método se bloquea 
              indefinidamente hasta que llega un mensaje:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
Message m = consumer.receive();
Message m = consumer.receive(0);
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Para un cliente simple, esto puede no importar. Pero si es posible que un mensaje no esté 
              disponible, use una recepción síncrona con un tiempo de espera: llame al método 
              <code>receive</code> con un argumento de tiempo de espera mayor que <code>0</code>. Un segundo 
              es un valor de tiempo de espera recomendado:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
Message m = consumer.receive(1000); // tiempo de espera después de un segundo
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Para habilitar la entrega de mensajes asincrónicos desde un cliente de aplicación o un cliente 
              Java SE, utilice un detector de mensajes, como se describe en la siguiente sección.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Puede usar el método <code>JMSContext.createDurableConsumer</code> para crear una suscripción de 
              tema duradera. Este método es válido solo si está utilizando un tema. Para más detalles, 
              consulte <a href="#BNCGD">Creación de Suscripciones Duraderas</a>. Para los temas, también puede 
              crear consumidores compartidos; ver 
              <a href="#BABJCIGJ">Creación de Suscripciones Compartidas</a>.
            </p>
          </div>
          <div class="sect3" id="BNCEQ">
            <h4 id="jms-message-listeners">Oyentes de Mensajes de JMS</h4>
            <div class="paragraph">
              <p>
                Un detector de mensajes es un objeto que actúa como un controlador de eventos asíncrono para 
                los mensajes. Este objeto implementa la interfaz <code>MessageListener</code>, que contiene un 
                método, <code>onMessage</code>. En el método <code>onMessage</code>, define las acciones que 
                se realizarán cuando llegue un mensaje.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Desde un cliente de aplicación o un cliente Java SE, registra el detector de mensajes con un 
                consumidor de mensajes específico utilizando el método <code>setMessageListener</code>. Por 
                ejemplo, si define una clase llamada <code>Listener</code> que implementa la interfaz 
                <code>MessageListener</code>, puede registrar el detector de mensajes de la siguiente manera:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
Listener myListener = new Listener();
consumer.setMessageListener(myListener);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Cuando comienza la entrega de mensajes, el proveedor de JMS llama automáticamente al método 
                <code>onMessage</code> del detector de mensajes cada vez que se entrega un mensaje. El método 
                <code>onMessage</code> toma un argumento de tipo <code>Message</code>, que su implementación 
                del método puede convertir a otro subtipo de mensaje según sea necesario (consulte 
                <a href="#BNCEW">Cuerpos del Mensaje</a>).
              </p>
            </div>
            <div class="paragraph">
              <p>
                En el contenedor web o EJB de Java EE, utiliza beans controlados por mensajes para la entrega 
                de mensajes asincrónicos. Un bean controlado por mensajes también implementa la interfaz 
                <code>MessageListener</code> y contiene un método <code>onMessage</code>. Para obtener más 
                información, consulte <a href="jms-concepts005.html#BNCGQ">
                  Uso de Beans Controlados por Mensajes para Recibir Mensajes de Forma Asíncrona</a>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Su método <code>onMessage</code> debe manejar todas las excepciones. Lanzar una 
                <code>RuntimeException</code> se considera un error de programación.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Para ver un ejemplo simple del uso de un detector de mensajes, consulte 
                <a href="jms-examples003.html#BNCFH">Uso de un Detector de Mensajes para la Entrega 
                  Asincrónica de Mensajes</a>. El <a href="jms-examples.html#BNCGV">Capítulo 49, "Ejemplos del 
                  Servicio de Mensajería de Java,"</a> contiene varios ejemplos más de escuchas de mensajes 
                y beans controlados por mensajes.
              </p>
            </div>
          </div>
          <div class="sect3" id="BNCER">
            <h4 id="jms-message-selectors">Selectores de Mensajes de JMS</h4>
            <div class="paragraph">
              <p>
                Si su aplicación de mensajería necesita filtrar los mensajes que recibe, puede usar un 
                selector de mensajes JMS, que permite que un consumidor de mensajes para un destino 
                especifique los mensajes que le interesan. Los selectores de mensajes asignan el trabajo de 
                filtrado de mensajes al proveedor JMS en lugar de a la aplicación. Para ver un ejemplo de una 
                aplicación que utiliza un selector de mensajes, consulte 
                <a href="jms-examples008.html#BNCGW">Envío de Mensajes Desde un Bean de Sesión a un MDB</a>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Un selector de mensajes es una <code>String</code> que contiene una expresión. La sintaxis de 
                la expresión se basa en un subconjunto de la sintaxis de expresión condicional de SQL92. El 
                selector de mensajes del ejemplo selecciona cualquier mensaje que tenga una propiedad 
                <code>NewsType</code> establecida en el valor <code>'Sports'</code> o <code>'Opinion'</code>:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
NewsType = 'Sports' OR NewsType = 'Opinion'
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Los métodos <code>createConsumer</code> y <code>createDurableConsumer</code>, así como los 
                métodos para crear consumidores compartidos, le permiten especificar un selector de mensajes 
                como argumento cuando crea un consumidor de mensajes.
              </p>
            </div>
            <div class="paragraph">
              <p>
                El consumidor de mensajes solo recibe mensajes cuyos encabezados y propiedades coincidan con 
                el selector. (Consulte <a href="#BNCET">Encabezados del Mensaje</a> y 
                <a href="#BNCEV">Propiedades del Mensaje</a>.) Un selector de mensajes no puede seleccionar 
                mensajes en función del contenido de el cuerpo del mensaje.
              </p>
            </div>
          </div>
          <div class="sect3" id="BABEEJJJ">
            <h4 id="consuming-messages-from-topics">Consumir Mensajes desde los Temas</h4>
            <div class="paragraph">
              <p>
                La semántica de consumir mensajes de temas es más compleja que la semántica de consumir 
                mensajes de colas.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Una aplicación consume mensajes de un tema al crear una suscripción en ese tema y crear un 
                consumidor en esa suscripción. Las suscripciones pueden ser duraderas o no duraderas y pueden 
                ser compartidas o no compartidas.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Se puede pensar en una suscripción como una entidad dentro del propio proveedor JMS, mientras 
                que un consumidor es un objeto JMS dentro de la aplicación.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Una suscripción recibirá una copia de cada mensaje que se envíe al tema después de crear la 
                suscripción, a menos que se especifique un selector de mensajes. Si se especifica un selector 
                de mensajes, solo se agregarán a la suscripción aquellos mensajes cuyas propiedades coincidan 
                con el selector de mensajes.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Las suscripciones no compartidas están restringidas a un solo consumidor. En este caso, todos 
                los mensajes de la suscripción se entregan a ese consumidor. Las suscripciones compartidas 
                permiten múltiples consumidores. En este caso, cada mensaje de la suscripción se entrega a un 
                solo consumidor. JMS no define cómo se distribuyen los mensajes entre múltiples consumidores 
                en la misma suscripción.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Las suscripciones pueden ser duraderas o no duraderas.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Una suscripción no duradera existe solo mientras haya un consumidor activo en la suscripción. 
                Esto significa que cualquier mensaje enviado al tema se agregará a la suscripción solo 
                mientras exista un consumidor y no esté cerrado.
              </p>
            </div>
            <div class="paragraph">
              <p>Una suscripción no duradera puede ser no compartida o compartida.</p>
            </div>
            <div class="ulist">
              <ul>
                <li>
                  <p>
                    Una suscripción no duradera no compartida no tiene nombre y puede tener solo un único 
                    objeto de consumidor asociado. Se crea automáticamente cuando se crea el objeto de 
                    consumidor. No se conserva y se elimina automáticamente cuando se cierra el objeto 
                    consumidor.
                  </p>
                  <div class="paragraph">
                    <p>
                      El método <code>JMSContext.createConsumer</code> crea un consumidor en una suscripción 
                      no duradera no compartida si se especifica un tema como destino.
                    </p>
                  </div>
                </li>
                <li>
                  <p>
                    Una suscripción no duradera compartida se identifica por nombre y un identificador de 
                    cliente opcional, y puede tener varios objetos de consumidor que consumen mensajes de 
                    ella. Se crea automáticamente cuando se crea el primer objeto de consumidor. No se 
                    conserva y se elimina automáticamente cuando se cierra el último objeto de consumidor. 
                    Consulte <a href="#BABJCIGJ">Creación de Suscripciones Compartidas</a> para obtener más 
                    información.
                  </p>
                </li>
              </ul>
            </div>
            <div class="paragraph">
              <p>
                A costa de mayores cargas, una suscripción puede ser duradera. Una suscripción duradera se 
                mantiene y continúa acumulando mensajes hasta que se elimina explícitamente, incluso si no hay 
                objetos de consumo que consuman mensajes de ella. Ver 
                <a href="#BNCGD">Creación de Suscripciones Duraderas</a> para más detalles.
              </p>
            </div>
          </div>
          <div class="sect3" id="BNCGD">
            <h4 id="creating-durable-subscriptions">Creación de Suscripciones Duraderas</h4>
            <div class="paragraph">
              <p>
                Para asegurarse de que una aplicación de publicación/suscripción reciba todos los mensajes 
                enviados, use suscripciones duraderas para los consumidores sobre el tema.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Al igual que una suscripción no duradera, una suscripción duradera puede compartirse o no 
                compartirse.
              </p>
            </div>
            <div class="ulist">
              <ul>
                <li>
                  <p>
                    Una suscripción duradera no compartida se identifica por nombre e identificador de cliente 
                    (que debe configurarse) y puede tener solo un único objeto de consumidor asociado.
                  </p>
                </li>
                <li>
                  <p>
                    Una suscripción duradera compartida se identifica por nombre y un identificador de cliente 
                    opcional, y puede tener varios objetos de consumidor que consumen mensajes de ella.
                  </p>
                </li>
              </ul>
            </div>
            <div class="paragraph">
              <p>
                Una suscripción duradera que existe pero que actualmente no tiene asociado un objeto de 
                consumidor no cerrado se describe como inactiva.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Puede usar el método <code>JMSContext.createDurableConsumer</code> para crear un consumidor en 
                una suscripción duradera no compartida. Una suscripción duradera no compartida solo puede 
                tener un consumidor activo a la vez.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Un consumidor identifica la suscripción duradera de la que consume mensajes especificando una 
                identidad única que conserva el proveedor de JMS. Los objetos de consumidor subsiguientes que 
                tienen la misma identidad reanudan la suscripción en el estado en que la dejó el consumidor 
                anterior. Si una suscripción duradera no tiene un consumidor activo, el proveedor de JMS 
                conserva los mensajes de la suscripción hasta que la suscripción los reciba o hasta que 
                caduquen.
              </p>
            </div>
            <div class="paragraph">
              <p>
                La identidad única de una suscripción duradera no compartida se establece definiendo lo 
                siguiente:
              </p>
            </div>
            <div class="ulist">
              <ul>
                <li>
                  <p>Un ID de cliente para la conexión.</p>
                </li>
                <li>
                  <p>Un tema y un nombre de suscripción para la suscripción.</p>
                </li>
              </ul>
            </div>
            <div class="paragraph">
              <p>
                Puede configurar el ID de cliente de forma administrativa para una fábrica de conexiones 
                específica del cliente mediante la línea de comandos o la Consola de administración. (En un 
                cliente de aplicación o un cliente Java SE, puede llamar a 
                <code>JMSContext.setClientID</code>).
              </p>
            </div>
            <div class="paragraph">
              <p>
                Después de usar esta fábrica de conexiones para crear el <code>JMSContext</code>, llame al 
                método <code>createDurableConsumer</code> con dos argumentos: el tema y una cadena que 
                especifica el nombre de la suscripción:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
String subName = "MySub";
JMSConsumer consumer = context.createDurableConsumer(myTopic, subName);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                La suscripción se activa después de crear el consumidor. Más tarde, puede cerrar el 
                consumidor:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
consumer.close();
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El proveedor de JMS almacena los mensajes enviados al tema, como almacenaría los mensajes 
                enviados a una cola. Si el programa u otra aplicación llama a 
                <code>createDurableConsumer</code> utilizando la misma fábrica de conexiones y su ID de 
                cliente, el mismo tema y el mismo nombre de suscripción, la suscripción se reactiva y el 
                proveedor de JMS entrega los mensajes que se enviaron. mientras la suscripción estaba 
                inactiva.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Para eliminar una suscripción duradera, primero cierre el consumidor, luego llame al método 
                <code>unsubscribe</code> con el nombre de la suscripción como argumento:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
consumer.close();
context.unsubscribe(subName);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El método <code>unsubscribe</code> elimina el estado que el proveedor mantiene para la suscripción.
              </p>
            </div>
            <div class="paragraph">
              <p>
                La <a href="#BNCGE">Figura 48-6</a> y la <a href="#BNCGF">Figura 48-7</a> muestran la 
                diferencia entre una suscripción no duradera y una duradera. Con una suscripción ordinaria no 
                duradera, el consumidor y la suscripción comienzan y terminan en el mismo punto y, en efecto, 
                son idénticos. Cuando se cierra el consumidor, la suscripción también finaliza. Aquí, 
                <code>create</code> representa una llamada a <code>JMSContext.createConsumer</code> con un 
                argumento <code>Topic</code>, y <code>close</code> representa una llamada a 
                <code>JMSConsumer.close</code>. Los mensajes enviados al tema entre el momento del primer 
                <code>cerrar</code> y el momento del segundo <code>crear</code> no se agregan a ninguna de las 
                suscripciones. En la <a href="#BNCGE">Figura 48-6</a>, los consumidores reciben los mensajes 
                M1, M2, M5 y M6, pero no reciben los mensajes M3 y M4.
              </p>
            </div>
            <div id="BNCGE" class="paragraph">
              <div class="title"><strong>Figura 48-6 Suscripciones y Consumidores No Duraderos</strong></div>
              <p>
                <span class="image">
                  <img src="img/javaeett_dt_031.png" 
                       alt="Diagrama que muestra la pérdida de mensajes cuando se utilizan suscripciones no 
                       duraderas">
                </span>
              </p>
            </div>
            <div class="paragraph">
              <p>
                Con una suscripción duradera, el consumidor se puede cerrar y volver a crear, pero la 
                suscripción continúa existiendo y reteniendo mensajes hasta que la aplicación llama al método 
                <code>unsubscribe</code>. En la <a href="#BNCGF">Figura 48-7</a>, <code>create</code> 
                representa una llamada a <code>JMSContext.createDurableConsumer</code>, <code>close</code> 
                representa una llamada a <code>JMSConsumer.close</code>, y <code>unsubscribe</code> representa 
                una llamada a <code>JMSContext.unsubscribe</code>. Los mensajes enviados después de que se 
                cierra el primer consumidor se reciben cuando se crea el segundo consumidor (en la misma 
                suscripción duradera), por lo que aunque los mensajes M2, M4 y M5 lleguen mientras no haya 
                ningún consumidor, no se perderán.
              </p>
            </div>
            <div id="BNCGF" class="paragraph">
              <div class="title"><strong>Figura 48-7 Consumidores en una Suscripción Duradera</strong></div>
              <p>
                <span class="image">
                  <img src="img/javaeett_dt_032.png" 
                       alt="Diagrama que muestra los mensajes que se conservan cuando se utilizan 
                       suscripciones duraderas">
                </span>
              </p>
            </div>
            <div class="paragraph">
              <p>
                Una suscripción duradera compartida le permite utilizar varios consumidores para recibir 
                mensajes de una suscripción duradera. Si utiliza una suscripción duradera compartida, la 
                fábrica de conexiones que utiliza no necesita tener un identificador de cliente. Para crear 
                una suscripción duradera compartida, llame al método 
                <code>JMSContext.createSharedDurableConsumer</code>, especificando el tema y el nombre de 
                la suscripción:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
JMSConsumer consumer =
        context.createSharedDurableConsumer(topic, "MakeItLast");
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Ver <a href="jms-examples003.html#BNCFX">Confirmación de Mensajes</a>, 
                <a href="jms-examples004.html#BNCGG">Uso de Suscripciones Duraderas</a>, 
                <a href= "jms-examples005.html#BABEJBHA">Uso de Suscripciones Duraderas Compartidas</a>, y 
                <a href="jms-examples008.html#BNCGW">Envío de Mensajes Desde un Bean de Sesión a un MDB</a> 
                para ver ejemplos de aplicaciones Java EE que utilizan suscripciones duraderas.
              </p>
            </div>
          </div>
          <div class="sect3" id="BABJCIGJ">
            <h4 id="creating-shared-subscriptions">Creación de Suscripciones Compartidas</h4>
            <div class="paragraph">
              <p>
                Una suscripción de tema creada por el método <code>createConsumer</code> o 
                <code>createDurableConsumer</code> solo puede tener un consumidor (aunque un tema puede tener 
                muchos). Varios clientes que consumen del mismo tema tienen, por definición, varias 
                suscripciones al tema, y todos los clientes reciben todos los mensajes enviados al tema (a 
                menos que los filtren con selectores de mensajes).
              </p>
            </div>
            <div class="paragraph">
              <p>
                Sin embargo, es posible crear una suscripción compartida no duradera a un tema utilizando el 
                método <code>createSharedConsumer</code> y especificando no solo un destino sino también un 
                nombre de suscripción: 
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
consumer = context.createSharedConsumer(topicName, "SubName");
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Con una suscripción compartida, los mensajes se distribuirán entre varios clientes que 
                utilicen el mismo tema y nombre de suscripción. Cada mensaje enviado al tema se agregará a 
                cada suscripción (sujeto a cualquier selector de mensajes), pero cada mensaje agregado a una 
                suscripción se entregará solo a uno de los consumidores de esa suscripción, por lo que solo lo 
                recibirá uno de los clientes. Una suscripción compartida puede ser útil si desea compartir la 
                carga de mensajes entre varios consumidores de la suscripción en lugar de que solo un 
                consumidor de la suscripción reciba cada mensaje. Esta función puede mejorar la 
                escalabilidad de las aplicaciones cliente de aplicaciones Java EE y las aplicaciones Java SE. 
                (Los beans controlados por mensajes comparten el trabajo de procesar mensajes de un tema entre 
                varios subprocesos).
              </p>
            </div>
            <div class="paragraph">
              <p>
                Consulte 
                <a href="jms-examples005.html#BABIBEAC">Uso de Suscripciones no Duraderas Compartidas</a> para 
                ver un ejemplo simple del uso de consumidores no duraderos compartidos.
              </p>
            </div>
            <div class="paragraph">
              <p>
                También puede crear suscripciones duraderas compartidas mediante el método 
                <code>JMSContext.createSharedDurableConsumer</code>. Para más detalles, consulte 
                <a href="#BNCGD">Creación de Suscripciones Duraderas</a>.
              </p>
            </div>
          </div>
        </div>
        <div class="sect2" id="BNCES">
          <h3 id="jms-messages">Mensajes de JMS</h3>
          <div class="paragraph">
            <p>
              El propósito final de una aplicación JMS es producir y consumir mensajes que luego puedan ser 
              utilizados por otras aplicaciones de software. Los mensajes JMS tienen un formato básico que es 
              simple pero muy flexible, lo que le permite crear mensajes que coincidan con los formatos 
              utilizados por las aplicaciones que no son JMS en plataformas heterogéneas. 
            </p>
          </div>
          <div class="paragraph">
            <p>
              Un mensaje JMS puede tener tres partes: un encabezado, propiedades y un cuerpo. Solo se requiere 
              el encabezado. Las siguientes secciones describen estas partes.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Para obtener la documentación completa de los encabezados, las propiedades y los cuerpos de los 
              mensajes, consulte la documentación de la interfaz <code>Message</code> en la documentación de 
              la IPA. Para obtener una lista de posibles tipos de mensajes, consulte 
              <a href="#BNCEW">Cuerpos del Mensaje</a>.
            </p>
          </div>
          <div class="paragraph">
            <p>Aquí se tratan los siguientes temas:</p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p><a href="#BNCET">Encabezados del Mensaje</a></p>
              </li>
              <li>
                <p><a href="#BNCEV">Propiedades del Mensaje</a></p>
              </li>
              <li>
                <p><a href="#BNCEW">Cuerpos del Mensaje</a></p>
              </li>
            </ul>
          </div>
          <div class="sect3" id="BNCET">
            <h4 id="message-headers">Encabezados del Mensaje</h4>
            <div class="paragraph">
              <p>
                Un encabezado de mensaje JMS contiene una serie de campos predefinidos que contienen valores 
                utilizados tanto por clientes como por proveedores para identificar y enrutar mensajes. La 
                <a href="#BNCEU">Tabla 48-1</a> enumera y describe los campos de encabezado de mensaje JMS e 
                indica cómo se establecen sus valores. Por ejemplo, cada mensaje tiene un identificador único, 
                que se representa en el campo de encabezado <code>JMSMessageID</code>. El valor de otro campo 
                de encabezado, <code>JMSDestination</code>, representa la cola o el tema al que se envía el 
                mensaje. Otros campos incluyen una marca de tiempo y un nivel de prioridad.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Cada campo de encabezado tiene métodos setter y getter asociados, que se documentan en la 
                descripción de la interfaz <code>Message</code>. Algunos campos de encabezado están destinados 
                a ser configurados por un cliente, pero muchos se configuran automáticamente mediante el 
                método <code>send</code>, que anula los valores establecidos por el cliente.
              </p>
            </div>
            <div class="paragraph">
              <p><a id="sthref196"></a><a id="BNCEU"></a></p>
            </div>
            <div class="paragraph">
              <p>
                <strong>
                  Tabla 48-1 Cómo se establecen los valores de campo de encabezado de mensaje JMS
                </strong>
              </p>
            </div>
            <table class="tableblock frame-all grid-all" style="width: 99%;">
              <colgroup>
                <col style="width: 20%;">
                <col style="width: 60%;">
                <col style="width: 20%;">
              </colgroup>
              <tbody>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><strong>Campo de Encabezado</strong></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><strong>Descripción</strong></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><strong>Establecido por</strong></p></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>JMSDestination</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Destino al que se envía el mensaje</p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Método <code>send</code> del proveedor JMS</p></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>JMSDeliveryMode</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Modo de entrega especificado cuando se envió el mensaje (ver 
                      <a href="jms-concepts004.html#BNCFY">Especificación de la Persistencia de Mensajes</a>)
                    </p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Método <code>send</code> del proveedor JMS</p></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>JMSDeliveryTime</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      La hora en que se envió el mensaje más el retraso de entrega especificado cuando se 
                      envió el mensaje (ver 
                      <a href="jms-concepts004.html#BABGEADH">Especificación de un Retraso de Entrega</a>
                    </p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Método <code>send</code> del proveedor JMS</p></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>JMSExpiration</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Tiempo de caducidad del mensaje (ver 
                      <a href="jms-concepts004.html#BNCGA">Permitir que los Mensajes Caduquen</a>)
                    </p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Método <code>send</code> del proveedor JMS</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>JMSPriority</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      La prioridad del mensaje (ver 
                      <a href="jms-concepts004.html#BNCFZ">
                        Configuración de los Niveles de Prioridad de los Mensajes</a>)
                    </p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Método <code>send</code> del proveedor JMS</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>JMSMessageID</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Valor que identifica de forma única cada mensaje enviado por un proveedor
                    </p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Método <code>send</code> del proveedor JMS</p></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>JMSTimestamp</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      La hora en que se entregó el mensaje a un proveedor para ser enviado
                    </p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Método <code>send</code> del proveedor JMS</p></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>JMSCorrelationID</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Valor que vincula un mensaje con otro; comúnmente se usa el valor 
                      <code>JMSMessageID</code>
                    </p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Aplicación cliente</p></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>JMSReplyTo</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Destino donde se deben enviar las respuestas al mensaje
                    </p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Aplicación cliente</p></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>JMSType</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Identificador de tipo proporcionado por la aplicación cliente
                    </p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Aplicación cliente</p></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>JMSRedelivered</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Si el mensaje se está reenviando
                    </p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Proveedor de JMS antes de la entrega</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <div class="sect3" id="BNCEV">
            <h4 id="message-properties">Propiedades del Mensaje</h4>
            <div class="paragraph">
              <p>
                Puede crear y establecer propiedades para los mensajes si necesita valores además de los 
                proporcionados por los campos de encabezado. Puede usar propiedades para brindar 
                compatibilidad con otros sistemas de mensajería, o puede usarlas para crear selectores de 
                mensajes (consulte <a href="#BNCER">Selectores de Mensajes de JMS</a>). Para ver un ejemplo de 
                configuración de una propiedad para usarla como selector de mensajes, consulte 
                <a href="jms-examples008.html#BNCGW">Envío de Mensajes Desde un Bean de Sesión a un MDB</a>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                La IPA de JMS proporciona algunos nombres de propiedad predefinidos que comienzan con 
                <code>JMSX</code>. Se requiere un proveedor JMS para implementar solo uno de estos, 
                <code>JMSXDeliveryCount</code> (que especifica la cantidad de veces que se ha entregado un 
                mensaje); el resto son opcionales. El uso de estas propiedades predefinidas o de propiedades 
                definidas por el usuario en las aplicaciones es opcional.
              </p>
            </div>
          </div>
          <div class="sect3" id="BNCEW">
            <h4 id="message-bodies">Cuerpos del Mensaje</h4>
            <div class="paragraph">
              <p>
                La IPA JMS define seis tipos diferentes de mensajes. Cada tipo de mensaje corresponde a un 
                cuerpo de mensaje diferente. Estos tipos de mensajes le permiten enviar y recibir datos en 
                muchas formas diferentes. La <a href="#BNCEX">Tabla 48-2</a> describe estos tipos de mensajes.
              </p>
            </div>
            <div class="paragraph">
              <p><a id="sthref197"></a><a id="BNCEX"></a></p>
            </div>
            <div class="paragraph">
              <p><strong>Tabla 48-2 Tipos de mensajes JMS</strong></p>
            </div>
            <table class="tableblock frame-all grid-all" style="width: 75%;">
              <colgroup>
                <col style="width: 20%;">
                <col style="width: 80%;">
              </colgroup>
              <tbody>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><strong>Tipo de Mensaje</strong></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><strong>El Cuerpo Contiene</strong></p></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>TextMessage</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Un objeto <code>java.lang.String</code> (por ejemplo, el contenido de un archivo XML).
                    </p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>MapMessage</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Un conjunto de pares nombre-valor, con nombres como objetos <code>String</code> y 
                      valores como tipos primitivos en el lenguaje de programación Java. Se puede acceder a 
                      las entradas secuencialmente por enumerador o aleatoriamente por nombre. El orden de las 
                      entradas no está definido.
                    </p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>BytesMessage</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Un flujo de bytes no interpretados. Este tipo de mensaje es para codificar literalmente 
                      un cuerpo para que coincida con un formato de mensaje existente.
                    </p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>StreamMessage</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Un flujo de valores primitivos en el lenguaje de programación Java, llenado y leído 
                      secuencialmente.
                    </p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>ObjectMessage</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Un objeto <code>Serializable</code> en el lenguaje de programación Java.
                    </p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>Message</code></p></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">
                      Ninguna cosa. Compuesto solo de campos de encabezado y propiedades. Este tipo de mensaje 
                      es útil cuando no se requiere un cuerpo de mensaje.
                    </p>
                  </td>
                </tr>
              </tbody>
            </table>
            <div class="paragraph">
              <p>
                La IPA de JMS proporciona métodos para crear mensajes de cada tipo y para completar su 
                contenido. Por ejemplo, para crear y enviar un <code>TextMessage</code>, puede usar las 
                siguientes declaraciones:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
TextMessage message = context.createTextMessage();
message.setText(msg_text);     // msg_text es un objeto String
context.createProducer().send(message);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                En el extremo consumidor, llega un mensaje como un objeto genérico <code>Message</code>. A 
                continuación, puede convertir el objeto en el tipo de mensaje adecuado y utilizar métodos más 
                específicos para acceder al cuerpo y extraer el contenido del mensaje (y sus encabezados y 
                propiedades, si es necesario). Por ejemplo, puede usar los métodos de lectura orientados a 
                flujo de <code>BytesMessage</code>. Siempre debe convertir al tipo de mensaje apropiado para 
                recuperar el cuerpo de un <code>StreamMessage</code>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                En lugar de convertir el mensaje en un tipo de mensaje, puede llamar al método 
                <code>getBody</code> en <code>Message</code>, especificando el tipo de mensaje como argumento. 
                Por ejemplo, puede recuperar un <code>TextMessage</code> como una <code>String</code>. El 
                siguiente fragmento de código utiliza el método <code>getBody</code>:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
Message m = consumer.receive();
if (m instanceof TextMessage) {
    String message = m.getBody(String.class);
    System.out.println("Leyendo mensaje: " + message);
} else {
    // Manejar el error o procesar otro tipo de mensaje
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                La IPA de JMS proporciona accesos directos para crear y recibir un <code>TextMessage</code>, 
                <code>BytesMessage</code>, <code>MapMessage</code> u <code>ObjectMessage</code>. Por ejemplo, 
                no tiene que envolver una cadena en un <code>TextMessage</code>; en su lugar, puede enviar y 
                recibir la cadena directamente. Por ejemplo, puede enviar una cadena de la siguiente manera:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
String message = "Esto es un mensaje";
context.createProducer().send(dest, message);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Puede recibir el mensaje utilizando el método <code>receiveBody</code>:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
String message = receiver.receiveBody(String.class);
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Puede usar el método <code>receiveBody</code> para recibir cualquier tipo de mensaje, excepto 
                <code>StreamMessage</code> y <code>Message</code>, siempre que el cuerpo del mensaje se pueda 
                asignar a un tipo particular.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Un <code>Message</code> vacío puede ser útil si desea enviar un mensaje que sea simplemente 
                una señal a la aplicación. Algunos de los ejemplos en 
                <a href="jms-examples.html#BNCGV">Capítulo 49, "Ejemplos del Servicio de Mensajería de 
                  Java,"</a> envían un mensaje vacío después de enviar una serie de mensajes de texto. Por 
                ejemplo:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
context.createProducer().send(dest, context.createMessage());
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El código de consumidor puede entonces interpretar un mensaje que no sea de texto como una 
                señal de que todos los mensajes enviados ya han sido recibidos.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Los ejemplos en <a href="jms-examples.html#BNCGV">Capítulo 49, "Ejemplos del Servicio de 
                  Mensajería de Java,"</a> usan mensajes de tipo <code>TextMessage</code>, 
                <code> MapMessage</code> y <code>Mensaje</code>.
              </p>
            </div>
          </div>
        </div>
        <div class="sect2" id="BNCEY">
          <h3 id="jms-queue-browsers">Navegadores de la Cola de JMS</h3>
          <div class="paragraph">
            <p>
              Los mensajes enviados a una cola permanecen en la cola hasta que el consumidor de mensajes de 
              esa cola los consume. La IPA de JMS proporciona un objeto <code>QueueBrowser</code> que le 
              permite explorar los mensajes en la cola y mostrar los valores de encabezado para cada mensaje. 
              Para crear un objeto <code>QueueBrowser</code>, utilice el método 
              <code>JMSContext.createBrowser</code>. Por ejemplo:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight">
                <code class="language-oac_no_warn" data-lang="oac_no_warn">
QueueBrowser browser = context.createBrowser(queue);
                </code>
              </pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Consulte <a href="jms-examples003.html#BNCFL">Exploración de Mensajes en una Cola</a> para ver 
              un ejemplo del uso de un objeto <code>QueueBrowser</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              El método <code>createBrowser</code> le permite especificar un selector de mensajes como segundo 
              argumento cuando crea un <code>QueueBrowser</code>. Para obtener información sobre los 
              selectores de mensajes, consulte <a href="#BNCER">Selectores de Mensajes de JMS</a>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              La IPA de JMS no proporciona ningún mecanismo para examinar un tema. Los mensajes generalmente 
              desaparecen de un tema tan pronto como aparecen: si no hay consumidores de mensajes para 
              consumirlos, el proveedor de JMS los elimina. Aunque las suscripciones duraderas permiten que 
              los mensajes permanezcan en un tema mientras el consumidor de mensajes no está activo, JMS no 
              define ninguna función para examinarlos.
            </p>
          </div>
        </div>
        <div class="sect2" id="BNCEZ">
          <h3 id="jms-exception-handling">Manejo de Excepciones de JMS</h3>
          <div class="paragraph">
            <p>
              La clase raíz para todas las excepciones comprobadas en la IPA de JMS es 
              <code>JMSException</code>. La causa principal de todas las excepciones no verificadas en la 
              IPA de JMS es <code>JMSRuntimeException</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Capturar <code>JMSException</code> y <code>JMSRuntimeException</code> proporciona una forma 
              genérica de manejar todas las excepciones relacionadas con la IPA de JMS.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Las clases <code>JMSException</code> y <code>JMSRuntimeException</code> incluyen las siguientes 
              subclases, descritas en la documentación de la IPA:
            </p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p><code>IllegalStateException</code>, <code>IllegalStateRuntimeException</code></p>
              </li>
              <li>
                <p><code>InvalidClientIDException</code>, <code>InvalidClientIDRuntimeException</code></p>
              </li>
              <li>
                <p>
                  <code>InvalidDestinationException</code>, <code>InvalidDestinationRuntimeException</code>
                </p>
              </li>
              <li>
                <p><code>InvalidSelectorException</code>, <code>InvalidSelectorRuntimeException</code></p>
              </li>
              <li>
                <p><code>JMSSecurityException</code>, <code>JMSSecurityRuntimeException</code></p>
              </li>
              <li>
                <p><code>MessageEOFException</code></p>
              </li>
              <li>
                <p><code>MessageFormatException</code>, <code>MessageFormatRuntimeException</code></p>
              </li>
              <li>
                <p><code>MessageNotReadableException</code></p>
              </li>
              <li>
                <p>
                  <code>MessageNotWriteableException</code>, <code>MessageNotWriteableRuntimeException</code>
                </p>
              </li>
              <li>
                <p>
                  <code>ResourceAllocationException</code>, <code>ResourceAllocationRuntimeException</code>
                </p>
              </li>
              <li>
                <p>
                  <code>TransactionInProgressException</code>, 
                  <code>TransactionInProgressRuntimeException</code>
                </p>
              </li>
              <li>
                <p>
                  <code>TransactionRolledBackException</code>, 
                  <code>TransactionRolledBackRuntimeException</code>
                </p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>
              Todos los ejemplos en el tutorial capturan y manejan <code>JMSException</code> o 
              <code>JMSRuntimeException</code> cuando es apropiado hacerlo.
            </p>
          </div>
        </div>
      </div>
    </div>
    <hr />
    <table width="90%" id="bottom-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>		
        <td align="left">
          <a href="jms-concepts002.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="jms-concepts004.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class="vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <span id="copyright">
      <a href="img/cpyr.adoc">
        <img src="img/oracle.gif" height="10" alt="Logo de Oracle" />&nbsp;			
        <span>
          Copyright&nbsp;&copy;&nbsp;2017,&nbsp;Oracle&nbsp;y/o&nbsp;sus&nbsp;afiliados.&nbsp;Todos&nbsp;los&nbsp;
          derechos&nbsp;reservados.
        </span>
      </a>
    </span>
  </body>
</html>
