<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Lección: Algoritmos (Los Tutoriales de Java&trade; &gt; Colecciones)</title>
        <meta name="description" content="Este tutorial de Java sobre colecciones describe los interfaces, implementaciones, y
              algoritmos en el marco de trabajo de Colecciones de Java" />
        <meta name="keywords" content="programacion java , aprender java, codigo de ejemplo de java, colecciones de java,
              set, list, queue, map, array, arraylist" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
    </head>
    <body>
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper  clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="MainFlow_wide">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Colecciones
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;
                <a href="../index.html" target="_top">Colecciones</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="../implementations/index.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../custom-implementations/index.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Lección: Algoritmos</h1>
            </div>
            <div id="PageContent">
                <p>
                    Los <em>algoritmos polimórficos</em> descritos aquí son piezas de funcionalidad reutilizable ofrecida por la 
                    plataforma Java. Todos ellos provienen de la
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html"><code>Collections</code></a>
                    clase, y todos toman la forma de métodos estáticos cuyo primer argumento es la colección sobre la cual la
                    operación va a ser realizada. La gran mayoría de los algoritmos suministrados por la plataforma Java operan
                    sobre instancias
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html"><code>List</code></a>, pero unas pocas
                    de lleas operan sobre instancias arbitrarias
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html"><code>Collection</code></a>
                       . Esta sección describe brevemente los siguientes algoritmos:
                </p>
                <ul>
                    <li><a href="#sorting">Ordenación</a></li>
                    <li><a href="#shuffling">Mezcla</a></li>
                    <li><a href="#rdm">Manipulación de Datos de Rutina</a></li>
                    <li><a href="#searching">Búsqueda</a></li>
                    <li><a href="#composition">Composición</a></li>
                    <li><a href="#fev">Encontrar Valores Extremos</a></li>
                </ul>
                <a id="sorting"></a>
                <h2>Ordenación</h2>
                <p>
                    El algoritmo <code>sort</code> reordenan una <code>List</code> de forma que sus elementos están en orden
                    ascendido de acuerdo a una relación de ordenación. Se suministran dos formas de operación. La forma simple toma 
                    una <code>List</code> y la ordena de acuerdo a la <em>ordenación natural</em> de los elementos. Si no está
                    familiarizado con el concepto del orden natura, vea la sección
                    <a class="TutorialLink" target="_top" href="../interfaces/order.html">Ordenando Objetos</a>.
                </p>
                <p>
                    La operación <code>sort</code> usa un algoritmo <em>merge sort</em> levemente mejorado que es rápido y estable:
                </p>
                <ul>
                    <li>
                        <b>Rapido</b>:Se garantiza ejecutar en tiempo <code>n log(n)</code> y se ejecuta substancialmente más
                        rápida en casi todas las listas ordenadas. Las pruebas empíricas mostró ser tan rápido como el altamente
                        optimizado quicksort. Un quicksort es considerado generalmente ser más rápido que un sort merge pero no es
                        estable y no garantiza el rendimiento <code>n log(n)</code>.
                    </li>
                    <li>
                        <b>Estable</b>: No reordena los elementos iguales. Esto es importante si ordena la misma lista repetidamente
                        sobre diferentes atributos. Si un usuario de un programa de correo ordena la carpeta de entrada por fecha
                        de entrada del correo y después lo ordena por su remitente, el usuario espera naturalmente que la ahora
                        contigua lista de mensajes de un remitente dado estará (aún) ordenada por fecha de entrada del correo. Esto
                        se garantiza sólo si la ordenación segunda fue estable.
                    </li>
                </ul>
                <p>
                    El siguiente
                    <a class="SourceLink" target="_blank" href="examples/Sort.java"
                       onclick="showCode('../../displayCode.html', 'examples/Sort.java'); return false;">
                        <code>programa trivial</code></a> imprime sus argumentos en orden lexicográfico (alfabético).
                </p>
                <div class="codeblock">
                    <pre>

import java.util.*;

public class Sort {
    public static void main(String[] args) {
        List&lt;String&gt; list = Arrays.asList(args);
        Collections.sort(list);
        System.out.println(list);
    }
}
                    </pre>
                </div>
                <p>
                    Ejecutemos el programa.
                </p>
                <div class="codeblock">
                    <pre>
% java Sort i walk the line
                    </pre>
                </div>
                <p>
                    Se produce la salida siguiente.
                </p>
                <div class="codeblock">
                    <pre>
[i, line, the, walk]
                    </pre>
                </div>
                <p>
                    El programa fue incluído sólo para mostrarle que esos algoritmos son realmente tan facilmente de usar como
                    parece ser.
                </p>
                <p>
                    La segunda forma de <code>sort</code> toma un
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html"><code>Comparator</code></a> además 
                    de una <code>List</code> y ordena los elementos con el <code>Comparator</code>. Suponga que quiere imprimir los
                    grupos de anagramas de nuestro ejemplo anterior en orden invertido de tamaño &mdash; el grupo de anagrama más
                    grande primero. El ejemplo que sigue muestra como conseguir esto con la ayuda de la segunda forma del método
                    <code>sort</code>.
                </p>
                <p>
                    Recuerde que los grupos de anagrama son almacenados como valores en un <code>Map</code>, en la forma de
                    instancias <code>List</code>. El código de impresión revisado itera a traves de la vista de valores de
                    <code>Map</code>, colocando cada <code>List</code> que pasa la prueba de tamaño-mínimo en una <code>List</code>
                    de <code>List</code>s. Entonces el código ordena esta <code>List</code>, usando un <code>Comparator</code>
                    que espera instancias <code>List</code>, e implementa el ordenamiento por tamaño inverso. Finalmente, el código
                    itera a través de la <code>List</code> ordenada, imprimiendo sus elementos (los grupos de anagramas). El código
                    siguiente reemplaza el código de impresión al final del método <code>main</code> en el ejemplo
                    <code>Anagrams</code>.
                </p>
                <div class="codeblock">
                    <pre>
// Hace una List de todos los grupos de anagramas por encima del umbral del tamaño.
List&lt;List&lt;String&gt;&gt; winners = new ArrayList&lt;List&lt;String&gt;&gt;();
for (List&lt;String&gt; l : m.values())
    if (l.size() >= minGroupSize)
        winners.add(l);

// Ordena los grupos de anagramas de acuerdo al tamaño
Collections.sort(winners, new Comparator&lt;List&lt;String&gt;&gt;() {
    public int compare(List&lt;String&gt; o1, List&lt;String&gt; o2) {
        return o2.size() - o1.size();
    }});

// Imprime los grupos de anagrama.
for (List&lt;String&gt; l : winners)
    System.out.println(l.size() + ": " + l);
                    </pre></div>
                <p>
                    Ejecute
                    <a class="SourceLink" target="_blank"
                       href="examples/Anagrams2.java"
                       onclick="showCode('../../displayCode.html', 'examples/Anagrams2.java'); return false;">
                        <code>el programa</code></a> sobre el
                    <a class="SourceLink" target="_blank" href="../interfaces/examples/dictionary.txt"
                       onclick="showCode('../../displayCode.html', '../interfaces/examples/dictionary.txt'); return false;">
                        <code>mismo diccionario</code></a> como en la sección
                    <a class="TutorialLink" target="_top" href="../interfaces/map.html">la Interface Map</a>, con el mismo tamaño
                    mínimo del grupo de anagrama (ocho), produce la salida siguiente.
                </p>
                <div class="codeblock">
                    <pre>

12: [apers, apres, asper, pares, parse, pears, prase,
       presa, rapes, reaps, spare, spear]
11: [alerts, alters, artels, estral, laster, ratels,
       salter, slater, staler, stelar, talers]
10: [least, setal, slate, stale, steal, stela, taels,
       tales, teals, tesla]
9: [estrin, inerts, insert, inters, niters, nitres,
       sinter, triens, trines]
9: [capers, crapes, escarp, pacers, parsec, recaps,
       scrape, secpar, spacer]
9: [palest, palets, pastel, petals, plates, pleats,
       septal, staple, tepals]
9: [anestri, antsier, nastier, ratines, retains, retinas,
       retsina, stainer, stearin]
8: [lapse, leaps, pales, peals, pleas, salep, sepal, spale]
8: [aspers, parses, passer, prases, repass, spares,
       sparse, spears]
8: [enters, nester, renest, rentes, resent, tenser,
       ternes,??????treens]
8: [arles, earls, lares, laser, lears, rales, reals, seral]
8: [earings, erasing, gainers, reagins, regains, reginas,
       searing, seringa]
8: [peris, piers, pries, prise, ripes, speir, spier, spire]
8: [ates, east, eats, etas, sate, seat, seta, teas]
8: [carets, cartes, caster, caters, crates, reacts,
       recast,??????traces]
                    </pre>
                </div>
                <p>
                    <a id="shuffling"></a>
                </p>
                <h2>Mezcla</h2>
                <p>
                    El algoritmo <code>shuffle</code> hace lo contrario de lo que hace <code>sort</code>, destruyendo cualquier
                    muestra de orden que puede haber sido presente en una <code>List</code>. Eso es, este algoritmo reordena la
                    <code>List</code> basada en la entrada de un origen de aleatoriedad tal que todas las permutaciones posibles
                    ocurran con la misma probabilidad, asumiendo una fuente justa de aleatoriedad. Este algoritmo es útil en la
                    implementación de los juegos de azar. Por ejemplo, podría ser usada para mezclar una <code>List</code> de
                    objetos <code>Card (Carta en español)</code> representando una baraja. También, es útil para generar casos de
                    prueba.
                </p>
                <p>
                    Esta operación tiene dos formas: uno toma una <code>List</code> y usa un fuente por defecto de aleatoriedad, y
                    el otro requiere que el que llama suministre un objeto
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html">Random</a> usa una fuente de 
                    aleatoriedad. El código para este algoritmo es usado como un ejemplo en la sección
                    <a class="TutorialLink" target="_top" href="../interfaces/list.html#shuffle"><code>List</code></a>.
                    <a id="rdm"></a>
                </p>
                <h2>Manipulación de Datos de Rutina</h2>
                <p>
                    La clase <code>Collections</code> suministra cinco algoritmos para hacer manipulación de datos rutinaria en los
                    objetos <code>List</code>, todos los cuales son bastante sencillos:
                </p>
                <ul>
                    <li>
                        <code>reverse</code> &mdash; invierte el orden de los elementos en una <code>List</code>.
                    </li>
                    <li>
                        <code>fill</code> &mdash; sobreescribe cada elemento en una <code>List</code> con el valor especificado.
                        Esta operación es útil para reinicializar una <code>List</code>.
                    </li>
                    <li>
                        <code>copy</code> &mdash; toma dos argumentos, una <code>List</code> de destino y una <code>List</code> de
                        origen, y copia los elementos de la fuente en el destino, sobreescribiendo sus contenidos. La
                        <code>List</code> de destino tiene que ser al menos tan larga como la fuente. Si es más larga, los elementos
                        remanentes en el <code>List</code> de destino son no afectados.
                    </li>
                    <li>
                        <code>swap</code> &mdash; intercambia los elementos en las posiciones especificadas en una
                        <code>List</code>.
                    </li>
                    <li>
                        <code>addAll</code> &mdash; agrega todos los elementos especificados a una <code>Collection</code>. Los
                        elementos a ser agregados pueden a ser especificados individualmente o como una matriz.
                    </li>
                </ul>
                <p>
                    <a id="searching"></a>
                </p>
                <h2>Búsqueda</h2>
                <p>
                    El algoritmo <code>binarySearch</code> busca por un elemento especificado en una <code>List</code> ordenada.
                    Este algoritmo tiene dos formas. Los primero toma una <code>List</code> y un elemento para buscar (la
                    &quot;clave de búsqueda&quot;). Esta forma asume que la <code>List</code> es ordenada en orden ascendido de
                    acuerdo al orden natural de sus elementos. la segunda forma toma un <code>Comparator</code> además de la
                    <code>List</code> y la clave de búsqueda, y asume que la <code>List</code> es ordenada en orden ascendente de
                    acuerdo al <code>Comparator</code> especificado. El algoritmo <code>sort</code> puede ser usado para ordenar
                    la <code>List</code> antes de llamar a <code>binarySearch</code>.
                </p>
                <p>
                    El valor devuelto es el mismo para ambas formas. Si la <code>List</code> contiene la clave de búsqueda, su
                    índice es devuelta. Si no, el valor devuelto es <code>(-(punto de inserción) - 1)</code>, donde el punto de
                    inserción es el punto en el cual el valor debería ser insertado en la <code>List</code>, o el índice del primer
                    elemento más grande que el valor de <code>list.size()</code> si todos los elementos en la <code>List</code>
                    son menos que el valor especificado. Esta fórmula ciertamente fea garantiza que el valor devuelto será 
                    <code>&gt;= 0</code> si y sólo si la clave de búsqueda se encuentra. Es básicamente un truco para combinar un
                    booleano <code>(encontrado)</code> y un entero <code>(índice)</code> dentro de un único valor <code>int</code>
                    devuelto.
                </p>
                <p>
                    El idioma siguiente, utilizable con ambas formas de la operación <code>binarySearch</code>, busca por la
                    clave de búsqueda especificada y lo inserta en la posición apropiada si no está aún presente.
                </p>
                <div class="codeblock">
                    <pre>
int pos = Collections.binarySearch(list, key);
if (pos &lt; 0)
   l.add(-pos-1, key);
                    </pre>
                </div>
                <p>
                    <a id="composition"></a>
                </p>
                <h2>Composición</h2>
                <p>
                    La frecuencia y los algoritmos disjuntos prueban algún aspecto de la composición de una o más
                    <code>Collections</code>:
                </p>
                <ul>
                    <li>
                        <code>frequency</code> &mdash; cuenta el número de veces que el elemento especificado ocurre en la colección
                        especificada.
                    </li>
                    <li>
                        <code>disjoint</code> &mdash; determina si dos <code>Collections</code> son disjuntos; que es, si ellos
                        no contiene elementos en común.
                    </li>
                </ul>
                <p>
                    <a id="fev"></a>
                </p>
                <h2>Encontrar Valores Extremos</h2>
                <p>
                    Los algoritmos <code>min</code> y <code>max</code> devuelven, respectivamente, el elemento mínimo y máximo
                    contenido en una <code>Collection</code> especificada. Ambas operaciones vienen en dos formas. La forma simple
                    toma sólo una <code>Collection</code> y devuelve el elemento mínimo (o máximo) de acuerdo al orden natural de
                    elementos. La segunda forma toma un <code>Comparator</code> además de la <code>Collection</code> y devuelve
                    el elemento mínimo (o máximo) de acuerdo al <code>Comparator</code> especificado.
                </p>
            </div>
            <div class="NavBit">
                <a href="../implementations/index.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a href="../custom-implementations/index.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Lección Anterior<br />
            <b>Página siguiente:</b> Implementaciones de Colección Personalizada
        </div>
    </body>
</html> 
