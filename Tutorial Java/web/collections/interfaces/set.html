<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        
        <title>El Interfaz Set (Los Tutoriales de Java&trade; &gt; Colecciones &gt; Interfaces)</title>
        <meta name="description" content="Este tutorial de Java sobre colecciones describe los interfaces, implementaciones, y
              algoritmos en el marco de trabajo de Colecciones de Java" />
        <meta name="keywords" content="programacion java , aprender java, codigo de ejemplo de java, colecciones de java,
              set, list, queue, map, array, arraylist" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Interfaces</a></div>
                <div class="linkAHEAD"><a href="collection.html">La Interfaz Collection</a></div>
                <div class="nolinkAHEAD">La Interfaz Set</div>
                <div class="linkAHEAD"><a href="list.html">La Interfaz List</a></div>
                <div class="linkAHEAD"><a href="queue.html">La Interfaz Queue</a></div>
                <div class="linkAHEAD"><a href="deque.html">La Interfaz Deque</a></div>
                <div class="linkAHEAD"><a href="map.html">La Interfaz Map</a></div>
                <div class="linkAHEAD"><a href="order.html">Ordenación de Objetos</a></div>
                <div class="linkAHEAD"><a href="sorted-set.html">La Interfaz SortedSet</a></div>
                <div class="linkAHEAD"><a href="sorted-map.html">La Interfaz SortedMap</a></div>
                <div class="linkAHEAD"><a href="summary.html">Sumario de Interfaces</a></div>
                <div class="linkQUESTIONS"><a href="QandE/questions.html">Preguntas y Ejercicios</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Colecciones<br />
                <b>Lección:</b> Interfaces
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Colecciones</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Interfaces</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="collection.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="list.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>El Interfaz Set</h1>
            </div>
            <div id="PageContent">
                <p>
                    Un
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">
                        <code>Set</code>
                    </a> es una
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">
                        <code>Collection</code>
                    </a> que no puede contener elementos duplicados. Modela la abstracción del conjunto matemático. El interfaz 
                    <code>Set</code> contiene <i>sólo</i> métodos heredados desde <code>Collection</code> y agrega la restricción
                    de que los elementos duplicados están prohibidos. <code>Set</code> también agrega un contrato más fuerte en
                    el comportamiento de las operaciones <code>equals</code> y <code>hashCode</code>, permitiendo  a las instancias
                    de <code>Set</code> a ser comparadas significativamente aunque sus tipos de implementación difieran. Dos
                    instancias de <code>Set</code> son iguales si contienen los mismos elementos.
                </p>
                <p>
                    La plataforma Java contiene tres implementaciones de propósito general de <code>Set</code>:
                    <code>HashSet</code>, <code>TreeSet</code>, y <code>LinkedHashSet</code>.
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html">
                        <code>HashSet</code>
                    </a>, la cual almacena sus elementos en una tabla hash, es la implementación de mejor rendimiento; sin embargo
                    no garantiza el orden de la iteración.
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html">
                        <code>TreeSet</code>
                    </a>, la cual almacena sus elementos en un árbol rojo-negro, ordena sus elementos basados en sus valores; es
                    substancialmente más lento que <code>HashSet</code>.
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html">
                        <code>LinkedHashSet</code>
                    </a>, la cual es implementada como un tabla hash con una lista enlazada que lo atraviesa, ordena sus elementos
                    basados en el orden en cual fueron insertados en el set (orden-de-inserción). <code>LinkedHashSet</code> evita
                    a sus clientes del ordenamiento no específico, generalmente caótico suministrado por <code>HashSet</code> al
                    coste de ser sólo ligeramente más lento.
                </p>
                <p>
                    Aquí hay un modismo simple pero útil de <code>Set</code>. Suponga que tiene una <code>Collection</code>,
                    <code>c</code>, y quiere crear otra <code>Collection</code> conteniendo los mismos elementos pero con todos los
                    duplicados eliminados. La siguiente expresión en una línea hace el truco.
                </p>
                <div class="codeblock">
                    <pre>
Collection&lt;Type&gt; noDups = new HashSet&lt;Type&gt;(c);
                    </pre>
                </div>
                <p>
                    Funciona al crear un <code>Set</code> (el cual, por definición, no puede contener duplicados), conteniendo
                    inicialmente todos los elementos en <code>c</code>. Usa el constructor de conversión estándar descrito en la
                    sección <a class="TutorialLink" target="_top" href="collection.html">El Interfaz Collection</a>.
                </p>
                <p>
                    O, si usa el KDD 8 o posterior, podría facilmente reunirlos en un <code>Set</code> usando operaciones de
                    agregación:
                </p>
                <div class="codeblock">
                    <pre>
c.stream()
.collect(Collectors.toSet()); // sin duplicados
                    </pre>
                </div>
                <p>
                    Aquí tiene un ejemplo ligeramente más largo que acumuña una <code>Collection</code> de nombres en un
                    <code>TreeSet</code>:
                </p>
                <div class="codeblock">
                    <pre>
Set&lt;String&gt; set = people.stream()
.map(Person::getName)
.collect(Collectors.toCollection(TreeSet::new));
                    </pre>
                </div>
                <p>
                    Y lo siguiente es una variante menor del primer idioma que preserva el orden de la colección original mientras
                    elimina elementos duplicados:
                </p>
                <div class="codeblock">
                    <pre>
Collection&lt;Type&gt; noDups = new LinkedHashSet&lt;Type&gt;(c);
                    </pre>
                </div>
                <p>
                    El siguiente es un método genérico que encapsula el idioma precente, devolviendo un <code>Set</code> del mismo
                    tipo genérico que el pasado.
                </p>
                <div class="codeblock">
                    <pre>
public static &lt;E&gt; Set&lt;E&gt; removeDups(Collection&lt;E&gt; c) {
    return new LinkedHashSet&lt;E&gt;(c);
}
                    </pre>
                </div>
                <h2>
                    Operaciones Básicas del Interfaz Set
                </h2>
                <p>
                    La operación <code>size</code> devuelve el número de elementos en el <code>Set</code> (su <i>cardinalidad</i>).
                    El método <code>isEmpty</code> hace exactamente lo que cree que haría. El método <code>add</code> agrega el
                    elemento especificado a <code>Set</code> si no está aun presente y devuelve un booleano indicando si el
                    elemento fue agregado. Del mismo mod, el método <code>remove</code> elimina el elemento especificado del
                    <code>Set</code> si está presente y devuelve un booleano indicando si el elemento estaba presente. El método
                    <code>iterator</code> devuelve un <code>Iterator</code> para el <code>Set</code>.
                </p>
                <p>
                    El siguiente
                    <a class="SourceLink" target="_blank"
                       href="examples/FindDups.java"
                       onclick="showCode('../../displayCode.html', 'examples/FindDups.java'); return false;">
                        <code>programa</code>
                    </a> visualiza todas las palabras distintas en su lista de argumentos. Dos versiones de este programa son
                    ofrecidos. El primero usa las operaciones agregadas del KDD 8. La segunda usa el constructo for-each.
                </p>
                <p>
                    Usando Operaciones de Agregación del KDD 8:
                </p>
                <div class="codeblock">
                    <pre>
import java.util.*;
import java.util.stream.*;

public class FindDups {
    public static void main(String[] args) {
        Set&lt;String&gt; distinctWords = Arrays.asList(args).stream()
		.collect(Collectors.toSet()); 
        System.out.println(distinctWords.size()+ 
                           " palabras distintas: " +
                           distinctWords);
    }
}
                    </pre>
                </div>
                <p>
                    Usando el Constructo <code>for-each</code>:
                </p>
                <div class="codeblock">
                    <pre>
import java.util.*;

public class FindDups {
    public static void main(String[] args) {
        Set&lt;String&gt; s = new HashSet&lt;String&gt;();
        for (String a : args)
               s.add(a);
               System.out.println(s.size() + &quot; palabras distintas: &quot; + s);
    }
}

                    </pre>
                </div>
                <p>
                    Ahora ejecute cualquiera de las versiones del programa.
                </p>
                <div class="codeblock">
                    <pre>
java FindDups i came i saw i left
                    </pre>
                </div>
                <p>
                    Se produce la siguiente salida:
                </p>
                <div class="codeblock">
                    <pre>
4 palabras distintas: [left, came, saw, i]
                    </pre>
                </div>
                <p>
                    Dese cuenta de que el código siempre se refiere a la <code>Collection</code> por el tipo de interfaz
                    (<code>Set</code>) en vez de por su tipo de implementación. Esta es una práctica de programación
                    <i>fuertemente</i> recomendada porque le da la flexibilidad de cambiar las implementaciones cambiando meramente
                    el constructor. Si cualquiera de las variables utilizadas para almacenar una colección o los parámetros usados
                    para pasarlo son declarados para ser del tipo de implementación <code>Collection</code> en vez del
                    tipo de interfaz, <i>todas</i> las variables y parámetros deben ser cambiados en orden a cambiar el tipo de
                    implementación.
                </p>
                <p>
                    Además, no hay garantía que el programa resultante vaya a funcionar. Si el programa usa cualesquiera
                    operaciones no estándar presentes en el tipo de implementación original, pero no en el nuevo, el programa
                    fallará. Hacer referencia a las colecciones solo por su interfaz evita que utilice operaciones no estándar.
                </p>
                <p>
                    El tipo de implementación del <code>Set</code> en el ejemplo precedente es <code>HashSet</code>, el cual no
                    garantiza el orden de los elementos en el <code>Set</code>. Si quiere que el programa visualize la lista de
                    palabras en orden alfabético, cambiar meramente el tipo de implementación de <code>Set</code> de
                    <code>HashSet</code> a <code>TreeSet</code>. Hacer este cambio trivial en una línea causa que la línea de
                    comandos en el ejemplo previo genere la siguiente salida.
                </p>
                <div class="codeblock">
                    <pre>
java FindDups i came i saw i left

4 distinct words: [came, i, left, saw]
                    </pre>
                </div>
                <h2>
                    Operaciones Masivas del Interfaz Set
                </h2>
                <p>
                    Las operaciones masivas son especialmente adecuadas en los <code>Set</code>s; cuando se aplican, realizan
                    operaciones algebraicas estándar de conjuntos. Suponga que <code>s1</code> y <code>s2</code> son sets. Aquí
                    tiene lo que hacen las operaciones masivas:
                </p>
                <ul>
                    <li>
                        <code>s1.containsAll(s2)</code> &mdash; devuelve <code>true</code> si <code>s2</code> es un
                        <b>subconjunto</b> de
                        <code>s1</code>. (<code>s2</code> es un subconjunto de <code>s1</code> si el set <code>s1</code> contiene
                        todos los elementos en <code>s2</code>.)
                    </li>
                    <li>
                        <code>s1.addAll(s2)</code> &mdash; transforma <code>s1</code> en la <b>unión</b> de <code>s1</code> y
                        <code>s2</code>. (La unión de dos conjuntos (sets) es el conjunto que contiene todos los elementos
                        contenidos en cada conjunto).
                    </li>
                    <li>
                        <code>s1.retainAll(s2)</code> &mdash; transforma <code>s1</code> en la intersección de <code>s1</code>
                        y <code>s2</code>. (La intersección de dos conjuntos (sets) es el conjunto que contiene sólo los elementos
                        comunes en ambos conjuntos).
                    </li>
                    <li>
                        <code>s1.removeAll(s2)</code> &mdash; transforma <code>s1</code> en el conjunto diferencia (asimétrico) de
                        <code>s1</code> y <code>s2</code>. (Por ejemplo, el conjunto diferencia de <code>s1</code> menos
                        <code>s2</code> es el conjunto que contiene todos los elementos encontrados en <code>s1</code> pero no en
                        <code>s2</code>).
                    </li>
                </ul>
                <p>
                    Para calcular la unión, intersección, o el conjunto diferencia de dos conjuntos <i>no destructivo</i> (sin
                    modificar ningún set), el llamador debe copiar un set antes de llamar a la operación masiva apropiada. Las
                    siguientes son las expresiones resultantes.
                </p>
                <div class="codeblock">
                    <pre>
Set&lt;Type&gt; union = new HashSet&lt;Type&gt;(s1);
union.addAll(s2);

Set&lt;Type&gt; intersection = new HashSet&lt;Type&gt;(s1);
intersection.retainAll(s2);

Set&lt;Type&gt; difference = new HashSet&lt;Type&gt;(s1);
difference.removeAll(s2);
                    </pre>
                </div>
                <p>
                    El tipo de implementación del <code>Set</code> resultante en las expresiones precedentes es un 
                    <code>HashSet</code>, el cual es, como ya se mencionó, la mejor implementación integral de <code>Set</code> en
                    la plataforma Java. Sin embargo, cualquier implementación de propósito general de <code>Set</code> podría ser
                    sustituída.
                </p>
                <p>
                    Revisemos el programa <code>FindDups</code>. Supongamos que queremos saber qué palabras en la lista de
                    argumentos se dan una sola vez y cuáles se dan más de una vez, pero no quiere que se impriman duplicados
                    repetidamente. Este efecto se puede lograr mediante la generación de dos conjuntos &mdash; uno conteniendo cada
                    palabra en la lista de argumentos y el otro conteniendo sólo los duplicados. Las palabras que se dan una sola 
                    vez son el conjunto de diferencia de estos dos conjuntos, lo cual sabemos como calcular.  Así se muestra el
                    <a class="SourceLink" target="_blank"
                       href="examples/FindDups2.java"
                       onclick="showCode('../../displayCode.html', 'examples/FindDups2.java'); return false;">
                        <code>el programa resultante</code>
                    </a>.
                </p>
                <div class="codeblock">
                    <pre>

import java.util.*;

public class FindDups2 {
    public static void main(String[] args) {
        Set&lt;String&gt; uniques = new HashSet&lt;String&gt;();
        Set&lt;String&gt; dups    = new HashSet&lt;String&gt;();

        for (String a : args)
            if (!uniques.add(a))
                dups.add(a);

        // Conjunto de diferencia destructivo
        uniques.removeAll(dups);

        System.out.println(&quot;Palabras únicas:     &quot; + uniques);
        System.out.println(&quot;Palabras duplicadas: &quot; + dups);
    }
}
                    </pre>
                </div>
                <p>
                    Cuando se ejecuta con la misma lista de argumentos usada anteriormente (<code>i came i saw i left</code>), el
                    programa produce la siguiente salida.
                </p>
                <div class="codeblock">
                    <pre>
Palabras únicas:     [left, saw, came]
Palabras duplicadas: [i]
                    </pre>
                </div>
                <p>
                    Una operación algebraica de conjuntos menos común es el <i>conjunto diferencia simétrico</i> &mdash; el conjunto
                    de los elementos contenidos en alguno de los dos conjuntos especificados pero no en ambos. El código siguiente
                    calcula el conjunto diferencia simétrico de dos conjuntos no destructivamente.
                </p>
                <div class="codeblock">
                    <pre>
Set&lt;Type&gt; symmetricDiff = new HashSet&lt;Type&gt;(s1);
symmetricDiff.addAll(s2);
Set&lt;Type&gt; tmp = new HashSet&lt;Type&gt;(s1);
tmp.retainAll(s2);
symmetricDiff.removeAll(tmp);
                    </pre>
                </div>
                <h2>
                    Operaciones de Matriz del Interfaz Set
                </h2>
                <p>
                    Las operaciones de matriz no hacen nada especial para los <code>Set</code>s más allá de lo que hacen para
                    cualquier otra <code>Collection</code>. Estas operaciones están descritas en la sección
                    <a class="TutorialLink" target="_top" href="collection.html">La Interfaz Collection</a>.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="collection.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="list.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> El Interfaz Collection<br />
            <b>Página siguiente:</b> El Interfaz List
        </div>
    </body>
</html> 
