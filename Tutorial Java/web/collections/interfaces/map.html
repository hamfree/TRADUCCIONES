<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        
        <title>El Interfaz Map (Los Tutoriales de Java&trade; &gt; Colecciones &gt; Interfaces)</title>
        <meta name="description" content="Este tutorial de Java sobre colecciones describe los interfaces, implementaciones, y
              algoritmos en el marco de trabajo de Colecciones de Java" />
        <meta name="keywords" content="programacion java , aprender java, codigo de ejemplo de java, colecciones de java,
              set, list, queue, map, array, arraylist" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Interfaces</a></div>
                <div class="linkAHEAD"><a href="collection.html">La Interfaz Collection</a></div>
                <div class="linkAHEAD"><a href="set.html">La Interfaz Set</a></div>
                <div class="linkAHEAD"><a href="list.html">La Interfaz List</a></div>
                <div class="linkAHEAD"><a href="queue.html">El Interfaz Queue</a></div>
                <div class="linkAHEAD"><a href="deque.html">La Interfaz Deque</a></div>
                <div class="nolinkAHEAD">El Interfaz Map</div>
                <div class="linkAHEAD"><a href="order.html">Ordenación de Objetos</a></div>
                <div class="linkAHEAD"><a href="sorted-set.html">La Interfaz SortedSet</a></div>
                <div class="linkAHEAD"><a href="sorted-map.html">La Interfaz SortedMap</a></div>
                <div class="linkAHEAD"><a href="summary.html">Sumario de Interfaces</a></div>
                <div class="linkQUESTIONS"><a href="QandE/questions.html">Preguntas y Ejercicios</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Colecciones<br />
                <b>Lección:</b> Interfaces
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Colecciones</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Interfaces</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="deque.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="order.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>El Interfaz Map</h1>
            </div>
            <div id="PageContent">
                <p>
                    Un
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">
                        <code>Map</code>
                    </a> es un objeto que asocia claves a valores. Un map (mapa en español) no puede contener claves duplicadas:
                    cada clave puede asociarse como máximo a un valor. Modela la abstracción matemática <i>function</i>. El
                    interfaz <code>Map</code> incluye métodos para las operaciones básicas (tales como <code>put</code>,
                    <code>get</code>, <code>remove</code>, <code>containsKey</code>, <code>containsValue</code>, <code>size</code>,
                    y <code>empty</code>), operaciones en masa (tales como <code>putAll</code> y <code>clear</code>), y vistas de
                    colección (tales como <code>keySet</code>, <code>entrySet</code>, y <code>values</code>).
                </p>
                <p>
                    La plataforma Jva contiene tres implementaciones de <code>Map</code> de propósito general:
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">
                        <code>HashMap</code>
                    </a>,
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html">
                        <code>TreeMap</code>
                    </a>, and
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html">
                        <code>LinkedHashMap</code>
                    </a>. Su comportamiento y rendimiento son precisamente análogos a <code>HashSet</code>, <code>TreeSet</code>, y
                    <code>LinkedHashSet</code>, como se describió en la sección
                    <a class="TutorialLink" target="_top" href="set.html">El Interfaz Set</a>.
                </p>
                <p>
                    El resto de esta página describe el interfaz <code>Map</code> en detalle. Pero primero, aquí tiene algunos
                    ejemplos más de recolección a <code>Map</code>s usando las operaciones agregadas del KDJ 8. La modelización de
                    objetos del mundo real es una tarea común en la programación orientada a objetos, así que es razonable
                    pensar que algunos programas podrían, por ejemplo, agrupar a los empleados por departamento:
                </p>
                <div class="codeblock">
                    <pre>
// Agrupa a los empleados por departamento
Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()
.collect(Collectors.groupingBy(Employee::getDepartment));
                    </pre>
                </div>
                <p>
                    O calcular la suma de todos los salarios por departamento:
                </p>
                <div class="codeblock">
                    <pre>
// Calcula la suma de salarios por departamento
Map&lt;Department, Integer&gt; totalByDept = employees.stream()
.collect(Collectors.groupingBy(Employee::getDepartment,
Collectors.summingInt(Employee::getSalary)));
                    </pre>
                </div>
                <p>
                    O quizás agrupa los estudiantes en aprobados y suspensos:
                </p>
                <div class="codeblock">
                    <pre>
// Particiona a los estudiantes en aprobados y suspensos
Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()
.collect(Collectors.partitioningBy(s -&gt; s.getGrade()&gt;= PASS_THRESHOLD)); 
                    </pre>
                </div>
                <p>
                    Podría agrupar a la gente por ciudad:
                </p>
                <div class="codeblock">
                    <pre>
// Clasifica los objetos Person por ciudad
Map&lt;String, List&lt;Person&gt;&gt; peopleByCity
         = personStream.collect(Collectors.groupingBy(Person::getCity));
                    </pre>
                </div>
                <p>
                    On incluso encadenar dos colectores para clasificar a la gente por estado y ciudad:
                </p>
                <div class="codeblock">
                    <pre>
// Colectores en cascada
Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; peopleByStateAndCity
  = personStream.collect(Collectors.groupingBy(Person::getState,
  Collectors.groupingBy(Person::getCity)))
                    </pre>
                </div>
                <p>
                    De nuevo, estos son sólo algunos ejemplos de como usar las nuevas IPAs del KDJ 8. Para una cobertura en
                    profundidad de las expresiones lambda y las operaciones agregadas, vea la lección titulada
                    <a class="TutorialLink" target="_top" href="../../collections/streams/index.html">Operaciones de agregación</a>.
                </p>
                <h2>
                    Operaciones Básicas Interfaz Map
                </h2>
                <p>
                    Las operaciones básicas de <code>Map</code> (<code>put</code>, <code>get</code>, <code>containsKey</code>,
                    <code>containsValue</code>, <code>size</code>, y <code>isEmpty</code>) se comportan exactamente como sus
                    contrapartes en <code>Hashtable</code>. El
                    <a class="SourceLink" target="_blank" href="examples/Freq.java"
                       onclick="showCode('../../displayCode.html', 'examples/Freq.java'); return false;">
                        <code>programa siguiente</code>
                    </a> genera una tabla de frecuencias de las palabras encontradas en su lista de argumentos. La tabla de
                    frecuencias asocia cada palabra al número de veces que aparece en la lista de argumentos.
                </p>
                <div class="codeblock">
                    <pre>
import java.util.*;

public class Freq {
    public static void main(String[] args) {
        Map&lt;String, Integer&gt; m = new HashMap&lt;String, Integer&gt;();

        // Inicializa la tabla de frecuencia desde la línea de comandos
        for (String a : args) {
            Integer freq = m.get(a);
            m.put(a, (freq == null) ? 1 : freq + 1);
        }

        System.out.println(m.size() + &quot; palabras distintas:&quot;);
        System.out.println(m);
    }
}
                    </pre>
                </div>
                <p>
                    Lo único difícil de este programa es el segundo argumento de la sentencia <code>put</code>. Ese argumento es
                    una expresión condicional que tiene el efecto de establecer la frecuencia a uno si la palabra no ha sido vista
                    nunca antes o a uno más que su valor actual si la palabra ha sido ya vista. Intente ejecutar este programa con
                    el comando:
                </p>
                <div class="codeblock">
                    <pre>
java Freq if it is to be it is up to me to delegate
                    </pre>
                </div>
                <p>
                    El programa produce la siguiente salida.
                </p>
                <div class="codeblock">
                    <pre>
8 palabras distintas:
{to=3, delegate=1, be=1, it=2, up=1, if=1, me=1, is=2}
                    </pre>
                </div>
                <p>
                    Suponga que usted prefierese ver la tabla de frecuencias en orden alfabético. Todo lo que tiene que hacer es 
                    cambiar el tipo de implementación de <code>Map</code> de <code>HashMap</code> a <code>TreeMap</code>. Hacer este
                    cambio de cuatro caracteres causa que el programa genere la siguiente salida desde la misma línea de comandos.
                </p>
                <div class="codeblock">
                    <pre>
8 palabras distintas:
{be=1, delegate=1, if=1, is=2, it=2, me=1, to=3, up=1}
                    </pre>
                </div>
                <p>
                    De forma similar, podría hacer que el programa imprima la tabla de frecuencias en el orden en el que las palabras
                    aparecen primero en la línea de comando cambiando simplemente el tipo de implementación del mapa a 
                    <code>LinkedHashMap</code>. Hacerlo da como resultado la siguiente salida.
                </p>
                <div class="codeblock">
                    <pre>
8 palabras distintas:
{if=1, it=2, is=2, to=3, be=1, up=1, me=1, delegate=1}
                    </pre>
                </div>
                <p>
                    Esta flexibilidad proporciona una potente ilustración del poder de un marco de trabajo basado en interfaces.
                </p>
                <p>
                    Como los interfaces
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">
                        <code>Set</code>
                    </a> y
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">
                        <code>List</code>
                    </a>, <code>Map</code> refuerza los requisitos de los métodos <code>equals</code> y <code>hashCode</code>
                    de forma que dos objetos <code>Map</code> puedan ser comparados por su igualdad lógica sin preocuparse por sus
                    tipos de implementación. Dos instancias <code>Map</code> son iguales si representan las mismas asociaciones
                    clave-valor.
                </p>
                <p>
                    Por convención, todas las implementaciones de propósito general de <code>Map</code> suministran constructores
                    que toman un objeto <code>Map</code> e inicializan el nuevo <code>Map</code> para que contenga todas las
                    asociaciones clave-valor en el <code>Map</code> especificado. Este constructor de conversión de <code>Map</code>
                    estándar es completamente análogo al constructor estándar de <code>Collection</code>: permite al llamador
                    crear un <code>Map</code> del tipo de implementación deseado que inicialmente contiene todas las asociaciones
                    en otro <code>Map</code>, independientemente del tipo de implementación del otro <code>Map</code>. Por ejemplo,
                    suponga que tienen un <code>Map</code>, llamado <code>m</code>. La siguiente expresión en una línea
                    crea un nuevo <code>HashMap</code> conteniendo inicialmente todas las mismas asociaciones clave-valor que
                    <code>m</code>.
                </p>
                <div class="codeblock">
                    <pre>
Map&lt;K, V&gt; copy = new HashMap&lt;K, V&gt;(m);
                    </pre>
                </div>
                <h2>
                    Operaciones Masivas Interfaz Map
                </h2>
                <p>
                    La operación <code>clear</code> hace exactamente lo que cree que podría hacer: elimina todas las asociaciones
                    del <code>Map</code>. La operación <code>putAll</code> es el análogo del <code>Map</code> de la operación
                    <code>addAll</code> del interfaz <code>Collection</code>. Además de su uso obvio de volcar un <code>Map</code>
                    en otro, tiene un segundo uso más sutil. Suponga que un <code>Map</code> es usado para representar una colección
                    de pares atributo-valor; la operación <code>putAll</code>, en combinación con el constructor de conversión de
                    <code>Map</code>, proporciona una forma ordenda de implementar la creación de un mapa de atributos con valores
                    por defecto. Lo siguiente es un método de factoria estática que demuestra esta técnica.
                </p>
                <div class="codeblock">
                    <pre>
static &lt;K, V&gt; Map&lt;K, V&gt; newAttributeMap(Map&lt;K, V&gt;defaults, Map&lt;K, V&gt; overrides) {
    Map&lt;K, V&gt; result = new HashMap&lt;K, V&gt;(defaults);
    result.putAll(overrides);
    return result;
}
                    </pre>
                </div>
                <h2>
                    Vistas de Collection
                </h2>
                <p>
                    Los métodos de vista de <code>Collection</code> permiten que un <code>Map</code> sea visto como una
                    <code>Collection</code> de estas tres formas:
                </p>
                <ul>
                    <li>
                        <code>keySet</code> &mdash; el  <code>Set</code> de claves contenidas en el <code>Map</code>.
                    </li>
                    <li>
                        <code>values</code> &mdash; la <code>Collection</code> de valores contenidos en el <code>Map</code>. Esta
                        <code>Collection</code> no es un <code>Set</code>, porque múltiples claves pueden asociarse al mismo valor.
                    </li>
                    <li>
                        <code>entrySet</code> &mdash; el <code>Set</code> de pares clave-valor contenidos en el <code>Map</code>. El
                        interfaz <code>Map</code> proporciona una pequeña interfaz anidada llamada <code>Map.Entry</code>, el tipo
                        de elementos en este <code>Set</code>.
                    </li>
                </ul>
                <p>
                    Las vistas de <code>Collection</code> proporcionan el <i>único</i> medio de iterar en un <code>Map</code>. Este
                    ejemplo ilustra el idioma estándar de iterar por las claves en un <code>Map</code> con una construcción
                    <code>for-each</code>:
                </p>
                <div class="codeblock">
                    <pre>
for (KeyType key : m.keySet())
    System.out.println(key);
                    </pre>
                </div>
                <p>
                    y con un <code>iterador</code>:
                </p>
                <div class="codeblock">
                    <pre>
// Filtra un mapa basado en alguna
// propiedad de sus claves.
for (Iterator&lt;Type&gt; it = m.keySet().iterator(); it.hasNext(); )
    if (it.next().isBogus())
        it.remove();
                    </pre>
                </div>
                <p>
                    La forma de iterar sobre los valores es análoga. A continuación se muestra la forma de iterar sobre pares
                    clave-valor.
                </p>
                <div class="codeblock">
                    <pre>
for (Map.Entry&lt;KeyType, ValType&gt; e : m.entrySet())
    System.out.println(e.getKey() + ": " + e.getValue());
                    </pre>
                </div>
                <p>
                    Al principio, a mucha gente le preocupa que estas expresiones puedan ser lentas porque el <code>Map</code>
                    tiene que crear una nueva instanca de <code>Collection</code> cada vez que una operación de vista de
                    <code>Collection</code> se llama. Quédese tranquilo:
                    No hay ninguna razón para que un <code>Map</code> no pueda devolver siempre el mismo objeto cada vez que se le
                    pida una vista de <code>Collection</code> dada. Esto es precisamente lo que todas las implementaciones de
                    <code>Map</code> en <code>java.util</code> hacen.
                </p>
                <p>
                    Con las tres vistas de <code>Collection</code>, llamar a una operación <code>remove</code> en el
                    <code>Iterator</code> elimina la entrada asociada del <code>Map</code> subyacente, asumiendo que el
                    <code>Map</code> subyacente soporte la eliminación de elementos. Esto se ilustra con el modismo de filtrado
                    anterior.
                </p>
                <p>
                    Con la vista <code>entrySet</code>, es también posible cambiar el valor asociado con una clave llamando al
                    método <code>setValue</code> de <code>Map.Entry</code> durante la iteración (de nuevo, asumiendo que el
                    <code>Map</code> soporte la modificación de valores para comenzar). Dese cuenta de que estas son las 
                    <i>únicas</i> formas seguras de modificar un <code>Map</code> durante la iteración; el comportamiento no está
                    especificado si el <code>Map</code> subyacente es modificado de cualquier otra forma mientras la iteración está
                    en progreso.
                </p>
                <p>
                    La vistas de <code>Collection</code> soportan la eliminación de elementos en todas sus formas &mdash;
                    operaciones <code>remove</code>, <code>removeAll</code>, <code>retainAll</code>, y <code>clear</code> , como
                    también la operación <code>Iterator.remove</code>. (Otra vez, esto asumen que el <code>Map</code> subyacente
                    soporta la eliminación de elementos).
                </p>
                <p>
                    Las vistas de <code>Collection</code> <i>no</i> soportan la agragación de elementos bajo ninguna circunstancia.
                    No tendría sentido para las vistas<code>keySet</code> y <code>values</code>, y es innecesarios para la vista
                    <code>entrySet</code>, porque los métodos <code>put</code> y <code>putAll</code> del <code>Map</code>
                    subyacente suministran la misma funcionalidad.
                </p>
                <h2>Usos Sofisticados de Vistas de Colección: Algebra con Map</h2>
                <p>
                    Cuando se aplican a las vistas de <code>Collection</code>, las operaciones masivas (<code>containsAll</code>,
                    <code>removeAll</code>, y <code>retainAll</code>) son herramientas sorprendentemente potentes. Para empezar,
                    supongamos que quiere saber si un <code>Map</code> es un submapa de otro &mdash; esto es , si el primer
                    <code>Map</code> contiene todas las asociaciones clave-valor en el segundo. La siguiente expresión realiza el
                    truco.
                </p>
                <div class="codeblock">
                    <pre>
if (m1.entrySet().containsAll(m2.entrySet())) {
    ...
}
                    </pre>
                </div>
                <p>
                    A lo largo de líneas similares, suponga que quiere saber si dos objetos <code>Map</code> contiene asociaciones
                    para todas las mismas claves.
                </p>
                <div class="codeblock">
                    <pre>
if (m1.keySet().equals(m2.keySet())) {
    ...
}
                    </pre>
                </div>
                <p>
                    Suponga que tiene un <code>Map</code> que representa una colección de pares atributo-valor, y dos
                    <code>Set</code>s representando los atributos requeridos y los atributos permisibles. (Los atributos
                    permisisbles incluyen los atributos requeridos). El siguiente trozo de código determina si el mapa de atributos
                    se ajusta a estas restricciones e imprimir un mensaje de error detallado si no lo hace.
                </p>
                <div class="codeblock">
                    <pre>
static &lt;K, V&gt; boolean validate(Map&lt;K, V&gt; attrMap, Set&lt;K&gt; requiredAttrs, Set&lt;K&gt;permittedAttrs) {
    boolean valid = true;
    Set&lt;K&gt; attrs = attrMap.keySet();

    if (! attrs.containsAll(requiredAttrs)) {
        Set&lt;K&gt; missing = new HashSet&lt;K&gt;(requiredAttrs);
        missing.removeAll(attrs);
        System.out.println("Atributos faltantes: " + missing);
        valid = false;
    }
    if (! permittedAttrs.containsAll(attrs)) {
        Set&lt;K&gt; illegal = new HashSet&lt;K&gt;(attrs);
        illegal.removeAll(permittedAttrs);
        System.out.println("Atributos ilegales: " + illegal);
        valid = false;
    }
    return valid;
}
                    </pre>
                </div>
                <p>
                    Suponga que quiere saber todas las claves comunes en dos objetos <code>Map</code>.
                </p>
                <div class="codeblock">
                    <pre>
Set&lt;KeyType&gt;commonKeys = new HashSet&lt;KeyType&gt;(m1.keySet());
commonKeys.retainAll(m2.keySet());
                    </pre>
                </div>
                <p>
                    Una expresión similar le da los valores comunes.
                </p>
                <p>
                    Todas las expresiones presentadas hasta ahora han sido no destructivas;esto es, no modifican el 
                    <code>Map</code> subyacente. Aquí tiene unas pocas que lo hacen. Supongan que quiere eliminar todas los pares
                    clave-valor que un <code>Map</code> tiene en común con otro.
                </p>
                <div class="codeblock">
                    <pre>
m1.entrySet().removeAll(m2.entrySet());
                    </pre>
                </div>
                <p>
                    Suponga que quiere eliminar de un <code>Map</code> todas las claves que tengan asociaciones en otro.
                </p>
                <div class="codeblock">
                    <pre>
m1.keySet().removeAll(m2.keySet());
                    </pre>
                </div>
                <p>
                    ¿Qué sucede cuando comienzas a mezclar claves y valores en la misma operación masiva? Suponga que tiene un
                    <code>Map</code>, <code>managers</code>, que asocia cada empleado en una compañía al gestor del empleado.
                    Seremos deliberadamente vagos sobre los tipos de la clave y los objetos de valor. No importa, siempre y cuando
                    sean lo mismos. Ahora suponga que quiere saber quiénes son todos los "contribuyentes individuales" (o no
                    gestores). El siguiente trozo de ´codigo le indica exactamente lo que quiere saber.
                </p>
                <div class="codeblock">
                    <pre>
Set&lt;Employee&gt; individualContributors = new HashSet&lt;Employee&gt;(managers.keySet());
individualContributors.removeAll(managers.values());
                    </pre>
                </div>
                <p>
                    Suponga que quiere despedir a todos los empleados que informan directament a un gestor, Simon.
                </p>
                <div class="codeblock">
                    <pre>
Employee simon = ... ;
managers.values().removeAll(Collections.singleton(simon));
                    </pre>
                </div>
                <p>
                    Dese cuenta de que esta expresión hace uso de <code>Collections.singleton</code>, un método de factoría
                    estático que devuelve un <code>Set</code> inmutable con el elemento único y especificado.
                </p>
                <p>
                    Una vez haya hecho esto, puede tener un grupo de empleados cuyos gerentes ya no trabajen para la empresa (si
                    alguno de los que informan directamente a Simon fueran ellos mismos gerentes). El código siguiente le indicará
                    cuantos empleados tienen gerentes que ya no trabajan para la compañía.
                </p>
                <div class="codeblock">
                    <pre>
Map&lt;Employee, Employee&gt; m = new HashMap&lt;Employee, Employee&gt;(managers);
m.values().removeAll(managers.keySet());
Set&lt;Employee&gt; slackers = m.keySet();
                    </pre>
                </div>
                <p>
                    Este ejemplo es un poco complicado. Primero, hace una copia temporal del <code>Map</code>, y elimina de la
                    copia temporal todas las entradas cuyo (gerente) valor es una clave en el <code>Map</code> original. Recuerde
                    que el <code>Map</code> original tiene una entrada para cada empleado. Así, las entradas restantes en el
                    <code>Map</code> temporal comprende todas las entradas del <code>Map</code> original cuyos valores (manager) ya
                    no son empleados. Las claves en la copia temporal, entonces, representan precisamente los empleados que estamos
                    buscando.
                </p>
                <p>
                    Hay muchos más modismos como los que figuran en esta sección, pero sería poco práctico y tedioso enumerarlos a 
                    todos. Una vez que lo domina, no es tan difícil encontrar el correcto cuando lo necesita.
                </p>
                <h2>
                    Multimapas
                </h2>
                <p>
                    Un <i>multimap</i> es como un <code>Map</code> pero puede asociar cada clave a múltiples valores. El Marco de
                    trabajo de Colecciones de Java no incluye un interfaz para los multimapas porque no se usan con tanta
                    frecuencia. Es un asunto bastante simple usar un <code>Map</code> cuyos valores son instancias de
                    <code>List</code> como multimap. Esta técnica se demuestra en el siguiente código de ejemplo, el cual lee una
                    lista de palabras conteniendo una palabra por línea (todas en minúsculas) e imprime todos los grupos de
                    anagramas que cumplen un criterio de tamaño. Un <i>grupo de anagrama</i> es un conjunto de palabras, las cuales
                    contienen exactamente las misms letras pero en orden diferente. El programa toma dos argumentos en la línea de
                    comandos: (1) el nombre del fichero con el diccionario y (2) el tamaño mínimo de grupo anagrama a imprimir. Los
                    grupos de anagrma que contienen menos palabras que el mínimo especificado no serán impresos.
                </p>
                <p>
                    Hay un truco estándar para encontrar grupos de anagramas: Para cada palabra en el diccionario, alfabetiza las
                    letras en la palabra (esto es, reorden loas letras de la palabra en orden alfabético) y coloque una entrada en
                    un multimapa, asociando la palabra alfabetizada a la palabra original. Por ejemplo, la palabra <em>bad</em>
                    causa una entrada mapeada <em>abd</em> en <em>bad</em> a ser colocada en el multimapa. Un momento de reflexión
                    mostrará que todas las palabras con las cuales un mapa clave dado forman un grupo anagrama. Es una simple
                    cuestión de iterar sobre las teclas en el multimapa, imprimiendo cada grupo de anagramas que cumple con la
                    restricción de tamaño.
                </p>
                <p>
                    <a class="SourceLink" target="_blank" href="examples/Anagrams.java"
                       onclick="showCode('../../displayCode.html', 'examples/Anagrams.java'); return false;">
                        <code>El siguiente programa</code>
                    </a> es una implementación directa de esta técnica.
                </p>
                <div class="codeblock">
                    <pre>
import java.util.*;
import java.io.*;

public class Anagrams {
    public static void main(String[] args) {
        int minGroupSize = Integer.parseInt(args[1]);

        // Lee palabras del fichero y las coloca en un multimapa simulado
        Map&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;String, List&lt;String&gt;&gt;();

        try {
            Scanner s = new Scanner(new File(args[0]));
            while (s.hasNext()) {
                String word = s.next();
                String alpha = alphabetize(word);
                List&lt;String&gt; l = m.get(alpha);
                if (l == null)
                    m.put(alpha, l=new ArrayList&lt;String&gt;());
                l.add(word);
            }
        } catch (IOException e) {
            System.err.println(e);
            System.exit(1);
        }

        // Imprime todos los grupos de permutación que están por encima del límite de tamaño
        for (List&lt;String&gt; l : m.values())
            if (l.size() &gt;= minGroupSize)
                System.out.println(l.size() + &quot;: &quot; + l);
    }

    private static String alphabetize(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}
                    </pre>
                </div>
                <p>
                    Ejecutar este programa sobre un fichero de diccionario de 173.000 palabras con un tamaño mínimo de
                    grupo de anagrama de ocho produce la salida siguiente.
                </p>
                <div class="codeblock">
                    <pre>
9: [estrin, inerts, insert, inters, niters, nitres, sinter,
     triens, trines]
8: [lapse, leaps, pales, peals, pleas, salep, sepal, spale]
8: [aspers, parses, passer, prases, repass, spares, sparse,
     spears]
10: [least, setal, slate, stale, steal, stela, taels, tales,
      teals, tesla]
8: [enters, nester, renest, rentes, resent, tenser, ternes,
     treens]
8: [arles, earls, lares, laser, lears, rales, reals, seral]
8: [earings, erasing, gainers, reagins, regains, reginas,
     searing, seringa]
8: [peris, piers, pries, prise, ripes, speir, spier, spire]
12: [apers, apres, asper, pares, parse, pears, prase, presa,
      rapes, reaps, spare, spear]
11: [alerts, alters, artels, estral, laster, ratels, salter,
      slater, staler, stelar, talers]
9: [capers, crapes, escarp, pacers, parsec, recaps, scrape,
     secpar, spacer]
9: [palest, palets, pastel, petals, plates, pleats, septal,
     staple, tepals]
9: [anestri, antsier, nastier, ratines, retains, retinas,
     retsina, stainer, stearin]
8: [ates, east, eats, etas, sate, seat, seta, teas]
8: [carets, cartes, caster, caters, crates, reacts, recast,
     traces]

                    </pre>
                </div>
                <p>
                    Muchas de estas palabras parecen un poco falsas, pero eso no es culpa del programa; están en el fichero del
                    diccionario. Aquí está el
                    <a class="SourceLink" target="_blank"
                       href="examples/dictionary.txt"
                       onclick="showCode('../../displayCode.html', 'examples/dictionary.txt'); return false;">
                        <code>fichero diccionario</code>
                    </a> que usamos. Se derivó de la lista de palabras de referencia de referencia de ENABLE Public Domain.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="deque.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="order.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> El Interfaz Deque<br />
            <b>Página siguiente:</b> Ordenación de Objetos
        </div>
    </body>
</html> 
