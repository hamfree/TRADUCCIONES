<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        
        <title>El Interfaz List (Los Tutoriales de Java&trade; &gt; Colecciones &gt; Interfaces)</title>
        <meta name="description" content="Este tutorial de Java sobre colecciones describe los interfaces, implementaciones, y
              algoritmos en el marco de trabajo de Colecciones de Java" />
        <meta name="keywords" content="programacion java , aprender java, codigo de ejemplo de java, colecciones de java,
              set, list, queue, map, array, arraylist" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Interfaces</a></div>
                <div class="linkAHEAD"><a href="collection.html">La Interfaz Collection</a></div>
                <div class="linkAHEAD"><a href="set.html">La Interfaz Set</a></div>
                <div class="nolinkAHEAD">La Interfaz List</div>
                <div class="linkAHEAD"><a href="queue.html">La Interfaz Queue</a></div>
                <div class="linkAHEAD"><a href="deque.html">La Interfaz Deque</a></div>
                <div class="linkAHEAD"><a href="map.html">La Interfaz Map</a></div>
                <div class="linkAHEAD"><a href="order.html">Ordenación de Objetos</a></div>
                <div class="linkAHEAD"><a href="sorted-set.html">La Interfaz SortedSet</a></div>
                <div class="linkAHEAD"><a href="sorted-map.html">La Interfaz SortedMap</a></div>
                <div class="linkAHEAD"><a href="summary.html">Sumario de Interfaces</a></div>
                <div class="linkQUESTIONS"><a href="QandE/questions.html">Preguntas y Ejercicios</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Colecciones<br />
                <b>Lección:</b> Interfaces
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Colecciones</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Interfaces</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="set.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="queue.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>La Interfaz List</h1>
            </div>
            <div id="PageContent">
                <p>
                    Una
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">
                        <code>List</code>
                    </a> es una
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">
                        <code>Collection</code>
                    </a> ordenada (algunas veces llamada una <i>secuencia</i>). Las listas pueden contener elementos duplicados.
                    Además de las operaciones heredadas de <code>Collection</code>, la interfaz <code>List</code> incluye
                    operaciones para lo siguiente:
                </p>
                <ul>
                    <li>
                        <code>Acceso posicional</code> &mdash; manipula elementos basándose en su posición numérica en la lista.
                        Esto incluye métodos tales como <code>get</code>, <code>set</code>, <code>add</code>, <code>addAll</code>,
                        y <code>remove</code>.
                    </li>
                    <li>
                        <code>Búsqueda</code> &mdash; las búsquedas de un objeto específico en la lista y devuelve su posición
                        numérica. Los métodos de búsqueda incluyen <code>indexOf</code> y <code>lastIndexOf</code>.
                    </li>
                    <li>
                        <code>Iteración</code> &mdash; extiende la semántica de <code>Iterator</code> para aprovechar la naturaleza
                        secuencial de la lista. Los métodos <code>listIterator</code> suministran este comportamiento.
                    </li>
                    <li>
                        <code>Vista de rango</code> &mdash; El método <code>sublist</code> realiza <i>operaciones de rango</i>
                        arbitrarias sobre la lista.
                    </li>
                </ul>
                <p>
                    La plataforma Java contiene dos implementaciones de propósito general de <code>List</code>.
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">
                        <code>ArrayList</code>
                    </a>, la cual es usualmente la implementación de mejor rendimiento, y
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html">
                        <code>LinkedList</code>
                    </a> que ofrece mejor rendimiento bajo ciertas circunstancias.
                </p>
                <h2>Operaciones de Collection</h2>
                <p>
                    Las operaciones heredadas de <code>Collection</code> hacen todo lo que esperaría que hicieran, asumiendo que
                    está ya familiarizado con ellas. Si no está familiarizado con ellas desde <code>Collection</code>, ahora sería
                    un buen momento para leer la sección
                    <a class="TutorialLink" target="_top" href="collection.html">El Interfaz Collection</a>. La operación
                    <code>remove</code> siempre elimina <i>la primera </i> ocurrencia del elemento especificado de la lista. Las
                    operaciones <code>add</code> y <code>addAll</code> siempre añaden el/los nuevo/s elemento/s al <i>final</i> de
                    la lista. De esta forma, la siguiente expresión concatena una lista a otra.
                </p>
                <div class="codeblock">
                    <pre>
list1.addAll(list2);
                    </pre>
                </div>
                <p>
                    Aquí tiene una forma no destructiva de esta expresión, la cual produce una tercera <code>List</code> que
                    consiste de la segunda lista agregada a la primera.
                </p>
                <div class="codeblock">
                    <pre>
List&lt;Type&gt; list3 = new ArrayList&lt;Type&gt;(list1);
list3.addAll(list2);
                    </pre>
                </div>
                <p>
                    Note que la expresión, en su forma no destructiva, se aprovecha del constructor estándar de conversión de
                    <code>ArrayList</code>.
                </p>
                <p>
                    Y aquí tiene un ejemplo (KDD 8 o posterior) que agrega algunos nombres en una <code>List</code>:
                </p>
                <div class="codeblock">
                    <pre>
List&lt;String&gt; list = people.stream()
.map(Person::getName)
.collect(Collectors.toList());
                    </pre>
                </div>
                <p>
                    Como el interfaz
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">
                        <code>Set</code>
                    </a>, <code>List</code> refuerza los requisitos en los métodos <code>equals</code> y <code>hashCode</code> de
                    froma que dos objetos <code>List</code> puedan ser comparados por su igualdad lógica sin preocuparse de sus
                    clases de implementación. Dos objetos <code>List</code> son iguales si contienen los mismos elementos en el
                    mismo orden.
                </p>
                <h2>Acceso Posicional y Operaciones de Búsqueda</h2>
                <p>
                    Las operaciones básicas de <code>acceso posicional</code> son <code>get</code>, <code>set</code>,
                    <code>add</code> y <code>remove</code>. (Las operaciones <code>set</code> y <code>remove</code> devuelven el
                    valor viejo que está siendo sobreescrito o eliminado). Otras operaciones (<code>indexOf</code> y
                    <code>lastIndexOf</code>) devuelven el primer o último índice del elemento especificado en la lista.
                </p>
                <p>
                    La operación <code>addAll</code> inserta todos los elementos de la <code>Collection</code> especificada empezando
                    en la posición especificada. Los elementos son insertados en el orden en el que son devueltos por el iterador 
                    especificado de la <code>Collection</code>. Esta llamada es el análogo de acceso posicional de la operación
                    <code>addAll</code> de <code>Collection</code>.
                </p>
                <p>
                    Aquí tiene un pequeño método para intercambiar dos valores indexados en una <code>List</code>.
                </p>
                <div class="codeblock">
                    <pre>
public static &lt;E&gt; void swap(List&lt;E&gt; a, int i, int j) {
    E tmp = a.get(i);
    a.set(i, a.get(j));
    a.set(j, tmp);
}
                    </pre>
                </div>
                <p>
                    <a id="shuffle">Por supuesto, hay una gran diferencia.</a> Este es un algoritmo polimórfico: intercambia dos
                    elementos en cualquier <code>List</code>, independientemente de su tipo de implementación. Aquí tiene otro
                    algoritmo polimórfico que usa el método <code>swap</code> precedente.
                </p>
                <div class="codeblock">
                    <pre>
public static void shuffle(List&lt;?&gt; list, Random rnd) {
    for (int i = list.size(); i &gt; 1; i--)
        swap(list, i - 1, rnd.nextInt(i));
}
                    </pre>
                </div>
                <p>
                    Este algoritmo, el cual está incluido en la clase
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html">
                        <code>Collections</code>
                    </a> de la plataforma Java, permuta aleatoriamente la lista especificada usando la fuente de aleatoriedad
                    especificada. Es un poco sutil: Se ejecuta en la lista desde la parte inferior, intercambiando repetidamente un
                    elemento seleccionado al azar en la posición actual. A diferencia de la mayoría de intentos ingenuos de barajar,
                    es <i>justo</i> (todas las permutaciones ocurren con la misma probabilidad, asumiendo una fuente imparcial de
                    aleatoriedad) y <i>rápido</i> (requiriendo exactamente <code>list.size()-1</code> intercambios). El programa
                    siguiente usa este algoritmo para visualizar las palabras en su lista de argumentos en orden aleatorio.
                </p>
                <div class="codeblock">
                    <pre>
import java.util.*;

public class Shuffle {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        for (String a : args)
            list.add(a);
        Collections.shuffle(list, new Random());
        System.out.println(list);
    }
}
                    </pre>
                </div>
                <p>
                    En realidad, este programa puede ser hecho más corto y más rápido. La clase
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html">
                        <code>Arrays</code>
                    </a> tiene un método de factoría estático llamado <code>asList</code>, el cual permite que una matriz sea vista
                    como una <code>List</code>. Este método no copia la matriz. Los cambios en la <code>List</code> se escriben en
                    la matriz y viceversa. La List resultante no es una implementación de <code>List</code> de propósito general, 
                    porque no implementa las operaciones (opcionales) <code>add</code> y <code>remove</code>: Las matrices no son
                    redimensionables. Aprovecharse de <code>Arrays.asList</code> y llamar a la versión de librería de
                    <code>shuffle</code>, que usa una fuente de aleatoriedad por defecto, hace que obtenga lo siguiente:
                    <a class="SourceLink" target="_blank"
                       href="examples/Shuffle.java"
                       onclick="showCode('../../displayCode.html', 'examples/Shuffle.java'); return false;">
                        <code>pequeño programa</code>
                    </a> cuyo comportamiento es idéntico al del programa anterior.
                </p>
                <div class="codeblock">
                    <pre>
import java.util.*;

public class Shuffle {
    public static void main(String[] args) {
        List&lt;String&gt; list = Arrays.asList(args);
        Collections.shuffle(list);
        System.out.println(list);
    }
}
                    </pre>
                </div>
                <h2><a id="Iterator">Iteradores</a></h2>
                <p>
                    Como esperaría, el <code>Iterator</code> devuelto por la operación <code>iterator</code> de <code>List</code>
                    devuelve los elementos de la lista en la secuencia apropiada. <code>List</code> también suministra un iterador
                    más complejo, llamado un <code>ListIterator</code>, el cual nos permite atravesar la lista en cualquier
                    dirección, modificar la lista durante la iteración, y obtener la posición actual del iterador.
                </p>
                <p>
                    Los tres métodos que <code>ListIterator</code> hereda desde <code>Iterator</code> (<code>hasNext</code>,
                    <code>next</code>, y <code>remove</code>) hacen exactamente lo mismo en ambos interfaces. Las operaciones
                    <code>hasPrevious</code> y <code>previous</code> son análogos exactos de <code>hasNext</code> y
                    <code>next</code>. Las operaciones anteriores se refieren al elemento antes del cursor (implícito), mientras
                    que los segundos se refieren al elemento después del cursor. La operación <code>previous</code> mueve el cursor
                    hacia atrás, mientras que <code>next</code> lo mueve hacia delante.
                </p>
                <p>
                    Aquí tiene la expresión estándar para iterar hacia atrás a traves de una lista.
                </p>
                <div class="codeblock">
                    <pre>
for (ListIterator&lt;Type&gt; it = list.listIterator(list.size()); it.hasPrevious(); ) {
    Type t = it.previous();
    ...
}
                    </pre>
                </div>
                <p>
                    Dese cuenta del argumento a <code>listIterator</code> en la expresión anterior. El interfaz <code>List</code>
                    tiene dos formas del método <code>listIterator</code>. La forma sin argumentos devuelve un
                    <code>ListIterator</code> posicionado al prinicipio de la lista; la forma con un argumento <code>int</code>
                    devuelve un <code>ListIterator</code> posicionado en el índice especificado. El índice se refiere al elemento
                    que será devuelto por una llamada inicial a <code>next</code>. Una llamada inicial a <code>previous</code>
                    devolverá el elemento cuyo índice fue <code>index - 1</code>. En una lista de longitud <code>n</code>, hay
                    <code>n + 1</code> valores válidos para el <code>índice</code>, desde <code>0</code> a <code>n</code>, inclusive.
                </p>
                <p>
                    Intuitivamente hablando, el cursor siempre está entre dos elementos &mdash; el primero que sería devuelto por
                    una llamada a <code>previous</code> y el segundo que sería devuelto por una llamada a <code>next</code>. Los
                    valores de <code>índice</code> <code>n + 1</code> válidos corresponden a los huecos <code>n + 1</code> entre
                    elementos, desde el hueco antes del primer elemento al hueco que está después del último.
                    <span id="figure:colls-fivePossibleCursor.gif">La figura siguiente</span> muestra las cinco posibles posiciones
                    del cursor en una lista que contiene cuatro elementos.
                </p>
                <p style="text-align: center;">
                    <img src="../../figures/collections/colls-fivePossibleCursor.gif"
                         width="370" height="98" 
                         alt="Cinco flechas representan las cinco posiciones del cursor, de 0 a 4, con cuatro elementos, uno entre
                         cada flecha." />
                </p>
                <p class="FigureCaption">
                    Las cinco posibles posiciones del cursor.
                </p>
                <p>
                    Las llamadas a <code>next</code> y <code>previous</code> pueden ser mezcladas, pero tiene que ser un poco
                    cuidadoso. La primera llamada a <code>previous</code> devuelve el mosmo elemento como la última llamada a
                    <code>next</code>. De forma similar, la primera llamada a <code>next</code> después de una secuencia de llamadas
                    a <code>previous</code> devuelve el mismo elemento como la última llamada a <code>previous</code>.
                </p>
                <p>
                    No debería sorprender que el método <code>nextIndex</code> devuelve el índice del elemento que sería devuelto
                    por una llamada subsecuente a <code>next</code>, y <code>previousIndex</code> devuelve el índice del elemento
                    que sería devuelto por una llamada subsecuente a <code>previous</code>. Estas llamadas son usadas típicamente o
                    para informar de la posición donde algo se encontró o para grabar la posición del <code>ListIterator</code>
                    de forma que otro <code>ListIterator</code> con una posición idéntica pueda ser creado.
                </p>
                <p>
                    No debería sorprender que el número devuelto por <code>nextIndex</code> es siempre uno mayor que el número
                    devuelto por <code>previousIndex</code>. Esto implica el comportamiento de los dos casos límite:
                    (1) una llamada a <code>previousIndex</code> cuando el cursor está antes del elemento inicial devuelve
                    <code>-1</code> y (2) una llamada a <code>nextIndex</code> cuando el cursor está después del elemento final
                    devuelve <code>list.size()</code>. Para hacer todo esto concreto, lo siguiente es una implementación posible
                    de <code>List.indexOf</code>.
                </p>
                <div class="codeblock">
                    <pre>
public int indexOf(E e) {
    for (ListIterator&lt;E&gt; it = listIterator(); it.hasNext(); )
        if (e == null ? it.next() == null : e.equals(it.next()))
            return it.previousIndex();
    // Elemento no encontrado
    return -1;
}
                    </pre>
                </div>
                <p>
                    Tenga en cuenta que el método <code>indexOf</code> devuelve <code>it.previousIndex()</code> a pesar de que está
                    atravesando la lista en la dirección de avance. La razón es que <code>it.nextIndex()</code> devolvería el
                    índice del elemento que estamos a punto de examinar, y nosotros queremos devolver el índice del elemento que
                    acabamos de examinar.
                </p>
                <p>
                    El interfaz <code>Iterator</code> suministra la operación <code>remove</code> para eliminar el último elemento
                    devuelto por <code>next</code> de la <code>Collection</code>. Para <code>ListIterator</code>, esta operación
                    elimina el último elemento devuelto por <code>next</code> o <code>previous</code>. El interfaz
                    <code>ListIterator</code> suministra dos operaicones adicionales para modificar la lista &mdash;
                    <code>set</code> y <code>add</code>. El método <code>set</code> sobreescribe el último elemento devuelto por
                    <code>next</code> o <code>previous</code> con el elemento especificado. El algoritmo polimórfico siguiente
                    usa <code>set</code> para reemplazar todas las ocurrencias de un valor especificado con otro.
                </p>
                <div class="codeblock">
                    <pre>
public static &lt;E&gt; void replace(List&lt;E&gt; list, E val, E newVal) {
    for (ListIterator&lt;E&gt; it = list.listIterator(); it.hasNext(); )
        if (val == null ? it.next() == null : val.equals(it.next()))
            it.set(newVal);
}
                    </pre>
                </div>
                <p>
                    El único truco en este ejemplo es la prueba de igualdad entre <code>val</code> y <code>it.next</code>.
                    Necesita un valor de caso especial de <code>val</code> de <code>null</code> para evitar una
                    <code>NullPointerException</code>.
                </p>
                <p>
                    El método <code>add</code> inserta un elemento nuevo en la lista inmediatamente antes de la posición actual del
                    cursor.  Este método se ilistra en el siguiente algoritmo polimórfico para reemplazar todas las ocurrencias de
                    un valor específico con la secuencia de valores contenidos en la lista especificada.
                </p>
                <div class="codeblock">
                    <pre>
public static &lt;E&gt; 
    void replace(List&lt;E&gt; list, E val, List&lt;? extends E&gt; newVals) {
    for (ListIterator&lt;E&gt; it = list.listIterator(); it.hasNext(); ){
        if (val == null ? it.next() == null : val.equals(it.next())) {
            it.remove();
            for (E e : newVals)
                it.add(e);
        }
    }
}
                    </pre>
                </div>
                <h2>Operación Range-View</h2>
                <p>
                    La operación <code>range-view</code>, <code>subList(int fromIndex, int toIndex)</code>, devuelve una vista
                    <code>List</code> de la porción de esta lista cuyo rango de índices desde <code>fromIndex</code>, inclusive,
                    a <code>toIndex</code>, exclusive. Este <i>rango medio-abierto</i> refleja el típico bucle <code>for</code>.
                </p>
                <div class="codeblock">
                    <pre>
for (int i = fromIndex; i &lt; toIndex; i++) {
    ...
}
                    </pre>
                </div>
                <p>
                    Como el término <i>vista</i> implica, la <code>List</code> devuelta está respaldada por la <code>List</code> en
                    la cual <code>subList</code> fue llamada, por lo que los cambios en el primero se reflejan en el segundo.
                </p>
                <p>
                    Este método elimina la necesidad de operaciones explícitas de rango ( de la clase que existen comunmente para
                    los matrices). Cualquier operación que espera una <code>List</code> puede ser usada como una operación de rango
                    pasando una vista <code>subList</code> en vez de una <code>List</code> completa. Por ejemplo, la siguiente
                    expresión elimina un rango de elementos de una <code>List</code>.
                </p>
                <div class="codeblock">
                    <pre>
list.subList(fromIndex, toIndex).clear();
                    </pre>
                </div>
                <p>
                    Expresiones similares pueden ser construidas para buscar un elemento en un rango.
                </p>
                <div class="codeblock">
                    <pre>
int i = list.subList(fromIndex, toIndex).indexOf(o);
int j = list.subList(fromIndex, toIndex).lastIndexOf(o);
                    </pre>
                </div>
                <p>
                    Tenga en cuenta que las expresiones precedentes devuelven el índice del elemento encontrado en la 
                    <code>subList</code>, no el índice en la <code>List</code> que está debajo.
                </p>
                <p>
                    Cualquier algorítmico polimórfico que opera sobre una <code>List</code>, tal como los ejemplos de
                    <code>replace</code> y <code>shuffle</code>, trabajan con la <code>List</code> devuelta por
                    <code>subList</code>.
                </p>
                <p>
                    Aquí tiene un algoritmo polimórfico cuya implementación usa <code>subList</code> para manejar una mano de una
                    baraja. Esto es, devuelve una nueva <code>List</code> (la &quot;mano&quot;) que contiene el número específico
                    de elementos tomados del final de la <code>List</code> especificada (la &quot;baraja&quot;). Los elementos
                    devueltos en la mano son eliminados de la baraja.
                </p>
                <div class="codeblock">
                    <pre>
public static &lt;E&gt; List&lt;E&gt; dealHand(List&lt;E&gt; deck, int n) {
    int deckSize = deck.size();
    List&lt;E&gt; handView = deck.subList(deckSize - n, deckSize);
    List&lt;E&gt; hand = new ArrayList&lt;E&gt;(handView);
    handView.clear();
    return hand;
}
                    </pre>
                </div>
                <p>
                    Tenga en cuenta que este algoritmo elimina la mano del <i>final</i> de la baraja. Para muchas implementaciones
                    comunes de <code>List</code>, tales como <code>ArrayList</code>, el rendimiento de eliminar elementos del final
                    de la lista es substancialmente mejor que el de eliminar elementos del principio.
                </p>
                <p>
                    Lo siguiente es
                    <a class="SourceLink" target="_blank"
                       href="examples/Deal.java"
                       onclick="showCode('../../displayCode.html', 'examples/Deal.java'); return false;">
                        <code>un programa</code>
                    </a> que usa el método <code>dealHand</code> en combinación con <code>Collections.shuffle</code> para generar
                    manos de una baraja normal de 52 cartas. El programa toma dos argumentos de la línea de comandos: (1) el número
                    de manos para manejar y (2) el número de cartas en cada mano.
                </p>
                <div class="codeblock">
                    <pre>
import java.util.*;

public class Deal {
    public static void main(String[] args) {
        if (args.length &lt; 2) {
            System.out.println("Uso: Deal manos cartas");
            return;
        }
        int numHands = Integer.parseInt(args[0]);
        int cardsPerHand = Integer.parseInt(args[1]);
    
        // Make a normal 52-card deck.
        String[] suit = new String[] {
            "spades", "hearts", 
            "diamonds", "clubs" 
        };
        String[] rank = new String[] {
            "ace", "2", "3", "4",
            "5", "6", "7", "8", "9", "10", 
            "jack", "queen", "king" 
        };

        List&lt;String&gt; deck = new ArrayList&lt;String&gt;();
        for (int i = 0; i &lt; suit.length; i++)
            for (int j = 0; j &lt; rank.length; j++)
                deck.add(rank[j] + " of " + suit[i]);
    
        // Mezcla la baraja.
        Collections.shuffle(deck);
    
        if (numHands * cardsPerHand &gt; deck.size()) {
            System.out.println("Not enough cards.");
            return;
        }
    
        for (int i = 0; i &lt; numHands; i++)
            System.out.println(dealHand(deck, cardsPerHand));
    }
  
    public static &lt;E&gt; List&lt;E&gt; dealHand(List&lt;E&gt; deck, int n) {
        int deckSize = deck.size();
        List&lt;E&gt; handView = deck.subList(deckSize - n, deckSize);
        List&lt;E&gt; hand = new ArrayList&lt;E&gt;(handView);
        handView.clear();
        return hand;
    }
}
                    </pre>
                </div>
                <p>
                    Ejecutar el programa produce una salida como la siguiente.
                </p>
                <div class="codeblock">
                    <pre>
% java Deal 4 5

[8 of hearts, jack of spades, 3 of spades, 4 of spades,
    king of diamonds]
[4 of diamonds, ace of clubs, 6 of clubs, jack of hearts,
    queen of hearts]
[7 of spades, 5 of spades, 2 of diamonds, queen of diamonds,
    9 of clubs]
[8 of spades, 6 of diamonds, ace of spades, 3 of hearts,
    ace of hearts]
                    </pre>
                </div>
                <p>
                    Aunque la operación <code>subList</code> es extremadamente poderosa, se debe tener cuidado al usarla. La
                    semántica de la <code>List</code> devuelta por <code>subList</code> se vuelve no definida si los elementos
                    son agregados o eliminado desde la <code>List</code> subyacente en cualquier otra forma distinta que la
                    <code>List</code> devuelta. Así, es muy recomendable que use la <code>List</code> devuelta por
                    <code>subList</code> sólo como un objeto transitorio &mdash; para realizar una o una secuencia de operaciones
                    de rango sobre la <code>List</code> de respaldo. Cuanto más use la instancia de <code>subList</code>, mayor es
                    la probabilidad de que se comprometa modificando la <code>List</code> de respaldo directamente o a través de 
                    otro objeto <code>subList</code>. Tenga en cuenta que es legal modificar una sublista de una sublista y
                    continuar usando la sublista original (aunque no al mismo tiempo).
                </p>
                <h2>Algoritmos de List</h2>
                <p>
                    La mayoría de los algoritmos polimórficos en la clase <code>Collections</code> se aplican especificamente a
                    <code>List</code>. Tener todos estos algoritmos a su disposición hace muy fácil manipular listas. Aquí tiene
                    una sumarios de estos algoritmos, los cuales son descritos en más detalle en la sección
                    <a class="TutorialLink" target="_top" href="../algorithms/index.html">Algoritmos</a>.
                </p>
                <ul>
                    <li>
                        <code>sort</code> &mdash; ordena una <code>List</code> usando un algoritmo de ordenación mezcla, el cual
                        suministra una ordenación estable y rápida. (Una <i>ordenación estable</i> es una que no reordena los
                        elementos iguales).
                    </li>
                    <li>
                        <code>shuffle</code> &mdash; cambia al azar los elementos en una <code>List</code>.
                    </li>
                    <li>
                        <code>reverse</code> &mdash; invierte el orden de los elementos en una <code>List</code>.
                    </li>
                    <li>
                        <code>rotate</code> &mdash; rota todos los elementos en una <code>List</code> por una distancia
                        especificada.
                    </li>
                    <li>
                        <code>swap</code> &mdash; intercambia los elementos en las posiciones especificadas en una <code>List</code>.
                    </li>
                    <li>
                        <code>replaceAll</code> &mdash; reemplaza todas las ocurrencias de un valor especificado con otro.
                    </li>
                    <li>
                        <code>fill</code> &mdash; sobreescribe cada elemento en una <code>List</code> con el valor especificado.
                    </li>
                    <li>
                        <code>copy</code> &mdash; copia la <code>List</code> fuente en la <code>List</code> de destino.
                    </li>
                    <li>
                        <code>binarySearch</code> &mdash; busca por un elemento en una <code>List</code> ordenada usando el
                        algoritmo de búsqueda binaria.
                    </li>
                    <li>
                        <code>indexOfSubList</code> &mdash; devuelve el índice de la primera sublista de una <code>List</code> que
                        es igual a otra.
                    </li>
                    <li>
                        <code>lastIndexOfSubList</code> &mdash; devuelve el índice de la última sublista de una <code>List</code>
                        que es igual a otra.
                    </li>
                </ul>
            </div>
            <div class="NavBit">
                <a target="_top" href="set.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="queue.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> El Interfaz Set<br />
            <b>Página siguiente:</b> El Interfaz Queue
        </div>
    </body>
</html> 
