<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        
        <title>Ordenación de Objetos (Los Tutoriales de Java&trade; &gt; Colecciones &gt; Interfaces)</title>
        <meta name="description" content="Este tutorial de Java sobre colecciones describe los interfaces, implementaciones, y
              algoritmos en el marco de trabajo de Colecciones de Java" />
        <meta name="keywords" content="programacion java , aprender java, codigo de ejemplo de java, colecciones de java,
              set, list, queue, map, array, arraylist" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Interfaces</a></div>
                <div class="linkAHEAD"><a href="collection.html">La Interfaz Collection</a></div>
                <div class="linkAHEAD"><a href="set.html">La Interfaz Set</a></div>
                <div class="linkAHEAD"><a href="list.html">La Interfaz List</a></div>
                <div class="linkAHEAD"><a href="queue.html">El Interfaz Queue</a></div>
                <div class="linkAHEAD"><a href="deque.html">La Interfaz Deque</a></div>
                <div class="linkAHEAD"><a href="map.html">El Interfaz Map</a></div>
                <div class="nolinkAHEAD">Ordenación de Objetos</div>
                <div class="linkAHEAD"><a href="sorted-set.html">La Interfaz SortedSet</a></div>
                <div class="linkAHEAD"><a href="sorted-map.html">La Interfaz SortedMap</a></div>
                <div class="linkAHEAD"><a href="summary.html">Sumario de Interfaces</a></div>
                <div class="linkQUESTIONS"><a href="QandE/questions.html">Preguntas y Ejercicios</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Colecciones<br />
                <b>Lección:</b> Interfaces
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Colecciones</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Interfaces</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="map.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="sorted-set.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Ordenación de Objetos</h1>
            </div>
            <div id="PageContent">
                <p>
                    Una <code>List</code> <code>l</code> puede ser ordenada como sigue.
                </p>
                <div class="codeblock">
                    <pre>
Collections.sort(l);
                    </pre>
                </div>
                <p>
                    Si la <code>List</code> consiste de elementos <code>String</code>, será ordenado en orden alfabético.
                    si consiste de elementos <code>Date</code>, será ordenado en orden cronólogico. ¿Cómo ocurre esto?
                    <code>String</code> y <code>Date</code> ambos implementan el interface
                    <code>
                        <a class="APILink" target="_blank"
                           href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">Comparable
                        </a>
                    </code>. Las implementaciones de <code>Comparable</code> suministran un <i>orden natural </i> por una clase,
                    los cuales permiten a los objetos de esa clase ser ordenados automáticamente. La 
                    <span id="table:comparable-implementations">tabla siguiente</span> resume algunas de las más importantes clases
                    de la plataforma Java que implementan <code>Comparable</code>.
                </p>
                <table class="celda">
                    <caption id="comparable-implementations"><strong>Clases que Implementan Comparable</strong></caption>
                    <tr>
                        <th id="h1" class="celda">Clase</th>
                        <th id="h2" class="celda">Orden Natural</th>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>Byte</code></td>
                        <td headers="h2" class="celda">Numérico con signo</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>Character</code></td>
                        <td headers="h2" class="celda">Numérico sin signo</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>Long</code></td>
                        <td headers="h2" class="celda">Numérico con signo</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>Integer</code></td>
                        <td headers="h2" class="celda">Numérico con signo</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>Short</code></td>
                        <td headers="h2" class="celda">Numérico con signo</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>Double</code></td>
                        <td headers="h2" class="celda">Numérico con signo</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>Float</code></td>
                        <td headers="h2" class="celda">Numérico con signo</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>BigInteger</code></td>
                        <td headers="h2" class="celda">Numérico con signo</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>BigDecimal</code></td>
                        <td headers="h2" class="celda">Numérico con signo</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>Boolean</code></td>
                        <td headers="h2" class="celda"><code>Boolean.FALSE &lt; Boolean.TRUE</code></td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>File</code></td>
                        <td headers="h2" class="celda">Lexicográfico dependiente del sistema en el nombre de ruta</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>String</code></td>
                        <td headers="h2" class="celda">Lexicográfico</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>Date</code></td>
                        <td headers="h2" class="celda">Cronológico</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>CollationKey</code></td>
                        <td headers="h2" class="celda">Lexicográfico específico de la Región</td>
                    </tr>
                </table>
                <br />
                <p>
                    Si intenta ordenar una lista, en los elementos que no implementen <code>Comparable</code>,
                    <code>Collections.sort(list)</code> lanzará una
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassCastException.html">
                        <code>ClassCastException</code>
                    </a>. De forma similar, <code>Collections.sort(list, comparator)</code> lanzará una
                    <code>ClassCastException</code> si intenta ordenar una lista cuyos elementos no pueden ser comparados con otros
                    usando el <code>comparator</code>. Los elementos que pueden ser comparados unos con otros se llaman
                    <i>comparables mutuamente</i>. Aunque los elementos de tipos diferentes pueden ser mutuamente comparables,
                    ninguna de las clases listadas aquí permite la comparación interclase.
                </p>
                <p>
                    Esto es todo lo que realmente necesita saber sobre el interfaz <code>Comparable</code> si simplemente quiere
                    ordenar listas de elementos comparables o crear colecciones ordenadas de ellas. La sección siguiente será de
                    interés para usted si quiere implementar su propio tipo <code>Comparable</code>.
                </p>
                <h2>Escribir Sus Propios Tipos Comparables</h2>
                <p>
                    El interfaz <code>Comparable</code> consiste en el siguiente método.
                </p>
                <div class="codeblock">
                    <pre>
public interface Comparable&lt;T&gt; {
    public int compareTo(T o);
}
                    </pre>
                </div>
                <p>
                    El método <code>compareTo</code> compara el objeto recibido con el objeto especificado y devuelve un entero
                    negativo, 0, o un entero positivio dependiendo de si el objeto recibido es menor que, igual a, o mayor que el
                    objeto especificado. Si el objeto especificado no puede ser comparado con el objeto recibido, el método lanza
                    una <code>ClassCastException</code>.
                </p>
                <p>
                    La
                    <a class="SourceLink" target="_blank"
                       href="examples/Name.java"
                       onclick="showCode('../../displayCode.html', 'examples/Name.java'); return false;">
                        <code>siguiente clase representa el nombre de una persona</code>
                    </a> e implementa <code>Comparable</code>.
                </p>
                <div class="codeblock">
                    <pre>
import java.util.*;

public class Name implements Comparable&lt;Name&gt; {
    private final String firstName, lastName;

    public Name(String firstName, String lastName) {
        if (firstName == null || lastName == null)
            throw new NullPointerException();
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String firstName() { return firstName; }
    public String lastName()  { return lastName;  }

    public boolean equals(Object o) {
        if (!(o instanceof Name))
            return false;
        Name n = (Name) o;
        return n.firstName.equals(firstName) &amp;&amp; n.lastName.equals(lastName);
    }

    public int hashCode() {
        return 31*firstName.hashCode() + lastName.hashCode();
    }

    public String toString() {
	return firstName + &quot; &quot; + lastName;
    }

    public int compareTo(Name n) {
        int lastCmp = lastName.compareTo(n.lastName);
        return (lastCmp != 0 ? lastCmp : firstName.compareTo(n.firstName));
    }
}
                </pre>
            </div>
                <p>
                    Para mantener el ejemplo precedente corto, la clases es de alguna forma limitada: no soporta nombres
                    intermedios, exige un primer nombre y un apellido, y no está internacionalizada de ninguna forma. No obstante,
                    ilustra los siguientes puntos importantes:
                </p>
                <ul>
                    <li>
                        Los objetos <code>Name</code> son <i>inmutables</i>. En igualdad de condiciones, los tipos inmutables son el
                        camino a seguir, especialmente para objetos que serán usados como elementos en <code>Set</code>s o como
                        claves en <code>Map</code>s. Estas colecciones se romperán si modifica sus elementos o claves mientras están
                        en la colección.
                    </li>
                    <li>
                        El constructor comprueba sus argumentos por el <code>null</code>. Esto se asegura que todos los objetos
                        <code>Name</code> están bien formados de forma que ninguno de los otros métodos lanzará nunca una
                        <code>NullPointerException</code>.
                    </li>
                    <li>
                        El método <code>hashCode</code> es redefinido. Eso es esencial para cualquier clase que redefine el método
                        <code>equals</code>. (Los objetos iguales tienen los mismos códigos hash).
                    </li>
                    <li>
                        The <code>equals</code> method returns <code>false</code> if the specified object is <code>null</code> or of an
                        inappropriate type. The <code>compareTo</code> method throws a runtime exception under these circumstances.
                        Both of these behaviors are required by the general contracts of the respective methods.
                    </li>
                    <li>
                        El método <code>toString</code> ha sido redefinido de forma que imprime el <code>Name</code> en una forma
                        leíble por los humanos. Esto es siempre una buena idea, especialmente para objetos que van a colocarse en 
                        colecciones. Los varios tipos de métodos <code>toString</code> de los tipos colección dependen de los 
                        métodos <code>toString</code> de sus elmentos, claves y valores.
                    </li>
                </ul>
                <p>
                    Ya que esta sección es sobre ordenación de elementos, hablemos un poco más sobre el método 
                    <code>compareTo</code> de <code>Name</code>. Implementa el algoritmo estándar de ordenación de nombres, donde
                    los apellidos toman precedencia sobre los nombres. Esto es exactamente lo que usted quiere en un orden natural.
                    ¡Sería muy confuso si el orden natural fuera innatural!.
                </p>
                <p>
                    Eche un vistazo a cómo <code>compareTo</code> se implementa, porque es bastante típico. Primero, compara la
                    parte más significante del objeto (en este caso, el apellido). A menudo, puedes usar el orden natural del tipo
                    de la parte. En este caso, la parte es una <code>String</code> y el orden natural (lexicográfico) es
                    exactamente lo que buscamos. Si la comparación resulta en algo diferente de cero, lo que representa la igualdad,
                    ya terminó: simplemente devuelva el resultado. Si las partes más significantes son iguales, va a comparar las 
                    siguientes partes más significativas. En este caso, sólo hay dos partes &mdash; nombre y apellido. Si hubiera
                    más partes, procedería de la manera obvia, comparando partes hasta que encuentre dos que no serán iguales o
                    si estaba comparando las partes menos significativas, en cuyo punto obtendría el resultado de la comparación.
                </p>
                <p>
                    Sólo para mostrar que todo esto funciona, aquí tiene
                    <a class="SourceLink" target="_blank"
                       href="examples/NameSort.java"
                       onclick="showCode('../../displayCode.html', 'examples/NameSort.java'); return false;">
                        <code>un programa que construye una lista de nombres y los ordena</code>
                    </a>.
                </p>
                <div class="codeblock">
                    <pre>
import java.util.*;

public class NameSort {
    public static void main(String[] args) {
        Name nameArray[] = {
            new Name(&quot;John&quot;, &quot;Smith&quot;),
            new Name(&quot;Karl&quot;, &quot;Ng&quot;),
            new Name(&quot;Jeff&quot;, &quot;Smith&quot;),
            new Name(&quot;Tom&quot;, &quot;Rich&quot;)
        };

        List&lt;Name&gt; names = Arrays.asList(nameArray);
        Collections.sort(names);
        System.out.println(names);
    }
}
                    </pre>
                </div>
                <p>
                    Si ejecuta este programa, aquí está lo que imprime.
                </p>
                <div class="codeblock">
                    <pre>
[Karl Ng, Tom Rich, Jeff Smith, John Smith]
                    </pre>
                </div>
                <p>
                    Hay cuatro restricciones en el comportamiento del método <code>compareTo</code>, en los que que no vamos a
                    entrar ahora  porque son bastante técnicos y aburridos y es mejor dejarlos en la documentación de la IPA. Es
                    realmente importante que todas las clases que implementan <code>Comparable</code> obedezcan estas restricciones,
                    así que lea la documentación para <code>Comparable</code> si está escribiendo una clase que lo implementa.
                    Intentar ordenar una lista de objetso que violan las restricciones tiene un comportamiento no definido. Hablando
                    técnicamente, estas restricciones se aseguran de que el orden natural es un <i>orden total </i> sobre los
                    objetos de una clase que los implementa; esto es necesario para asegurarse que el ordenado está bien definido.
                </p>
                <h2>Comparadores</h2>
                <p>
                    ¿Qué sucede si desea clasificar algunos objetos en un orden diferente a su orden natural? ¿O si quiere ordenar
                    algunos objetos que no implementan <code>Comparable</code>? Para hacer cualquiera de estos dos cosas, necesitará
                    suministrar un
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html">
                        <code>Comparator</code>
                    </a> &mdash; un objeto que encapsula un orden. Como el interfaz <code>Comparable</code>, El interfaz
                    <code>Comparator</code> consiste de un único método.
                </p>
                <div class="codeblock">
                    <pre>
public interface Comparator&lt;T&gt; {
    int compare(T o1, T o2);
}
                    </pre>
                </div>
                <p>
                    El método <code>compare</code> compara sus dos argumentos, devolviendo un entero negativo,0, o un entero 
                    positivo dependiendo de si el primer argumento es menor que, igual que, o mayor que el segundo. Si uno de los
                    argumentos tiene un tipo inapropiado para el <code>Comparator</code>, el método <code>compare</code> lanza una 
                    <code>ClassCastException</code>.
                </p>
                <p>
                    Mucho de lo que dijimos sobre <code>Comparable</code> se aplica a <code>Comparator</code> también. Escribir un
                    método <code>compare</code> es casi idéntico a escribur un método <code>compareTo</code>, excepto que el primero
                    obtiene ambos objetos pasados como argumentos.El método <code>compare</code> tiene que obedecer las mismas
                    cuatro restricciones técnics que el método <code>compareTo</code> de <code>Comparable</code> por la misma 
                    razón &mdash; un <code>Comparator</code> debe inducir un orden total en los objetos que compara.
                </p>
                <p>
                    Suponga que tiene una clase llamada <code>Employee</code>, como sigue.
                </p>
                <div class="codeblock">
                    <pre>
public class Employee implements Comparable&lt;Employee&gt; {
    public Name name()     { ... }
    public int number()    { ... }
    public Date hireDate() { ... }
       ...
}
                    </pre>
                </div>
                <p>
                    Asumamos que el orden natural de las instancias de <code>Employee</code> es el orden de <code>Name</code>
                    (como se definió en el ejemplo previo) sobre el nombre del empleado. Desafortunadamente, el jefe ha solicitado
                    una lista de empleados en orden de antiguedad. Esto significa que tenemos que hacer un poco de trabajo, pero
                    no mucho. El programa siguiente producirá la lista requerida.
                </p>
                <div class="codeblock">
                    <pre>
import java.util.*;
public class EmpSort {
    static final Comparator&lt;Employee&gt; SENIORITY_ORDER = 
                                        new Comparator&lt;Employee&gt;() {
            public int compare(Employee e1, Employee e2) {
                return e2.hireDate().compareTo(e1.hireDate());
            }
    };

    // Employee database
    static final Collection&lt;Employee&gt; employees = ... ;

    public static void main(String[] args) {
        List&lt;Employee&gt; e = new ArrayList&lt;Employee&gt;(employees);
        Collections.sort(e, SENIORITY_ORDER);
        System.out.println(e);
    }
}
                    </pre>
                </div>
                <p>
                    El <code>Comparator</code> en el programa es razonablemente sencillo. Se basa en el orden natura de
                    <code>Date</code> aplicado a los valores devueltos por el método accesor <code>hireDate</code>. Dese cuenta que
                    el <code>Comparator</code> pasa la fecha de contrato de su segundo argumento a su primera en lugar de viceversa.
                    La razón es que el empleado que fue contratado más recientemente es el menos antiguo; ordenar en el orden de la
                    fecha de contratación pondría la lista en orden inverso de antiguedad. Otra técnica que las personas a veces
                    usan para lograr este efecto es mantener el orden de los argumentos pero negar el resultado de la comparación.
                </p>
                <div class="codeblock">
                    <pre>
// ¡¡No haga esto!!
return -r1.hireDate().compareTo(r2.hireDate());
                    </pre>
                </div>
                <p>
                    Siempre debe usar la técnica anterior a favor de la última porque no se garantiza que la última funcione. La 
                    razón para esto es que el método <code>compareTo</code> puede devolver cualquier <code>int</code> negativo si
                    su argumento es menor que el objeto en el cual fue invocado. Hay un <code>int</code> negativo que permanece
                    negativo cuando se niega, por extraño que parezca.
                </p>
                <div class="codeblock">
                    <pre>
-Integer.MIN_VALUE == Integer.MIN_VALUE
                    </pre>
                </div>
                <p>
                    El <code>Comparator</code> en el programa precedene funciona bien para ordenar una <code>List</code>, pero
                    tiene una deficiencia: no puede ser usado para ordenar una colección ordenada, tal como un
                    <code>TreeSet</code>, porque genera una ordenación que es <i>no compatible con</i> la igualdad. Esto significa
                    que este <code>Comparator</code> equipara objetos que el método <code>equals</code> no. En particular, dos
                    empleados que fueron contratados en la misma fecha se compararán como iguales. Cuando está ordenando una 
                    <code>List</code>, esto no importa; pero cuando está usando el <code>Comparator</code> para ordenar una
                    colección ordenada, es fatal. Si usa este <code>Comparator</code> para insertar múltiples empleados contratados
                    en la misma fecha en un <code>TreeSet</code>, sólo el primero será añadido al set; el segundo será visto como
                    un elemento duplicado y será ignorado.
                </p>
                <p>
                    Para solucionar este problema, simplemente modifique el <code>Comparator</code> de forma que produzca una
                    ordenación que <i>sea compatible con</i> <code>equals</code>. En otras palabras, modifíquelo de forma que sólo
                    los elementeos vistos como iguales cuando use <code>compare</code> sean aquellos que son también vistos como
                    iguales cuando se comparan usando <code>equals</code>. La forma de hacer esto es realizar una comparación en
                    dos partes (como para <code>Name</code>), donde la primera parte es la que nos interesa &mdash; en este caso,
                    la fecha de contrato &mdash; y la segunda parte es un atributo que unicamente identifica el objeto. Aquí el 
                    número de empleado es el atributo obvio. Este es el <code>Comparator</code> que resulta.
                </p>
                <div class="codeblock">
                    <pre>
static final Comparator&lt;Employee&gt; SENIORITY_ORDER = 
                                        new Comparator&lt;Employee&gt;() {
    public int compare(Employee e1, Employee e2) {
        int dateCmp = e2.hireDate().compareTo(e1.hireDate());
        if (dateCmp != 0)
            return dateCmp;

        return (e1.number() &lt; e2.number() ? -1 :
               (e1.number() == e2.number() ? 0 : 1));
    }
};
                    </pre>
                </div>
                <p>
                    Una última nota: Es posible que tenga la tentación de reemplazar la sentencia <code>return</code> final en el 
                    <code>Comparator</code> con el más simple:
                </p>
                <div class="codeblock">
                    <pre>
return e1.number() - e2.number();
                    </pre>
                </div>
                <p>
                    !No haga esto a menos que esté <i>absolutemente seguro</i> de que nadie tendrá un número de empleado negativo!
                    Este truco no funciona en general porque el tipo de entero con signo no es lo bastante grande para representar
                    la diferencia de dos enteros con sigo arbitrarios. Si <code>i</code> es un entero positivo grande y
                    <code>j</code> es un entero negativo grande, <code>i - j</code> se desbordará y devolverá un entero negativo.
                    El <code>comparator</code> resultante viola una de las cuatro restricciones técnicas de las que estuvimos
                    hablando (transitividad) y produce errores sutiles y horribles. Esto no es sólo una preocupación puramente
                    teórica; la gente se quema por eso.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="map.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="sorted-set.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> El Interfaz Map<br />
            <b>Página siguiente:</b> El Interfaz SortedSet
        </div>
    </body>
</html> 
