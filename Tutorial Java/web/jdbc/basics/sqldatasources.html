<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Conectando con Objetos DataSource (Los Tutoriales de Java&trade; &gt; Acceso a Bases de Datos JDBC(TM) &gt; 
            Lo Básico de JDBC)
        </title>
        <meta name="description" content="Este tutorial de Java JDBC describe cómo usar la IPA JDBC para crear, insertar, 
              actualizar y consultar tablas. También aprenderá cómo usar declaraciones simples y preparadas, procedimientos 
              almacenados y realizar transacciones" />
        <meta name="keywords" content="java programming, learn java, java sample code, jdbc, prepared statement, result set" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Lo Básico de JDBC</a></div>
                <div class="linkAHEAD"><a href="gettingstarted.html">Empezando</a></div>
                <div class="linkAHEAD"><a href="processingsqlstatements.html">Procesando Sentencias SQL con JDBC</a></div>
                <div class="linkAHEAD"><a href="connecting.html">Estableciendo una Conexión</a></div>
                <div class="nolinkAHEAD">Conectando con Objetos DataSource</div>
                <div class="linkAHEAD"><a href="sqlexception.html">Manejando SQLExceptions</a></div>
                <div class="linkAHEAD"><a href="tables.html">Configurando Tablas</a></div>
                <div class="linkAHEAD"><a href="retrieving.html">Recuperando y Modificando Valores de los Result Sets</a></div>
                <div class="linkAHEAD"><a href="prepared.html">Usando Prepared Statements</a></div>
                <div class="linkAHEAD"><a href="transactions.html">Usando Transacciones</a></div>
                <div class="linkAHEAD"><a href="rowset.html">Usando Objetos RowSet</a></div>
                <div class="linkAHEAD"><a href="jdbcrowset.html">Utilizando Objetos JdbcRowSet</a></div>
                <div class="linkAHEAD"><a href="cachedrowset.html">Utilizando CachedRowSetObjects</a></div>
                <div class="linkAHEAD"><a href="joinrowset.html">Utilizando Objetos JoinRowSet</a></div>
                <div class="linkAHEAD"><a href="filteredrowset.html">Utilizando Objetos FilteredRowSet</a></div>
                <div class="linkAHEAD"><a href="webrowset.html">Utilizando Objetos WebRowSet</a></div>
                <div class="linkAHEAD"><a href="sqltypes.html">Usando Tipos de Datos Avanzados</a></div>
                <div class="linkAHEAD"><a href="blob.html">Utilizando Objetos Grandes</a></div>
                <div class="linkAHEAD"><a href="sqlxml.html">Utilizando Objetos SQLXML</a></div>
                <div class="linkAHEAD"><a href="array.html">Utilizando Objetos Array</a></div>
                <div class="linkAHEAD"><a href="distinct.html">Usando el Tipo de Datos DISTINCT</a></div>
                <div class="linkAHEAD"><a href="sqlstructured.html">Utilizando Objetos Estructurados</a></div>
                <div class="linkAHEAD"><a href="sqlcustommapping.html">Usando Mapeados de Tipos Personalizados</a></div>
                <div class="linkAHEAD"><a href="sqldatalink.html">Utilizando Objetos Datalink</a></div>
                <div class="linkAHEAD"><a href="sqlrowid.html">Utilizando Objetos RowId</a></div>
                <div class="linkAHEAD"><a href="storedprocedures.html">Usando Procedimientos Almacenados</a></div>
                <div class="linkAHEAD"><a href="jdbcswing.html">Usando JDBC con una IPA de IGU</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Acceso a Bases de Datos JDBC(TM)<br />
                <b>Lección:</b> Lo Básico de JDBC
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Acceso a Bases de Datos JDBC(TM)</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Lo Básico de JDBC</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="connecting.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="sqlexception.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Conectando con Objetos DataSource</h1>
            </div>
            <div id="PageContent">
                <p>
                    Esta sección cubre los objetos <code>DataSource</code>, que son los medios preferidos para obtener una conexión 
                    a una fuente de datos. Además de sus otras ventajas, las cuales serán explicadas más tarde, los objetos 
                    <code>DataSource</code> pueden proporcionar agrupación de conexiones y transacciones distribuidas. Esta 
                    funcionalidad es esencial para la computación con bases de datos empresariales. En particular, es parte 
                    integral de la tecnología Enterprise JavaBeans (EJB).
                </p>
                <p>
                    Esta sección le muestra cómo obtener una conexión usando la interfaz <code>DataSource</code> y cómo usar las 
                    transacciones distribuidas y la agrupación de conexiones. Ambos implican muy pocos cambios de código en su 
                    aplicación JDBC.
                </p>
                <p>
                    El trabajo realizado para desplegar las clases que hacen estas operaciones posibles, las cuales hace 
                    habitualmente un administrador de sistemas con una herramienta (tal como Apache Tomcat o el Servidor Weblogic 
                    de Oracle), varía con el tipo de objeto <code>DataSource</code> que está siendo desplegado. Cómo resultado, la 
                    mayor parte de esta sección está dedicada a mostrar cómo un administrador de sistemas configura el entorno para 
                    que los programadores puedan usar un objeto <code>DataSource</code> para obtener conexiones.
                </p>
                <p>
                    Los siguientes temas están cubiertos:
                </p>
                <ul>
                    <li>
                        <a href="#datasource_connection">Usar Objetos DataSource para Obtener Conexiones</a>
                    </li>
                    <li>
                        <a href="#deploy_datasource">Desplegar Objetos DataSource Básicos</a>
                    </li>
                    <li>
                        <a href="#datasource_implementation">Desplegar Otras Implementaciones de DataSource</a>
                    </li>
                    <li>
                        <a href="#pooled_connection">Obtener y Usar Agrupaciones de Conexiones</a>
                    </li>
                    <li>
                        <a href="#deployment_distributed_transactions">Desplegar Transacciones Distribuidas</a>
                    </li>
                    <li>
                        <a href="#using_connections_distributed_transactions">Usar Conexiones para Transacciones Distribuidas</a>
                    </li>
                </ul>
                <h2>
                    <a id="datasource_connection">Usar Objetos DataSource para Obtener Conexiones</a>
                </h2>
                <p>
                    En <a href="connecting.html">Estableciendo una Conexión</a>, aprendió cómo obtener una conexión usando la 
                    clase <code>DriverManager</code>. Esta sección le muestra cómo usar un objeto <code>DataSource</code> para 
                    obtener una conexión a su fuente de datos, que es la forma preferida.
                </p>
                <p>
                    Los objetos instanciados por las clases que implementan el <code>DataSource</code> representan a un DBMS 
                    particular o alguna otra fuente de datos, tal como un fichero. Un objeto <code>DataSource</code> representa un 
                    DBMS particular o alguna otra fuente de datos, tal como un fichero. Si una compañía usa más de una fuente de 
                    datos, desplegará un objeto <code>DataSource</code> separado para cada una de ellas. La interfaz 
                    <code>DataSource</code> es implementada por el proveedor del controlador. Puede ser implementada de tres formas 
                    diferentes:
                </p>
                <ul>
                    <li>
                        Un implemetación básica del <code>DataSource</code> produce objetos <code>Connection</code> estándar que 
                        no están agrupados o no se usan en transacciones distribuidas.
                    </li>
                    <li>
                        Una implementación de <code>DataSource</code> que soporta la agrupación de conexiones produce objetos 
                        <code>Connection</code> que participan en una agrupación de conexiones, esto es, conexiones que pueden ser 
                        recicladas.
                    </li>
                    <li>
                        Una implementación de <code>DataSource</code> que soporta las transacciones distribuidas produce objetos 
                        <code>Connection</code> que pueden usarse en transacciones distribuídas, esto es, una transacción que 
                        accede a dos o más servidores DBMS.
                    </li>
                </ul>
                <p>
                    Un controlador JDBC debe incluir al menos una implementación básica de <code>DataSource</code>. Por ejemplo, el 
                    controlador JDBC de Java DB incluye la implementación <code>org.apache.derby.jdbc.ClientDataSource</code> y 
                    para MySQL, <code>com.mysql.jdbc.jdbc2.optional.MysqlDataSource</code>. Si su cliente ejecuta el perfil 2 
                    compacto de Java 8 entonces el controlador JDBC de Java DB es 
                    <code>org.apache.derby.jdbc.BasicClientDataSource40</code>. El ejemplo para este tutorial requiere el perfil 3 
                    compacto o mayor.
                </p>
                <p>
                    Una clase <code>DataSource</code> que soporta transacciones distribuidas típicamente también implementa soporte 
                    para la agrupación de conexiones. Por ejemplo, una clase  <code>DataSource</code> proporcionada por un 
                    fabricante de EJB casi siempre admite tanto agrupación de conexiones como transacciones distribuídas.
                </p>
                <p>
                    Suponga que el propietario de la próspera cadena de tiendas The Coffe Break, de los ejemplos previos, ha 
                    decidido expandirse aún más vendiendo café a través de Internet. Con la gran cantidad de negocio en línea 
                    esperada, el propietario definitivamente necesitará la agrupación de conexiones. Abrir y cerrar conexiones 
                    implica una gran cantidad de sobrecarga, y el propietario anticipa que este sistema de peticiones en línea 
                    necesitará un número considerable de consultas y actualizaciones. Con la agrupación de conexiones, un grupo 
                    de conexiones puede ser usado una y otra vez de nuevo, evitando el gasto de crear una nueva conexión para cada 
                    acceso a la base de datos. Además, el propietario ahora tiene una segunda DBMS que contiene datos para la 
                    empresa tostadora de café recién adquirida. Esto significa que el propietario querrá ser capaz de escribir 
                    transacciones distribuidas que usen tanto el viejo servidor DBMS como el nuevo.
                </p>
                <p>
                    El propietario de la cadena ha reconfigurado el sistema de computadoras para servir la nueva, y más grande 
                    base de clientes. El propietario ha adquirido el controlador JDBC más reciente y un servidor de aplicaciones 
                    EJB que trabaja con éste para ser capaz de usar transacciones distribuidas y obtener el rendimiento 
                    incrementado que viene con la agrupación de conexión. Hay disponibles muchos controladores JDBC que son 
                    compatibles con el servidor EJB recientemente comprado. El propietario ahora tiene una arquitectura de tres 
                    niveles, con un nuevo servidor de aplicaciones EJB y un controlador JDBC en el nivel medio y los dos 
                    servidores DBMS como el tercer nivel. Las computadoras clientes que hacen las peticiones son el primer nivel.
                </p>
                <h2>
                    <a id="deploy_datasource">Desplegar Objetos DataSource Básicos</a>
                </h2>
                <p>
                    El administrador de sistema necesita desplegar objetos <code>DataSource</code> de forma que el equipo de 
                    programación de The Coffee Break pueda empezar a usarlos. Desplegar un objeto <code>DataSource</code> consiste 
                    en tres tareas:
                </p>
                <ol>
                    <li>
                        Crear una instancia de la clase <code>DataSource</code>
                    </li>
                    <li>
                        Establecer sus propiedades
                    </li>
                    <li>
                        Regístrarla con el servicio de nombrado que usa la IPA de la Interfaz de Nombrado y Directorio de Java 
                        (JNDI)
                    </li>
                </ol>
                <p>
                    Primero, considere el caso más básico, el cual usa una implementación básica de la interfaz 
                    <code>DataSource</code>, esto es, una que no soporta la agrupación de conexiones o transacciones distribuidas. 
                    En este caso hay sólo un objeto <code>DataSource</code> que necesita ser desplegado. Una implementación básica 
                    de <code>DataSource</code> produce la misma clase de conexiones que la clase <code>DriverManager</code> 
                    produce.
                </p>
                <h3>
                    Crear una Instancia de la Clase DataSource y Establecer sus Propiedades
                </h3>
                <p>
                    Suponga una compañía que quiere sólo una implementación básica de <code>DataSource</code> ha comprado un 
                    controlador del vendedor de JDBC DB access, Inc. Este controlador incluye la clase 
                    <code>com.dbaccess.BasicDataSource</code> que implementa la interfaz <code>DataSource</code>. El trozo de 
                    código siguiente crea una instancia de la clase <code>BasicDataSource</code> y establece sus propiedades.
                    Después de que la instancia <code>BasicDataSource</code> se despliega, un programador puede llamar al método  
                    <code>DataSource.getConnection</code> para obtener una conexión a la base de datos de la compañía, 
                    <code>CUSTOMER_ACCOUNTS</code>. Primero, el administrador de sistemas crea el objeto 
                    <code><em>ds</em></code> del <code>BasicDataSource</code> usando el constructor por defecto. El administrador 
                    de sistemas después establece tres propiedades. Tenga en cuenta que el siguiente código normalmente lo ejecuta 
                    una herramienta de implementación:
                </p>
                <div class="codeblock">
                    <pre>
com.dbaccess.BasicDataSource ds = new com.dbaccess.BasicDataSource();
ds.setServerName(&quot;grinder&quot;);
ds.setDatabaseName(&quot;CUSTOMER_ACCOUNTS&quot;);
ds.setDescription("Customer accounts database for billing");
                    </pre>
                </div>
                <p>
                    La variable <code><em>ds</em></code> ahora representa la base de datos <code>CUSTOMER_ACCOUNTS</code> instalada 
                    en el servidor. Cualquier conexión producida por el objeto <code><em>ds</em></code> de tipo 
                    <code>BasicDataSource</code> será una conexión a la base de datos <code>CUSTOMER_ACCOUNTS</code>.
                </p>
                <h3>
                    Registrar el Objeto DataSource con el Servicio de Nombrado Que Usa la IPA de JNDI
                </h3>
                <p>
                    Con el conjunto de propiedades, el administrador de sistemas puede registrar el objeto 
                    <code>BasicDataSource</code> con un servicio de nombrado JNDI (Interfaz de Nombrado y Directorio de Java). El 
                    servicio de nombrado particular que se usa está determinado habitualmente por una propiedad del sistema, la 
                    cual no se muestra aquí. El siguiente trozo de código registra el objeto <code>BasicDataSource</code> y lo 
                    vincula con el nombre lógico <code>jdbc/billingDB</code>:
                </p>
                <div class="codeblock">
                    <pre>
Context ctx = new InitialContext();
ctx.bind(&quot;jdbc/billingDB&quot;, ds);
                    </pre>
                </div>
                <p>
                    Este código usa la IPA de JNDI. La primera línea crea un objeto <code>InitialContext</code>, el cual sirve como 
                    el punto de inicio para un nombre, de forma similar al directorio raíz en un sistema de ficheros. La segunda 
                    línea asocia, o vincula, el objeto <code><em>ds</em></code> de tipo <code>BasicDataSource</code> al nombre 
                    lógico <code>jdbc/billingDB</code>. En el siguiente trozo de código, le da al servicio de nombrado este nombre 
                    lógico, y este devuelve el objeto <code>BasicDataSource</code>. El nombre lógico puede ser cualquier cadena. En 
                    este caso, la compañía decidió usar el nombre <code>billingDB</code> como el nombre lógico para la base de 
                    datos <code>CUSTOMER_ACCOUNTS</code>.
                </p>
                <p>
                    En el ejemplo anterior, <code>jdbc</code> es un subcontexto bajo el contexto inicial, al igual que un 
                    directorio bajo el directorio raíz es un subdirectorio. El nombre <code>jdbc/billingDB</code> es como un nombre 
                    de ruta, donde el último elemento en la ruta es análogo a un nombre de fichero. En este caso, 
                    <code>billingDB</code> es el nombre lógico que se da al objeto <code><em>ds</em></code> de tipo 
                    <code>BasicDataSource</code>. El subcontexto <code>jdbc</code> se reserva para los nombres lógicos que son 
                    vinculados a objetos <code>DataSource</code>, así <code>jdbc</code> será siempre la primera parte de un nombre 
                    lógico para una fuente de datos.
                </p>
                <h3>
                    Usar Objetos Datasource Desplegados
                </h3>
                <p>
                    Después de que una implementación básica de <code>DataSource</code> sea desplegada por un administrador de 
                    sistemas, este está listo para que un programador lo use. Esto significa que un programador puede dar el nombre 
                    de la fuente de datos lógica que estaba vinculada a una instancia de una clase <code>DataSource</code>, y el 
                    servicio de nombrado JNDI devolverá una instancia de esa clase <code>DataSource</code>. El método 
                    <code>getConnection</code> puede después ser llamado en ese objeto <code>DataSource</code> para obtener una 
                    conexión a la fuente de datos que representa. Por ejemplo, un programador podría escribir las dos líneas de 
                    codigo siguientes para obtener un objeto <code>DataSource</code> que produce una conexión a la base de datos 
                    <code>CUSTOMER_ACCOUNTS</code>.
                </p>
                <div class="codeblock">
                    <pre>
Context ctx = new InitialContext();
DataSource ds = (DataSource)ctx.lookup("jdbc/billingDB");
                    </pre>
                </div>
                <p>
                    La primera línea de código obtiene un contexto inicial como el punto inicial para recuperar un objeto 
                    <code>DataSource</code>. Cuando proporciona el nombre lógico <code>jdbc/billingDB</code> al método 
                    <code>lookup</code>, el método devuelve el objeto <code>DataSource</code> que el administrador de sistemas 
                    vinculó a <code>jdbc/billingDB</code> en el tiempo de despliegue. Ya que el valor de retorno del método 
                    <code>lookup</code> es un <code>Object</code> de Java, tenemos que moldearlo a su tipo <code>DataSource</code> 
                    más específico antes de asignarlo a la variable <code><em>ds</em></code>.
                </p>
                <p>
                    La variable <code><em>ds</em></code> es una instancia de la clase <code>com.dbaccess.BasicDataSource</code> que 
                    implementa la interfaz <code>DataSource</code>. Llamar al método <code><em>ds</em>.getConnection</code> 
                    produce una conexión a la base de datos <code>CUSTOMER_ACCOUNTS</code>.
                </p>
                <div class="codeblock">
                    <pre>
Connection con = ds.getConnection("fernanda","brewed");
                    </pre>
                </div>
                <p>
                    El método <code>getConnection</code> requiere sólo el nombre de usuario y contraseña porque la variable 
                    <code><em>ds</em></code> tiene el resto de la información necesaria para establecer una conexión con la 
                    base de datos <code>CUSTOMER_ACCOUNTS</code>, tales como el nombre de la base de datos y la ubicación, en sus 
                    propiedades.
                </p>
                <h3>
                    Ventajas de los Objetos DataSource
                </h3>
                <p>
                    Debidos a sus propiedades, un objeto <code>DataSource</code> es una alternativa mejor que la clase 
                    <code>DriverManager</code> para obtener una conexión. Los programadores ya no tienen que codificar el nombre 
                    del controlador o la URL JDBC en sus aplicaciones, lo que las hace más portables. También, las propiedades de 
                    <code>DataSource</code> hacen que mantener el código sea mucho más simple. Si hay un cambio, el administrador 
                    de sistemas puede actualizar las propiedades de la fuente de datos y no preocuparse sobre cambiar cada 
                    aplicación que hace una conexión a la fuente de datos. Por ejemplo, si la fuente de datos se movió a un 
                    servidor diferente, todo lo que el administrador de sistemas hará es establecer la propiedad 
                    <code>serverName</code> al nuevo nombre del servidor.
                </p>
                <p>
                    Aparte de la portabilidad y la facilidad de mantenimiento, usar un objeto <code>DataSource</code> para obtener 
                    conexiones puede ofrecer otras ventajas. Cuando la interfaz <code>DataSource</code> se implementa para trabajar 
                    con una implementación de <code>ConnectionPoolDataSource</code>, todas las conexiones producidas por las 
                    instancias de esa clase <code>DataSource</code> serán automáticamente conexiones agrupadas. De manera similar, 
                    cuando la implementación de <code>DataSource</code> se implementa para trabajar con una clase 
                    <code>XADataSource</code>, todas las conexiones que produce serán automáticamente conexiones que pueden usarse 
                    en transacciones distribuidas. La sección siguiente muestra cómo desplegar estos tipos de implementaciones de 
                    <code>DataSource</code>.
                </p>
                <h2>
                    <a id="datasource_implementation">Desplegar Otras Implementaciones de DataSource</a>
                </h2>
                <p>
                    Un administrador de sistemas u otra persona que trabaje en esa capacidad puede desplegar un objeto 
                    <code>DataSource</code> de forma que las conexiones que produzca sean conexiones agrupadas. Para hacer esto, 
                    el o ella primero despliega un objeto <code>ConnectionPoolDataSource</code> y después despliega un objeto 
                    <code>DataSource</code> implementado para trabajar con él. Las propiedades del objeto 
                    <code>ConnectionPoolDataSource</code> se establecen para que represente la fuente de datos a la que se 
                    producirán las conexiones. Después de que el objeto <code>ConnectionPoolDataSource</code> ha sido registrado 
                    con el servicio de nombres JNDI, el objeto <code>DataSource</code> se despliega. Generalmente sólo dos 
                    propiedades deben ser establecidas para el objeto <code>DataSource</code>: <code>description</code> y 
                    <code>dataSourceName</code>. El valor dado a la propiedad <code>dataSourceName</code> es el nombre lógico 
                    que identifica al objeto <code>ConnectionPoolDataSource</code> previamente desplegado, el cual es el objeto 
                    que contiene las propiedades necesitadas para hacer la conexión.
                </p>
                <p>
                    Con los objetos <code>ConnectionPoolDataSource</code> y <code>DataSource</code> desplegados, puede llamar al 
                    método <code>DataSource.getConnection</code> en el objeto <code>DataSource</code> y obtiene una conexión 
                    agrupada. Esta conexión será a la fuente de datos especificada en las propiedades del objeto 
                    <code>ConnectionPoolDataSource</code>.
                </p>
                <p>
                    El ejemplo siguiente describe cómo un administrador de sistema para The Coffe Break desplegaría un objeto 
                    <code>DataSource</code> implementado para proporcionar conexiones agrupadas. El administrador de sistema 
                    usaría típicamente una herramienta de despliegue, de forma que los fragmentos de código mostrados en esta 
                    sección son el código que una herramienta de despliegue ejecutaría.
                </p>
                <p>
                    Para obtener mejor rendimiento, la compañía The Coffee Break ha comprado un controlador JDBC de DB Access, Inc. 
                    que incluye la clase <code>com.dbaccess.ConnectionPoolDS</code>, la cual implementa la interfaz 
                    <code>ConnectionPoolDataSource</code>. El administrador de sistemas crea una instancia de esta clase, establece 
                    sus propiedades, y lo registra con el servicio de nombrado de JNDI. The Coffee Break ha comprado su clase 
                    <code>DataSource</code>, <code>com.applogic.PooledDataSource</code>, de su proveedor del servidor EJB, 
                    Application Logic, Inc. La clase <code>com.applogic.PooledDataSource</code> implementa la agrupación de 
                    conexiones usando el soporte subyacente proporcionado por la clase <code>com.dbaccess.ConnectionPoolDS</code> 
                    de tipo <code>ConnectionPoolDataSource</code>.
                </p>
                <p>
                    El objeto <code>ConnectionPoolDataSource</code> debe ser desplegado primero. El código siguiente crea una 
                    instancia de <code>com.dbaccess.ConnectionPoolDS</code> y establece sus propiedades:
                </p>
                <div class="codeblock">
                    <pre>
com.dbaccess.ConnectionPoolDS cpds = new com.dbaccess.ConnectionPoolDS();
cpds.setServerName(&quot;creamer&quot;);
cpds.setDatabaseName(&quot;COFFEEBREAK&quot;);
cpds.setPortNumber(9040);
cpds.setDescription(&quot;Connection pooling for " + "COFFEEBREAK DBMS&quot;);
                    </pre>
                </div>
                <p>
                    Después de que el objeto <code>ConnectionPoolDataSource</code> ha sido desplegado, el administrador de sistema 
                    despliega el objeto <code>DataSource</code>. El código siguiente registra el objeto 
                    <code><em>cpds</em></code> de tipo <code>com.dbaccess.ConnectionPoolDS</code> con un servicio de nombres 
                    JNDI. Dese cuenta de que el nombre lógico que está siendo asociado con la variable <code><em>cpds</em></code> 
                    tiene el subcontexto <code>pool</code> agregado bajo el subcontexto <code>jdbc</code>, lo cual es similar a 
                    agregar un subdirectorio a otro subdirectorio en un sistema de ficheros jerárquico. El nombre lógico de 
                    cualquier instancia de la clase <code>com.dbaccess.ConnectionPoolDS</code> empezará siempre con 
                    <code>jdbc/pool</code>. Oracle recomienda poner todos los objetos <code>ConnectionPoolDataSource</code> bajo 
                    el subcontexto <code>jdbc/pool</code>:
                </p>
                <div class="codeblock">
                    <pre>
Context ctx = new InitialContext();
ctx.bind(&quot;jdbc/pool/fastCoffeeDB&quot;, cpds);
                    </pre>
                </div>
                <p>
                    A continuación, la clase <code>DataSource</code> que se implementa para interactuar con la variable 
                    <code><em>cpds</em></code> y otras instancias de la clase <code>com.dbaccess.ConnectionPoolDS</code> es 
                    desplegada. El código siguiente crea una instancia de esta clase y establece sus propiedades. Dese cuenta de 
                    que sólo se establecen dos propiedades para esta instancia de <code>com.applogic.PooledDataSource</code>. La 
                    propiedad <code>description</code> es establecida porque siempre se requiere. La otra propiedad que se 
                    establece, <code>dataSourceName</code>, da el nombre lógico JNDI para <code><em>cpds</em></code>, el cual es 
                    una instancia de la clase <code>com.dbaccess.ConnectionPoolDS</code>. En otras palabras, 
                    <code><em>cpds</em></code> representa el objeto <code>ConnectionPoolDataSource</code> que implementará la 
                    agrupación de conexiones para el objeto <code>DataSource</code>.
                </p>
                <p>
                    El código siguiente, el cual probablemente sería ejecutado por una herramienta de despliegue, crea un objeto 
                    <code>PooledDataSource</code>, establece sus propiedades, y lo vincula al nombre lógico 
                    <code>jdbc/fastCoffeeDB</code>:
                </p>
                <div class="codeblock">
                    <pre>
com.applogic.PooledDataSource ds = new com.applogic.PooledDataSource();
ds.setDescription("produces pooled connections to COFFEEBREAK");
ds.setDataSourceName(&quot;jdbc/pool/fastCoffeeDB&quot;);
Context ctx = new InitialContext();
ctx.bind("jdbc/fastCoffeeDB", ds);
                    </pre>
                </div>
                <p>
                    En este punto, se implementa un objeto <code>DataSource</code> desde el cual una aplicación puede obtener 
                    conexiones agrupadas a la base de datos <code>COFFEEBREAK</code>.
                </p>
                <h2>
                    <a id="pooled_connection">Obtener y Usar Agrupaciones de Conexiones</a>
                </h2>
                <p>
                    Un <em>grupo de conexiones</em> es una caché de objetos de conexión a bases de datos. Los objetos representan 
                    conexiones físicas a una base de datos que pueden usarse por una aplicación para conectar a esa base de datos. 
                    En tiempo de ejecución, la aplicación pide una conexión del grupo. Si el grupo contiene una conexión que puede 
                    satisfacer la petición, devuelve la conexión a la aplicación. Si no se encuentran conexiones, se crea una nueva 
                    conexión y se devuelve a la aplicación. La aplicación usa la conexión para realizar algún trabajo en la base de 
                    datos y entonces devuelve el objeto de vuelta al grupo. La conexión está entonces disponible para la siguiente 
                    petición de conexión.
                </p>
                <p>
                    Los grupos de conexión promueven el reuso de los objetos de conexión y reduce el número de veces que se crean 
                    los objetos de conexión. Las agrupaciones de conexión mejoran significativamente el rendimiento para 
                    aplicaciones intensivas con la base de datos porque la creación de objetos de conexión es costosa en términos 
                    de tiempo como de recursos.
                </p>
                <p>
                    Ahora que estos objetos <code>DataSource</code> y <code>ConnectionPoolDataSource</code> están desplegados, un 
                    programador puede usar el objeto <code>DataSource</code> para obtener una conexión agrupada. El código para 
                    obtener una conexión agrupada es como el código para obtener una conexión no agrupada, como se muestra en las 
                    siguientes dos líneas:
                </p>
                <div class="codeblock">
                    <pre>
ctx = new InitialContext();
ds = (DataSource)ctx.lookup("jdbc/fastCoffeeDB");
                    </pre>
                </div>
                <p>
                    La variable <code><em>ds</em></code> representa un objeto <code>DataSource</code> que produce conexiones 
                    agrupadas a la base de datos <code>COFFEEBREAK</code>. Necesita recuperar este objeto <code>DataSource</code> 
                    sólo una vez porque puede usarlo para producir tantas conexiones agrupadas como necesite. Llamar al método 
                    <code>getConnection</code> en la variable <code><em>ds</em></code> automáticamente produce una conexión 
                    agrupada porque el objeto <code>DataSource</code> que la variable <code><em>ds</em></code> representa fue 
                    configurado para producir conexiones agrupadas.
                </p>
                <p>
                    La agrupación de conexiones es generalmente transparente para el programador. Hay sólo dos cosas que necesita 
                    hacer cuando está usando conexiones agrupadas:
                </p>
                <ol>
                    <li>
                        <p>
                            Use un objeto <code>DataSource</code> en vez de la clase <code>DriverManager</code> para obtener una 
                            conexión. En la siguiente línea de código, <code><em>ds</em></code> es un objeto 
                            <code>DataSource</code> implementado y desplegado de forma que creará conexiones agrupadas y 
                            <code>username</code> y <code>password</code> son variables que representan las credenciales del 
                            usaurio que tiene acceso a la base de datos:
                        </p>
                        <div class="codeblock">
                            <pre>
Connection con = ds.getConnection(username, password);
                            </pre>
                        </div>
                    </li>
                    <li>
                        <p>
                            Use una sentencia <code>finally</code> para cerrar un conexión agrupada. El bloque <code>finally</code> 
                            siguiente aparecería después del bloque <code>try/catch</code> que aplica al código en el cual se usó 
                            la conexión agrupada:
                        </p>
                        <div class="codeblock">
                            <pre>
try {
    Connection con = ds.getConnection(username, password);
    // ... code to use the pooled
    // connection con
} catch (Exception ex {
    // ... code to handle exceptions
} finally {
    if (con != null) con.close();
}
                            </pre>
                        </div>
                    </li>
                </ol>
                <p>
                    De lo contrario, una aplicación que usa una conexión agrupada es idéntica a una aplicación que usa una 
                    conexión regular. La otra única cosa que un programador de aplicación podría notar cuando se realiza la 
                    agrupación de conexiones es que el rendimiento es mejor.
                </p>
                <p>
                    El ejemplo siguiente de código obtiene un objeto <code>DataSource</code> que produce conexiones a la base de 
                    datos <code>COFFEEBREAK</code> y las usa para actualizar un precio en la tabla <code>COFFEES</code>:
                </p>
                <div class="codeblock">
                    <pre>
import java.sql.*;
import javax.sql.*;
import javax.ejb.*;
import javax.naming.*;

public class ConnectionPoolingBean implements SessionBean {

    // ...

    public void ejbCreate() throws CreateException {
        ctx = new InitialContext();
        ds = (DataSource)ctx.lookup("jdbc/fastCoffeeDB");
    }

    public void updatePrice(float price, String cofName,
                            String username, String password)
        throws SQLException{

        Connection con;
        PreparedStatement pstmt;
        try {
            con = ds.getConnection(username, password);
            con.setAutoCommit(false);
            pstmt = con.prepareStatement(&quot;UPDATE COFFEES &quot; +
                        &quot;SET PRICE = ? " +
                        "WHERE COF_NAME = ?&quot;);
            pstmt.setFloat(1, price);
            pstmt.setString(2, cofName);
            pstmt.executeUpdate();

            con.commit();
            pstmt.close();

        } finally {
            if (con != null) con.close();
        }
    }

    private DataSource ds = null;
    private Context ctx = null;
}

                    </pre>
                </div>
                <p>
                    La conexión en este ejemplo de código participa en una agrupación de conexiones porque lo siguiente es verdad:
                </p>
                <ul>
                    <li>
                        Una instancia de una clase que implementa <code>ConnectionPoolDataSource</code> ha sido desplegada.
                    </li>
                    <li>
                        Una instancia de una clase que implementa <code>DataSource</code> ha sido desplegada, y el valor 
                        establecido para la propiedad <code>dataSourceName</code> es el nombre lógico que fue vinculado al objeto 
                        <code>ConnectionPoolDataSource</code> previamente desplegado.
                    </li>
                </ul>
                <p>
                    Dese cuenta de que aunque este código es muy similar al código que ha visto antes, es diferente en las formas 
                    siguientes:
                </p>
                <ul>
                    <li>
                        <p>
                            Importa los paquetes <code>javax.sql</code>, <code>javax.ejb</code>, y <code>javax.naming</code> 
                            además de <code>java.sql</code>.
                        </p>
                        <p>
                            Las interfaces <code>DataSource</code> y <code>ConnectionPoolDataSource</code> están en el paquete 
                            <code>javax.sql</code>, y el constructor JNDI de <code>InitialContext</code> y el método 
                            <code>Context.lookup</code> son parte del paquete <code>javax.naming</code>. Este ejemplo particular 
                            de código está en la forma de un componente EJB que usa la IPA del paquete <code>javax.ejb</code>. El 
                            propósito de este ejemplo es mostrar que usted usa una conexión agrupada de la misma forma que usa una 
                            conexión no agrupada, de forma que no necesita preocuparse por entender la IPA de EJB.
                        </p>
                    </li>
                    <li>
                        <p>
                            Usa un objeto <code>DataSource</code> para obtener una conexión en vez de usar la facilidad de 
                            <code>DriverManager</code>.
                        </p>
                    </li>
                    <li>
                        <p>
                            Usa un bloque <code>finally</code> para asegurarse de que la conexión se cierra.
                        </p>
                    </li>
                </ul>
                <p>
                    Obtener y usar una conexión agrupada es similar a obtener y usar una conexión regular. Cuando alguien actuando 
                    como administrador de sistema ha desplegado un objeto <code>ConnectionPoolDataSource</code> y un objeto 
                    <code>DataSource</code> apropiadamente, una aplicación usa ese objeto <code>DataSource</code> para obtener una 
                    conexión agrupada. Una aplicación debería, sin embargo, usar un  bloque <code>finally</code> para cerrar la 
                    conexión agrupada. Por simplicidad, el ejemplo precedente usó un bloque <code>finally</code> pero no un 
                    bloque <code>catch</code>. Si una excepción se lanza por un método en el bloque <code>try</code>, esta será 
                    lanzada por defecto, y la cláusula <code>finally</code> será ejecutada en cualquier caso.
                </p>
                <h2>
                    <a id="deployment_distributed_transactions">Desplegar Transacciones Distribuidas</a>
                </h2>
                <p>
                    Los objetos <code>DataSource</code> pueden ser desplegados para obtener conexiones que pueden usarse en 
                    transacciones distribuidas. Como con la agrupación de conexiones, dos instancias de clases diferentes deben ser 
                    desplegadas: un objeto <code>XADataSource</code> y un objeto <code>DataSource</code> que es implementado para 
                    trabajar con él.
                </p>
                <p>
                    Suponga que el servidor EJB que compró el empresario de The Coffe Break incluye la clase 
                    <code>com.applogic.TransactionalDS</code> de tipo <code>DataSource</code>, el cual trabaja con una clase 
                    <code>XADataSource</code> tal como <code>com.dbaccess.XATransactionalDS</code>. El hecho de que trabaje con 
                    cualquier clase <code>XADataSource</code> hace el servidor EJB portable a través de controladores JDBC. Cuando 
                    los objetos <code>DataSource</code> y <code>XADataSource</code> se despliegan, las conexiones producidas serán 
                    capaces de participar en transacciones distribuidas. En este caso, la clase 
                    <code>com.applogic.TransactionalDS</code> se implementa de forma que las conexiones producidas son también 
                    conexiones agrupadas, que suele ser el caso de las clases <code>DataSource</code> proporcionadas como parte de 
                    una implementación de servidor EJB.
                </p>
                <p>
                    El objeto <code>XADataSource</code> debe ser desplegado primero. El código siguiente crea una instancia de 
                    <code>com.dbaccess.XATransactionalDS</code> y establece sus propiedades:
                </p>
                <div class="codeblock">
                    <pre>
com.dbaccess.XATransactionalDS xads = new com.dbaccess.XATransactionalDS();
xads.setServerName(&quot;creamer&quot;);
xads.setDatabaseName(&quot;COFFEEBREAK&quot;);
xads.setPortNumber(9040);
xads.setDescription("Distributed transactions for COFFEEBREAK DBMS");
                    </pre>
                </div>
                <p>
                    El código siguiente registra el objeto <code>com.dbaccess.XATransactionalDS</code> <code><em>xads</em></code> 
                    con un servicio de nombres JNDI. Dese cuenta de que el nombre lógico que se está asociando con 
                    <code><em>xads</em></code> tiene el subcontexto <code>xa</code> agregado bajo <code>jdbc</code>. Oracle 
                    recomienda que el nombre lógico de cualquier instancia de la clase <code>com.dbaccess.XATransactionalDS</code> 
                    siempre empiece con <code>jdbc/xa</code>.
                </p>
                <div class="codeblock">
                    <pre>
Context ctx = new InitialContext();
ctx.bind("jdbc/xa/distCoffeeDB", xads);
                    </pre>
                </div>
                <p>
                    A continuación, el objeto <code>DataSource</code> que se implementa para interactuar con 
                    <code><em>xads</em></code> y otros objetos <code>XADataSource</code> se despliega. Dese cuenta de que la 
                    clase <code>DataSource</code>, <code>com.applogic.TransactionalDS</code>, puede trabajar con una clase 
                    <code>XADataSource</code> desde cualquier proveedor de controladores JDBC. Desplegar el objeto 
                    <code>DataSource</code> implica crear una instancia de la clase <code>com.applogic.TransactionalDS</code> y 
                    establecer sus propiedades. La propiedad <code>dataSourceName</code> es establecida como 
                    <code>jdbc/xa/distCoffeeDB</code>, el nombre lógico asociado con <code>com.dbaccess.XATransactionalDS</code>. 
                    Este es la clase <code>XADataSource</code> que implementa la capacidad de transacción distribuida para la 
                    clase <code>DataSource</code>. El código siguiente despliega una instancia de la clase <code>DataSource</code>:
                </p>
                <div class="codeblock">
                    <pre>
com.applogic.TransactionalDS ds = new com.applogic.TransactionalDS();
ds.setDescription("Produces distributed transaction " +
                  "connections to COFFEEBREAK&quot;);
ds.setDataSourceName("jdbc/xa/distCoffeeDB");
Context ctx = new InitialContext();
ctx.bind(&quot;jdbc/distCoffeeDB&quot;, ds);
                    </pre>
                </div>
                <p>
                    Ahora que esas instancias de las clases <code>com.applogic.TransactionalDS</code> y 
                    <code>com.dbaccess.XATransactionalDS</code> han sido desplegadas, una aplicación puede llamar al método 
                    <code>getConnection</code> sobre instancias de la clase <code>TransactionalDS</code> para obtener una conexión 
                    a la base de datos <code>COFFEEBREAK</code> que puede ser usada en transacciones distribuidas.
                </p>
                <h2>
                    <a id="using_connections_distributed_transactions">Usar Conexiones para Transacciones Distribuidas</a>
                </h2>
                <p>
                    Para obtener una conexión que pueda ser usada para transacciones distribuidas, debe usar un objeto 
                    <code>DataSource</code> que ha sido apropiadamente implementado y desplegado, como se mostró en la sección
                    <a href="#deployment_distributed_transactions">Desplegar Transacciones Distribuidas</a>. Con tal objeto 
                    <code>DataSource</code>, llame al método <code>getConnection</code> en él. Después de que usted tiene la 
                    conexión, úsela simplemente como usaría cualquier otra conexión. Debido a que <code>jdbc/distCoffeesDB</code> 
                    se ha asociado con un objeto <code> XADataSource </code> en un servicio de nombres JNDI, el código siguiente 
                    produce un objeto <code>Connection</code> que puede usarse en transacciones distribuidas:
                </p>
                <div class="codeblock">
                    <pre>
Context ctx = new InitialContext();
DataSource ds = (DataSource)ctx.lookup(&quot;jdbc/distCoffeesDB&quot;);
Connection con = ds.getConnection();
                    </pre>
                </div>
                <p>
                    Existen algunas restricciones menores pero importantes sobre cómo se usa esta conexión mientras es parte de una 
                    transacción distribuida. Un gestor de transacciones controla cuando empieza una transacción distribuida y 
                    cuando es confirmada o revertida; por lo tanto, el código de la aplicación nunca debe llamar a los métodos 
                    <code>Connection.commit</code> o <code>Connection.rollback</code>. Del mismo modo una aplicación nunca debe 
                    llamar a <code>Connection.setAutoCommit(true)</code>, que habilita el modo de confirmación automática, porque 
                    eso también interferiría con el control del gestor de transacciones de los límites de la transacción. Esto 
                    explica porqué una nueva conexión que se crea en el alcance de una transacción distribuida tiene su modo de 
                    confirmación automática deshabilitado de forma predetermianda. Dese cuenta que estas restricciones se aplican 
                    sólo cuando una conexión está participando en una transacción distribuida; no hay restricciones mientras la 
                    conexión no sea parte de una transacción distribuida.
                </p>
                <p>
                    Para el ejemplo siguiente, suponga que una petición de café ha sido enviada, lo cual dispara actualizaciones 
                    a dos tablas que residen en diferentes servidores DBMS. La primera tabla es una nueva tabla 
                    <code>INVENTORY</code>, y la segunda es la tabla <code>COFFEES</code>. Ya que estas tablas están en diferentes 
                    servidores DBMS, una transacción que implique a ambas será una transacción distribuida. El código en el ejemplo 
                    siguiente, el cual obtiene una conexión, actualiza la tabla <code>COFFEES</code>, y cierra la conexión, es la 
                    segunda parte de una transacción distribuida.
                </p>
                <p>
                    Tenga en cuenta que el código no confirma ni revierte explícitamente las actualizaciones porque el alcance de 
                    la transacción distribuida está controlado por la infraestructura del sistema subyacente del servidor de nivel 
                    medio. También, asumiendo que la conexión usada para la transacción distribuida es una conexión agrupada, la 
                    aplicación usa un bloque <code>finally</code> para cerrar la conexión. Esto garantiza que una conexión válida 
                    será cerrada incluso si se lanza una excepción, asegurando así que la conexión se devuelve al grupo de 
                    conexiones para ser reciclada.
                </p>
                <p>
                    El siguiente ejemplo de código ilustra un Enterprise Bean, el cual es una clase que implementa los métodos que 
                    pueden ser llamados por una computadora cliente. El propósito de este ejemplo es demostrar que el código de la 
                    aplicación para una transacción distribuida no es diferente de otro código excepto que no llama a los métodos 
                    de <code>Connection</code> <code>commit</code>, <code>rollback</code>, o <code>setAutoCommit(true)</code>. Por 
                    lo tanto, no necesita preocuparse por comprender la IPA de EJB que se utiliza.
                </p>
                <div class="codeblock">
                    <pre>
import java.sql.*;
import javax.sql.*;
import javax.ejb.*;
import javax.naming.*;

public class DistributedTransactionBean implements SessionBean {

    // ...

    public void ejbCreate() throws CreateException {

        ctx = new InitialContext();
        ds = (DataSource)ctx.lookup(&quot;jdbc/distCoffeesDB&quot;);
    }

    public void updateTotal(int incr, String cofName, String username,
                            String password)
        throws SQLException {

        Connection con;
        PreparedStatement pstmt;

        try {
            con = ds.getConnection(username, password);
            pstmt = con.prepareStatement(&quot;UPDATE COFFEES &quot; +
                        &quot;SET TOTAL = TOTAL + ? " +
                        "WHERE COF_NAME = ?&quot;);
            pstmt.setInt(1, incr);
            pstmt.setString(2, cofName);
            pstmt.executeUpdate();
            stmt.close();
        } finally {
            if (con != null) con.close();
        }
    }

    private DataSource ds = null;
    private Context ctx = null;
}
                    </pre>
                </div>
            </div>
            <div class="NavBit">
                <a target="_top" href="connecting.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="sqlexception.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Estableciendo una Conexión<br />
            <b>Página siguiente:</b> Manejando SQLExceptions
        </div>
    </body>
</html> 
