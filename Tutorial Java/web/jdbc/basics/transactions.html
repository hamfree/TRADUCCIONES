<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Usando Transacciones (Los Tutoriales de Java&trade; &gt; Acceso a Bases de Datos JDBC(TM) &gt; Lo Básico de JDBC)
        </title>
        <meta name="description" content="Este tutorial de Java JDBC describe cómo usar la IPA JDBC para crear, insertar, 
              actualizar y consultar tablas. También aprenderá cómo usar declaraciones simples y preparadas, procedimientos 
              almacenados y realizar transacciones" />
        <meta name="keywords" content="java programming, learn java, java sample code, jdbc, prepared statement, result set" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Lo Básico de JDBC</a></div>
                <div class="linkAHEAD"><a href="gettingstarted.html">Empezando</a></div>
                <div class="linkAHEAD"><a href="processingsqlstatements.html">Procesando Sentencias SQL con JDBC</a></div>
                <div class="linkAHEAD"><a href="connecting.html">Estableciendo una Conexión</a></div>
                <div class="linkAHEAD"><a href="sqldatasources.html">Conectando con Objetos DataSource</a></div>
                <div class="linkAHEAD"><a href="sqlexception.html">Manejando SQLExceptions</a></div>
                <div class="linkAHEAD"><a href="tables.html">Configurando Tablas</a></div>
                <div class="linkAHEAD"><a href="retrieving.html">Recuperando y Modificando Valores de los Result Sets</a></div>
                <div class="linkAHEAD"><a href="prepared.html">Usando Prepared Statements</a></div>
                <div class="nolinkAHEAD">Usando Transacciones</div>
                <div class="linkAHEAD"><a href="rowset.html">Usando Objetos RowSet</a></div>
                <div class="linkAHEAD"><a href="jdbcrowset.html">Utilizando Objetos JdbcRowSet</a></div>
                <div class="linkAHEAD"><a href="cachedrowset.html">Utilizando CachedRowSetObjects</a></div>
                <div class="linkAHEAD"><a href="joinrowset.html">Utilizando Objetos JoinRowSet</a></div>
                <div class="linkAHEAD"><a href="filteredrowset.html">Utilizando Objetos FilteredRowSet</a></div>
                <div class="linkAHEAD"><a href="webrowset.html">Utilizando Objetos WebRowSet</a></div>
                <div class="linkAHEAD"><a href="sqltypes.html">Usando Tipos de Datos Avanzados</a></div>
                <div class="linkAHEAD"><a href="blob.html">Utilizando Objetos Grandes</a></div>
                <div class="linkAHEAD"><a href="sqlxml.html">Utilizando Objetos SQLXML</a></div>
                <div class="linkAHEAD"><a href="array.html">Utilizando Objetos Array</a></div>
                <div class="linkAHEAD"><a href="distinct.html">Usando el Tipo de Datos DISTINCT</a></div>
                <div class="linkAHEAD"><a href="sqlstructured.html">Utilizando Objetos Estructurados</a></div>
                <div class="linkAHEAD"><a href="sqlcustommapping.html">Usando Mapeados de Tipos Personalizados</a></div>
                <div class="linkAHEAD"><a href="sqldatalink.html">Utilizando Objetos Datalink</a></div>
                <div class="linkAHEAD"><a href="sqlrowid.html">Utilizando Objetos RowId</a></div>
                <div class="linkAHEAD"><a href="storedprocedures.html">Usando Procedimientos Almacenados</a></div>
                <div class="linkAHEAD"><a href="jdbcswing.html">Usando JDBC con una IPA de IGU</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Acceso a Bases de Datos JDBC(TM)<br />
                <b>Lección:</b> Lo Básico de JDBC
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Acceso a Bases de Datos JDBC(TM)</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Lo Básico de JDBC</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="prepared.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="rowset.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Usando Transacciones</h1>
            </div>
            <div id="PageContent">
                <p>
                    Hay veces que no quiere que un sentencia haga efecto a menos que alguna otra se complete. Por ejemplo, cuando 
                    el propieatario de The Coffee Break actualiza la cantidad de café vendido cada semana, el propietario también 
                    querrá actualizar la cantidad total vendida hasta la fecha. Sin embargo, la cantidad vendida por semana y la 
                    cantidad total vendida debe ser actualizada al mismo tiempo; de lo contrario, los datos serán inconsistentes. 
                    La forma de estar seguro de que ambas acciones ocurran o que ninguna acción ocurra es usar una transacción. 
                    Una transacción es un conjunto de una o más sentencias que se ejecutan como una unidad, así o todas las 
                    sentencias son ejecutadas, o ninguna de las sentencias es ejecutada.
                </p>
                <p>
                    Esta página cubre los elementos siguientes
                </p>
                <ul>
                    <li><a href="#disable_auto_commit">Desactivación del Modo de Confirmación Automática</a></li>
                    <li><a href="#commit_transactions">Confirmación de Transacciones</a></li>
                    <li><a href="#transactions_data_integrity">Usando Transacciones para Preservar la Integridad de Datos</a></li>
                    <li><a href="#set_roll_back_savepoints">Configuración y Reversión a Puntos de Guardado</a></li>
                    <li><a href="#release_savepoints">Liberar Puntos de Guardado</a></li>
                    <li><a href="#call_rollback">Cuándo Llamar al Método de Reversión</a></li>
                </ul>
                <h2>
                    <a id="disable_auto_commit">Desactivación del Modo de Confirmación Automática</a>
                </h2>
                <p>
                    Cuando se crea una conexión, está en el modo de auto-confirmación. Esto significa que cada sentencia SQL 
                    individual es tratada como una transacción y es automáticamente confirmada justo después de que es ejecutada. 
                    (Para ser más preciso, el valor predeterminado es que una sentencia SQL se confirme cuando se completa, no 
                    cuando se ejecuta. Una sentencia se completa cuando todos sus conjuntos de resultados y recuentos de 
                    actualización han sido recuperados. En casi todos los casos, sin embargo, una sentencia se completa, y por lo 
                    tanto, se confirma, justo después de su ejecución).
                </p>
                <p>
                    La forma de permitir que dos o más sentencias sean agrupadas en una transacción es deshabilitar el modo de 
                    auto-confirmación. Esto se demuestra en el código siguiente, donde <code>con</code> es una conexión activa:
                </p>
                <div class="codeblock">
                    <pre>
con.setAutoCommit(false);
                    </pre>
                </div>
                <h2>
                    <a id="commit_transactions">Confirmación de Transacciones</a>
                </h2>
                <p>
                    Después de que se deshabilita el modo de auto-confirmación, ninguna sentencia SQL se confirma hasta que llama 
                    al método <code>commit</code> explícitamente. Todas las sentencias ejecutadas después de la llamada previa al 
                    método <code>commit</code> se incluyen en la transacción actual y confirmadas juntas como una unidad. El método 
                    siguiente, <code><a href="gettingstarted.html">CoffeesTable.updateCoffeeSales</a></code>, en el cual 
                    <code>con</code> es una conexión activa, ilustra una transacción:
                </p>
                <div class="codeblock">
                    <pre>
public void updateCoffeeSales(HashMap&lt;String, Integer> salesForWeek)
    throws SQLException {

    PreparedStatement updateSales = null;
    PreparedStatement updateTotal = null;

    String updateString =
        "update " + dbName + ".COFFEES " +
        "set SALES = ? where COF_NAME = ?";

    String updateStatement =
        "update " + dbName + ".COFFEES " +
        "set TOTAL = TOTAL + ? " +
        "where COF_NAME = ?";

    try {
        con.setAutoCommit(false);
        updateSales = con.prepareStatement(updateString);
        updateTotal = con.prepareStatement(updateStatement);

        for (Map.Entry&lt;String, Integer> e : salesForWeek.entrySet()) {
            updateSales.setInt(1, e.getValue().intValue());
            updateSales.setString(2, e.getKey());
            updateSales.executeUpdate();
            updateTotal.setInt(1, e.getValue().intValue());
            updateTotal.setString(2, e.getKey());
            updateTotal.executeUpdate();
            con.commit();
        }
    } catch (SQLException e ) {
        JDBCTutorialUtilities.printSQLException(e);
        if (con != null) {
            try {
                System.err.print("Transaction is being rolled back");
                con.rollback();
            } catch(SQLException excep) {
                JDBCTutorialUtilities.printSQLException(excep);
            }
        }
    } finally {
        if (updateSales != null) {
            updateSales.close();
        }
        if (updateTotal != null) {
            updateTotal.close();
        }
        con.setAutoCommit(true);
    }
}
                    </pre>
                </div>
                <p>
                    En este método, el modo de auto-confirmación se deshabilita para la conexión <code>con</code>, lo que significa 
                    que las dos sentencias preparadas <code>updateSales</code> y <code>updateTotal</code> son confirmadas juntas 
                    cuando se llama el método <code>commit</code>. Siempre que se llama al método <code>commit</code> (ya sea 
                    automáticamente cuando el modo de confirmación automática está habilitado o explícitamente cuando está 
                    deshabilitado), todos los cambios resultantes de las declaraciones en la transacción se hacen permanentes. En 
                    este caso, eso significa que las columnas <code>SALES</code> y <code>TOTAL</code> para el café Colombian han 
                    sido cambiados a <code>50</code> (si <code>TOTAL</code> ha sido <code>0</code> previamente) y retendrá este 
                    valor hasta que hayan cambiado con otra sentencia de actualización.
                </p>
                <p>
                    La sentencia <code>con.setAutoCommit(true);</code> habilita el modo de auto-confirmación, lo cual significa que 
                    cada sentencia es una vez de nuevo confirmada automáticamente cuando se completa. Luego, regresa al estado 
                    predeterminado en el que no tiene que llamar al método <code>commit</code> usted mismo. Es recomendable 
                    deshabilitar el modo de confirmación automática sólo durante el modo de transacción. De esta forma, evita 
                    mantener los bloqueos en la base de datos para múltiples sentencias, lo que aumenta la probabilidad de 
                    conflictos con otros usuarios.
                </p>
                <h2>
                    <a id="transactions_data_integrity">Usando Transacciones para Preservar la Integridad de Datos</a>
                </h2>
                <p>
                    Además de agrupar las sentencias juntas para ejecutarlas como una unidad, las transacciones pueden ayudar a 
                    preservar la integridad de los datos en una tabla. Por ejemplo, imagine que se suponía que un empleado debía 
                    ingresar nuevos precios de café en la tabla <code>COFFEES</code>, pero se demoró unos días en hacerlo. Mientras 
                    tanto, los precios subieron y hoy el propietario está en proceso de ingresar los precios más altos. El empleado 
                    finalmente ingresa los precios ahora desactualizados al mismo tiempo que el propietario está tratando de 
                    actualizar la tabla. Después de insertar los precios desactualizados, el empleado se da cuenta de que no son ya 
                    válidos y llama al método <code>rollback</code> de <code>Connection</code> para deshacer sus efectos. (El 
                    método <code>rollback</code> aborta una transacción y restaura los valores a los que eran antes del intento de 
                    actualización). Al mismo tiempo, el propietario está ejecutando un sentencia <code>SELECT</code> e imprime los 
                    nuevos precios. En esta situación, es posible que el propietario imprima un precio que se había revertido a 
                    su valor anterior, haciendo que el precio impreso sea incorrecto.
                </p>
                <p>
                    Esta clase de situación puede ser evitada usando transacciones, proporcionando algún nivel de protección contra 
                    los conflictos que surjen cuando dos usuarios acceden a los datos al mismo tiempo.
                </p>
                <p>
                    Para evitar conflictos durante una transacción, un DBMS usa los bloqueos, mecanismos para bloquear el acceso 
                    por otros a los datos que están siendo accedidos por la transacción. (Dese cuenta de que en el modo de 
                    auto-confirmación, donde cada sentencia es una transacción, los bloqueos se mantienen sólo para una 
                    declaración). Después de que se establece un bloqueo, permanece en vigor hasta que la transacción se confirma 
                    o se revierte. Por ejemplo, un DBMS podría bloquear una fila de una tabla hasta que las actualizaciones a esta 
                    han sido confirmados. El efecto de este bloqueo sería prevenir que un usuario obtenga una lectura sucia, es 
                    decir, leer un valor antes de que se convierta en permanente. (Acceder a un valor actualizado que no ha sido 
                    confirmado es considerado una <em>lectura sucia</em> porque es posible que ese valor sea revertido a su valor 
                    previo. Si lee un valor que es más tarde revertido, habrá leído un valor no válido).
                </p>
                <p>
                    La forma en que se establecen los bloqueos está determinada por lo que se llama un nivel de aislamiento de 
                    transacciones, que puede ir desde no admitir transacciones en absoluto hasta admitir transacciones que imponen 
                    reglas de acceso muy estrictas.
                </p>
                <p>
                    Un ejemplo de un nivel de aislamiento de transacción es <code>TRANSACTION_READ_COMMITTED</code>, que no 
                    permitirá acceder a un valor hasta después de que se haya confirmado. En otras palabras, si el nivel de 
                    aislamiento de transacción está establecido a <code>TRANSACTION_READ_COMMITTED</code>, el DBMS no permite que 
                    ocurran lecturas sucias. La interfaz <code>Connection</code> incluye cinco valores que representan los niveles 
                    de aislamiento de transacción que puede usar en JDBC:
                </p>
                <table class="celda">
                    <caption>Niveles de Aislamiento de Transacción</caption>
                    <tr>
                        <th id="h1" class="celda">Nivel de Aislamiento</th>
                        <th id="h2" class="celda">Transacciones</th>
                        <th id="h3" class="celda">Lecturas Sucias</th>
                        <th id="h4" class="celda">Lecturas No-Repetibles</th>
                        <th id="h5" class="celda">Lecturas Fantasma</th>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>TRANSACTION_NONE</code></td>
                        <td headers="h2" class="celda">No soportado</td>
                        <td headers="h3" class="celda"><em>No aplica</em></td>
                        <td headers="h4" class="celda"><em>No aplica</em></td>
                        <td headers="h5" class="celda"><em>No aplica</em></td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>TRANSACTION_READ_COMMITTED</code></td>
                        <td headers="h2" class="celda">Soportado</td>
                        <td headers="h3" class="celda">Prevenido</td>
                        <td headers="h4" class="celda">Permitido</td>
                        <td headers="h5" class="celda">Permitido</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>TRANSACTION_READ_UNCOMMITTED</code></td>
                        <td headers="h2" class="celda">Soportado</td>
                        <td headers="h3" class="celda">Permitido</td>
                        <td headers="h4" class="celda">Permitido</td>
                        <td headers="h5" class="celda">Permitido</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>TRANSACTION_REPEATABLE_READ</code></td>
                        <td headers="h2" class="celda">Soportado</td>
                        <td headers="h3" class="celda">Prevenido</td>
                        <td headers="h4" class="celda">Prevenido</td>
                        <td headers="h5" class="celda">Permitido</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda"><code>TRANSACTION_SERIALIZABLE</code></td>
                        <td headers="h2" class="celda">Soportado</td>
                        <td headers="h3" class="celda">Prevenido</td>
                        <td headers="h4" class="celda">Prevenido</td>
                        <td headers="h5" class="celda">Prevenido</td>
                    </tr>
                </table>
                <p>
                    Una <em>lectura no repetible</em> ocurre cuando la transacción recupera una fila, la transacción B 
                    subsecuentemente actualiza la fila, y la transacción A más tarde recupera la misma fila de nuevo. La 
                    transacción A recupera la misma fila dos veces pero ve datos diferentes.
                </p>
                <p>
                    Una <em>lectura fantasma</em> ocurre cuando la transacción A recupera un conjunto de filas que satisfacen una 
                    condición dada, la transacción B posteriormente inserta o actualiza una fila de modo que la fila ahora cumpla 
                    con la condición en la transacción A, y la transacción A más tarde repite la recuperación condicional. La 
                    transacción A ahora ve una fila adicional. Esta fila se conoce como fantasma.
                </p>
                <p>
                    Usualmente, no necesita hacer nada sobre el nivel de aislamiento de transacción; puede simplemente usar el 
                    predeterminado para su DBMS. EL nivel de aislamiento de transacción predeterminado depende de su DBMS. Por 
                    ejemplo, para Java DB, es <code>TRANSACTION_READ_COMMITTED</code>. JDBC le permite encontrar qué nivel de 
                    aislamiento de transacción tiene establecida su DBMS (usando el método <code>getTransactionIsolation</code> de 
                    <code>Connection</code>) y también le permite establecerlo en otro nivel (usando el método 
                    <code>setTransactionIsolation</code> de <code>Connection</code>).
                </p>
                <p>
                    <strong>Nota</strong>: Un controlador JDBC podría no admitir todos los niveles de aislamiento de transacción. 
                    Si un controlador no admite el nivel de aislamiento especificado en una invocación de 
                    <code>setTransactionIsolation</code>, el controlador puede sustituirlo por un nivel de aislamiento de 
                    transacciones más alto y más restrictivo. Si un controlador no puede sustituirlo por un nivel más alto de 
                    transacción, lanza una <code>SQLException</code>. Use el método 
                    <code>DatabaseMetaData.supportsTransactionIsolationLevel</code> para determinar si el controlador admite o no 
                    un nivel dado.
                </p>
                <h2>
                    <a id="set_roll_back_savepoints">Configuración y Reversión a Puntos de Guardado</a>
                </h2>
                <p>
                    El método <code>Connection.setSavepoint</code>, establece un objeto <code>Savepoint</code> dentro de la 
                    transacción actual. El método <code>Connection.rollback</code> está sobreescrito para tomar un argumento 
                    <code>Savepoint</code>.
                </p>
                <p>
                    El método siguiente, <code><a href="gettingstarted.html">CoffeesTable.modifyPricesByPercentage</a></code>, 
                    aumenta el precio de un café particular en un porcentaje, <code>priceModifier</code>. Sin embargo, si el precio 
                    nuevo es mayor que un precio especificado, <code>maximumPrice</code>, entonces el precio se revierte al precio 
                    original:
                </p>
                <div class="codeblock">
                    <pre>
public void modifyPricesByPercentage(
    String coffeeName,
    float priceModifier,
    float maximumPrice)
    throws SQLException {
    
    con.setAutoCommit(false);

    Statement getPrice = null;
    Statement updatePrice = null;
    ResultSet rs = null;
    String query =
        "SELECT COF_NAME, PRICE FROM COFFEES " +
        "WHERE COF_NAME = '" + coffeeName + "'";

    try {
        Savepoint save1 = con.setSavepoint();
        getPrice = con.createStatement(
                       ResultSet.TYPE_SCROLL_INSENSITIVE,
                       ResultSet.CONCUR_READ_ONLY);
        updatePrice = con.createStatement();

        if (!getPrice.execute(query)) {
            System.out.println(
                "Could not find entry " +
                "for coffee named " +
                coffeeName);
        } else {
            rs = getPrice.getResultSet();
            rs.first();
            float oldPrice = rs.getFloat("PRICE");
            float newPrice = oldPrice + (oldPrice * priceModifier);
            System.out.println(
                "Old price of " + coffeeName +
                " is " + oldPrice);

            System.out.println(
                "New price of " + coffeeName +
                " is " + newPrice);

            System.out.println(
                "Performing update...");

            updatePrice.executeUpdate(
                "UPDATE COFFEES SET PRICE = " +
                newPrice +
                " WHERE COF_NAME = '" +
                coffeeName + "'");

            System.out.println(
                "\nCOFFEES table after " +
                "update:");

            CoffeesTable.viewTable(con);

            if (newPrice > maximumPrice) {
                System.out.println(
                    "\nThe new price, " +
                    newPrice +
                    ", is greater than the " +
                    "maximum price, " +
                    maximumPrice +
                    ". Rolling back the " +
                    "transaction...");

                con.rollback(save1);

                System.out.println(
                    "\nCOFFEES table " +
                    "after rollback:");

                CoffeesTable.viewTable(con);
            }
            con.commit();
        }
    } catch (SQLException e) {
        JDBCTutorialUtilities.printSQLException(e);
    } finally {
        if (getPrice != null) { getPrice.close(); }
        if (updatePrice != null) {
            updatePrice.close();
        }
        con.setAutoCommit(true);
    }
}
                    </pre>
                </div>
                <p>
                    La siguiente sentencia especifica que el cursor del objeto <code>ResultSet</code> generado desde la consulta 
                    <code>getPrice</code> se cierra cuando se llame al método <code>commit</code>. Dese cuenta que si su DBMS no 
                    admite <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>, entonces esta constante se ignora:
                </p>
                <div class="codeblock">
                    <pre>
getPrice = con.prepareStatement(query, ResultSet.CLOSE_CURSORS_AT_COMMIT);
                    </pre>
                </div>
                <p>
                    El método empieza creando un <code>Savepoint</code> con la sentencia siguiente:
                </p>
                <div class="codeblock">
                    <pre>
Savepoint save1 = con.setSavepoint();
                    </pre>
                </div>
                <p>
                    El método comprueba si el nuevo precio es mayor que el valor <code>maximumPrice</code>. Si lo es, el método 
                    revierte la transacción con la siguiente sentencia:
                </p>
                <div class="codeblock">
                    <pre>
con.rollback(save1);
                    </pre>
                </div>
                <p>
                    Como consecuencia, cuando el método confirma la transacción al llamar al método <code>Connection.commit</code>, 
                    no confirmará ninguna fila cuyo <code>Savepoint</code> asociado haya sido revertido; confirmará todas las otras 
                    filas actualizadas.
                </p>
                <h2>
                    <a id="release_savepoints">Liberar Puntos de Guardado</a>
                </h2>
                <p>
                    El método <code>Connection.releaseSavepoint</code> toma un objeto <code>Savepoint</code> como un parámetro y 
                    lo elimina de la transacción actual.
                </p>
                <p>
                    Después de que se haya liberado un punto de guardado, intentar referenciarlo en una operación de reversión 
                    provoca que se lanze una <code>SQLException</code>. Cualquier punto de guardado que ha sido creado en una 
                    transacción es automáticamente liberado y se convierte en inválido cuando se confirma la transacción, o cuando 
                    la transacción entera se revierte. Revertir una transacción a un punto de salvado automáticamente libera y 
                    anula cualquier otro punto de salvado que se haya creado después del punto de salvado en cuestión.
                </p>
                <h2>
                    <a id="call_rollback">Cuándo Llamar al Método de Reversión</a>
                </h2>
                <p>
                    Como se mencionó anteriormente, llamar al método <code>rollback</code> termina una transacción y devuelve 
                    cualquier valor que fue modificado a sus valores previos. Si está intentando ejecutar una o más sentencias en 
                    una transacción y obtiene una <code>SQLException</code>, llame al método <code>rollback</code> para terminar la 
                    transacción y comenzar la transacción de nuevo. Esta es la única forma de saber qué ha sido confirmado y qué 
                    no. Capturar una <code>SQLException</code> le indica que algo ha ido mal, pero no le dice qué fue o no 
                    confirmado. Debido a que no puede contar con el hecho de que no se confirmó nada, llamar al método 
                    <code>rollback</code> es la única forma de estar seguro.
                </p>
                <p>
                    El método <code><a href="gettingstarted.html">CoffeesTable.updateCoffeeSales</a></code> demuestra una 
                    transacción e incluye un bloque <code>catch</code> que invoca al método <code>rollback</code>. Si la aplicación 
                    continúa y usa los resultados de la transacción, esta llamada al método <code>rollback</code> en el bloque 
                    <code>catch</code> evita el uso de datos posiblemente incorrectos.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="prepared.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="rowset.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Usando Prepared Statements<br />
            <b>Página siguiente:</b> Usando Objetos RowSet
        </div>
    </body>
</html> 
