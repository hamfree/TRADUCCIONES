<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Utilizando CachedRowSetObjects (Los Tutoriales de Java&trade; &gt; Acceso a Bases de Datos JDBC(TM) &gt; 
            Lo Básico de JDBC)
        </title>
        <meta name="description" content="Este tutorial de Java JDBC describe cómo usar la IPA JDBC para crear, insertar, 
              actualizar y consultar tablas. También aprenderá cómo usar declaraciones simples y preparadas, procedimientos 
              almacenados y realizar transacciones" />
        <meta name="keywords" content="java programming, learn java, java sample code, jdbc, prepared statement, result set" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Lo Básico de JDBC</a></div>
                <div class="linkAHEAD"><a href="gettingstarted.html">Empezando</a></div>
                <div class="linkAHEAD"><a href="processingsqlstatements.html">Procesando Sentencias SQL con JDBC</a></div>
                <div class="linkAHEAD"><a href="connecting.html">Estableciendo una Conexión</a></div>
                <div class="linkAHEAD"><a href="sqldatasources.html">Conectando con Objetos DataSource</a></div>
                <div class="linkAHEAD"><a href="sqlexception.html">Manejando SQLExceptions</a></div>
                <div class="linkAHEAD"><a href="tables.html">Configurando Tablas</a></div>
                <div class="linkAHEAD"><a href="retrieving.html">Recuperando y Modificando Valores de los Result Sets</a></div>
                <div class="linkAHEAD"><a href="prepared.html">Usando Prepared Statements</a></div>
                <div class="linkAHEAD"><a href="transactions.html">Usando Transacciones</a></div>
                <div class="linkAHEAD"><a href="rowset.html">Usando Objetos RowSet</a></div>
                <div class="linkAHEAD"><a href="jdbcrowset.html">Utilizando Objetos JdbcRowSet</a></div>
                <div class="nolinkAHEAD">Utilizando CachedRowSetObjects</div>
                <div class="linkAHEAD"><a href="joinrowset.html">Utilizando Objetos JoinRowSet</a></div>
                <div class="linkAHEAD"><a href="filteredrowset.html">Utilizando Objetos FilteredRowSet</a></div>
                <div class="linkAHEAD"><a href="webrowset.html">Utilizando Objetos WebRowSet</a></div>
                <div class="linkAHEAD"><a href="sqltypes.html">Usando Tipos de Datos Avanzados</a></div>
                <div class="linkAHEAD"><a href="blob.html">Utilizando Objetos Grandes</a></div>
                <div class="linkAHEAD"><a href="sqlxml.html">Utilizando Objetos SQLXML</a></div>
                <div class="linkAHEAD"><a href="array.html">Utilizando Objetos Array</a></div>
                <div class="linkAHEAD"><a href="distinct.html">Usando el Tipo de Datos DISTINCT</a></div>
                <div class="linkAHEAD"><a href="sqlstructured.html">Utilizando Objetos Estructurados</a></div>
                <div class="linkAHEAD"><a href="sqlcustommapping.html">Usando Mapeados de Tipos Personalizados</a></div>
                <div class="linkAHEAD"><a href="sqldatalink.html">Utilizando Objetos Datalink</a></div>
                <div class="linkAHEAD"><a href="sqlrowid.html">Utilizando Objetos RowId</a></div>
                <div class="linkAHEAD"><a href="storedprocedures.html">Usando Procedimientos Almacenados</a></div>
                <div class="linkAHEAD"><a href="jdbcswing.html">Usando JDBC con una IPA de IGU</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Acceso a Bases de Datos JDBC(TM)<br />
                <b>Lección:</b> Lo Básico de JDBC
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Acceso a Bases de Datos JDBC(TM)</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Lo Básico de JDBC</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="jdbcrowset.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="joinrowset.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Utilizando CachedRowSetObjects</h1>
            </div>
            <div id="PageContent">
                <p>
                    Un objeto <code>CachedRowSet</code> es especial en que puede operar sin estar conectado a su fuente de datos, 
                    es decir, es un objeto <code>RowSet</code> <i>desconectado</i>. Obtiene su nombre del hecho de que almacena 
                    (cachea) sus datos en memoria para que puede operar con sus propios datos en lugar de con los datos almacenados 
                    en una base de datos.
                </p>
                <p>
                    La interfaz de <code>CachedRowSet</code> es la superinterfaz para todos objetos <code>RowSet</code> 
                    desconectados, así que todo lo demostrado aquí también se aplica a los objetos <code>WebRowSet</code>, 
                    <code>JoinRowSet</code>, y <code>FilteredRowSet</code>.
                </p>
                <p>
                    Tenga en cuenta que aunque la fuente de datos para un objeto <code>CachedRowSet</code> (y los objetos 
                    <code>RowSet</code> derivados de él) es casi siempre una base de datos relacional, un objeto 
                    <code>CachedRowSet</code> es capaz de obtener datos desde cualquier fuente de datos que almacene sus datos en un 
                    formato tabular. Por ejemplo, un fichero plano o una hoja de cálculo podrían ser la fuente de los datos. Esto 
                    es verdad cuando el objeto <code>RowSetReader</code> para un objeto <code>RowSet</code> desconectado se 
                    implementa para leer datos de dicha fuente de datos. La implementación de referencia de la interfaz 
                    <code>CachedRowSet</code> tiene un objeto <code>RowSetReader</code> que lee datos de una base de datos 
                    relacional, así en este tutorial, la fuente de datos es siempre una base de datos.
                </p>
                <p>
                    Los siguientes temas están cubiertos:
                </p>
                <ul>
                    <li><a href="#setting-up-cachedrowset-object">Configuración de Objetos CachedRowSet</a></li>
                    <li><a href="#populating-cachedrowset-object">Llenado de Objetos CachedRowSet</a></li>
                    <li><a href="#reader">Qué Hace Reader</a></li>
                    <li><a href="#updating-cachedrowset-object">Actualizar Objetos CachedRowSet</a></li>
                    <li><a href="#updating-data-source">Actualizar Fuentes de Datos</a></li>
                    <li><a href="#writer">Qué Hace Writer</a></li>
                    <li><a href="#syncresolver">Usar Objetos SyncResolver</a></li>
                    <li><a href="#notifying-listeners">Notificar a los Listeners</a></li>
                    <li><a href="#sending-large-amounts-of-data">Enviar Grandes Cantidades de Datos</a></li>
                </ul>
                <h2>
                    <a id="setting-up-cachedrowset-object">Configuración de Objetos CachedRowSet</a>
                </h2>
                <p>
                    Configurar un objeto <code>CachedRowSet</code> implica lo siguiente:
                </p>
                <ul>
                    <li><a href="#creating-cachedrowset-object">Crear Objetos CachedRowSet</a></li>
                    <li><a href="#setting-cachedrowset-properties">Establecer Propiedades de CachedRowSet</a></li>
                    <li><a href="#setting-key-columns">Establecer Columnas Clave</a></li>
                </ul>
                <h3>
                    <a id="creating-cachedrowset-object">Crear Objetos CachedRowSet</a>
                </h3>
                <p>
                    Puede crear un nuevo objeto <code>CachedRowSet</code> de diferentes formas:
                </p>
                <ul>
                    <li>
                        <a href="#using-default-constructor">Usando el Constructor Predeterminado</a>
                    </li>
                    <li>
                        Usando una instancia de <code>RowSetFactory</code>, la cual se crea desde la clase 
                        <code>RowSetProvider</code>: Vea <a href="jdbcrowset.html#rowsetfactory">Usar la Interfaz RowSetFactory</a> 
                        en <a href="jdbcrowset.html">Utilizando Objetos JdbcRowSet</a> para más información.
                    </li>
                </ul>
                <p>
                    <strong>Nota</strong>: Alternativamente, puede usar el constructor de la implementación de 
                    <code>CachedRowSet</code> de su controlador JDBC. Sin embargo, las implementaciones de la interfaz 
                    <code>RowSet</code> diferirán de la implementación de referencia. Estas implementaciones tendrán nombres y 
                    constructores diferentes. Por ejemplo, la implementación de la interfaz <code>CachedRowSet</code> del 
                    controlador JDBC de Oracle se llama <code>oracle.jdbc.rowset.OracleCachedRowSet</code>.
                </p>
                <h4>
                    <a id="using-default-constructor">Usar El Constructor por Defecto</a>
                </h4>
                <p>
                    Una de las formas en las que puede crear un objeto <code>CachedRowSet</code> es llamando al constructor 
                    predeterminado definido en la implementación de referencia, como se hace en la siguiente línea de código:
                </p>
                <div class="codeblock">
                    <pre>
CachedRowSet crs = new CachedRowSetImpl();
                    </pre>
                </div>
                <p>
                    El objeto <code>crs</code> tiene los mismos valores predeterminados para sus propiedades que un objeto 
                    <code>JdbcRowSet</code> tiene cuando se crea por primera vez. Además, le ha sido asignada una instancia de la 
                    implementación predeterminada de <code>SyncProvider</code>, <code>RIOptimisticProvider</code>.
                </p>
                <p>
                    Un objeto <code>SyncProvider</code> proporciona un objeto <code>RowSetReader</code> (un <i>lector</i>) y un 
                    objeto <code>RowSetWriter</code> (un <i>escritor</i>), que necesita un objeto <code>RowSet</code> desconectado 
                    para leer datos desde su fuente de datos o escribir datos de vuelta a su fuente de datos. Lo que hacen un 
                    lector o un escritor se explica más tarde en las secciones <a href="#reader">Qué Hace Reader</a> y
                    <a href="#writer">Qué Hace Writer</a>. Una cosa a tener en cuenta es que los lectores y escritores trabajan 
                    enteramente en segundo plano, así que la explicación de cómo trabajan es sólo para su información. Tener 
                    algunos antecedentes sobre lectores y escritores debería ayudarlo a comprender qué hacen algunos de los métodos 
                    definidos en la interfaz <code>CachedRowSet</code> en segundo plano.
                </p>
                <h3>
                    <a id="setting-cachedrowset-properties">Establecer Propiedades de CachedRowSet</a>
                </h3>
                <p>
                    Generalmente, los valores por defecto para las propiedades están bien tal como están, pero puede cambiar el 
                    valor de una propiedad llamando al método establecedor apropiado. Hay algunas propiedades sin valores 
                    predeterminados que debe establecer usted mismo.
                </p>
                <p>
                    Para obtener datos, un objeto <code>RowSet</code> desconectado debe ser capaz de conectar a una fuente de datos 
                    y tener alguna forma de seleccionar los datos que va a contener. Las propiedades siguientes contienen la 
                    información necesaria para obtener una conexión a la base de datos.
                </p>
                <ul>
                    <li><code>username</code>: El nombre que un usuario proporciona a una base de datos como parte de su acceso</li>
                    <li><code>password</code>: La contraseña del usuario de la base de datos</li>
                    <li><code>url</code>: La URL JDBC para la base de datos a la cual el usuario quiere conectar</li>
                    <li>
                        <code>datasourceName</code>: El nombre usado para recuperar el objeto DataSource que ha sido registrado con 
                        servicio de nombres JNDI
                    </li>
                </ul>
                <p>
                    Cuál de estas propiedades deberá establecer depende de cómo vaya a hacer una conexión. La forma preferida es 
                    usar un objeto <code>DataSource</code>, pero puede no serle práctico registrar un objeto 
                    <code>DataSource</code> con un servicio de nombres JNDI, lo que es generalmente hecho por un administrador de 
                    sistemas. Por lo tanto, todos los ejemplos de código usan el mecanismo de <code>DriverManager</code> para 
                    obtener una conexión, para lo cual usará la propiedad <code>url</code> y no la propiedad 
                    <code>datasourceName</code>.
                </p>
                <p>
                    Las líneas de código siguientes establecen las propiedades <code>username</code>, <code>password</code>, y 
                    <code>url</code>  para que se pueda obtener una conexión usando la clase <code>DriverManager</code>. 
                    (Encontrará la URL JDBC a establecer como el valor para la propiedad <code>url</code> en la documentación de su 
                    controlador JDBC).
                </p>
                <div class="codeblock">
                    <pre>
public void setConnectionProperties(
    String username, String password) {
    crs.setUsername(username);
    crs.setPassword(password);
    crs.setUrl("jdbc:mySubprotocol:mySubname");
    // ...
                    </pre>
                </div>
                <p>
                    Otra propiedad que debe establecer es la propiedad <code>command</code>. En la implementación de referencia, 
                    los datos se leen en un objeto <code>RowSet</code> desde un objeto <code>ResultSet</code>. La consulta que 
                    produce el objeto <code>ResultSet</code> es el valor para la propiedad <code>command</code>. Por ejemplo, la 
                    siguiente línea de código establece la propiedad <code>command</code> con una consulta que produce un objeto 
                    <code>ResultSet</code> conteniendo todos los datos en la tabla <code>MERCH_INVENTORY</code>:
                </p>
                <div class="codeblock">
                    <pre>
crs.setCommand("select * from MERCH_INVENTORY");
                    </pre>
                </div>
                <h3>
                    <a id="setting-key-columns">Establecer Columnas Clave</a>
                </h3>
                <p>
                    Si va a hacer cualquier actualización al objeto <code>crs</code> y quiere que esas actualizaciones se salven en 
                    la base de datos, debe establecer una pieza más de información: las columnas clave. Las columnas clave
                    son esencialmente lo mismo que una clave primaria porque indican una o más columnas que identifican de forma 
                    única una fila. La diferencia es que una clave primaria se establece en una tabla en la base de datos, mientras 
                    que las columnas clave se establecen en un objeto <code>RowSet</code> particular. Las siguientes líneas de 
                    código establecen las columnas clave para <code>crs</code> a la primera columna:
                </p>
                <div class="codeblock">
                    <pre>
int [] keys = {1};
crs.setKeyColumns(keys);
                    </pre>
                </div>
                <p>
                    La primera columna en la tabla <code>MERCH_INVENTORY</code> es <code>ITEM_ID</code>. Puede servir como columna 
                    clave porque cada identificador de artículo es diferente, y por lo tanto, identifica de forma única una fila y 
                    sólo una fila en la tabla <code>MERCH_INVENTORY</code>. Además, esta columna se especifica como clave primaria 
                    en la definición de la tabla <code>MERCH_INVENTORY</code>. El método <code>setKeyColumns</code> toma un vector 
                    para tener en cuenta el hecho de que puede ser necesarias dos o más columnas para identificar una fila de forma 
                    única.
                </p>
                <p>
                    Como punto de interés, el método <code>setKeyColumns</code> no establece un valor para una propiedad. En este 
                    caso, establece el valor para el campo <code>keyCols</code>. Las columnas clave son usadas internamente, así que 
                    después de establecerlas, no hace nada más con ellas. Verá cómo y cuándo se usan las columnas clave en la 
                    sección <a href="#syncresolver">Usar Objetos SyncResolver</a>.
                </p>
                <h2>
                    <a id="populating-cachedrowset-object">Llenado de Objetos CachedRowSet</a>
                </h2>
                <p>
                    Llenar un objeto <code>RowSet</code> desconectado implica más trabajo que llenar un objeto <code>RowSet</code> 
                    conectado. Afortunadamente, el trabajo extra se hace en segundo plano. Después de que ha hecho el trabajo 
                    preliminar para configurar el objeto <code>CachedRowSet</code> <code>crs</code>, la siguiente línea de código 
                    llena <code>crs</code>:
                </p>
                <div class="codeblock">
                    <pre>
crs.execute();
                    </pre>
                </div>
                <p>
                    Los datos en <code>crs</code> son los datos en el objeto <code>ResultSet</code> producido al ejecutar la 
                    consulta en la propiedad <code>command</code>.
                </p>
                <p>
                    Lo que es diferente es que la implementación de <code>CachedRowSet</code> para el método <code>execute</code> 
                    hace mucho más que la implementación de <code>JdbcRowSet</code>. O más correctamente, el lector del objeto 
                    <code>CachedRowSet</code>, al que el método <code>execute</code> delega sus tareas, hace mucho más.
                </p>
                <p>
                    Cada objeto <code>RowSet</code> desconectado tiene un objeto <code>SyncProvider</code> asignado, y este objeto 
                    <code>SyncProvider</code> es el que proporciona el <em>lector</em> del objeto <code>RowSet</code> (un objeto 
                    <code>RowSetReader</code>). Cuando se creó el objeto <code>crs</code>, fue usado como el constructor 
                    predeterminado <code>CachedRowSetImpl</code>, el cual, además de establecer los valores predeterminados para 
                    las propiedades, asigna una instancia de la implementación <code>RIOptimisticProvider</code> como objeto 
                    <code>SyncProvider</code> predeterminado.
                </p>
                <h2>
                    <a id="reader">Qué Hace Reader</a>
                </h2>
                <p>
                    Cuando una aplicación llama al método <code>execute</code>, el lector de un objeto <code>RowSet</code> 
                    desconectado trabaja entre bastidores para llenar el objeto <code>RowSet</code> con datos. Un objeto 
                    <code>CachedRowSet</code> recién creado no está conectado a una fuente de datos y, por lo tanto, debe obtener 
                    una conexión a esa fuente de datos para obtener datos de ella. La implementación de referencia del objeto 
                    <code>SyncProvider</code> (<code>RIOptimisticProvider</code>) proporciona un lector que obtiene una conexión 
                    usando los valores establecidos para el nombre de usuario, contraseña, y la URL de JDBC o el nombre de la 
                    fuente de datos, lo que se haya establecido más recientemente. Después el lector ejecuta la consulta 
                    establecida para <code>command</code>. Lee los datos en el objeto <code>ResultSet</code> producido por la 
                    consulta, y llena  el objeto <code>CachedRowSet</code> con esos datos. Finalmente, el lector cierra la conexión.
                </p>
                <h2>
                    <a id="updating-cachedrowset-object">Actualizar Objetos CachedRowSet</a>
                </h2>
                <p>
                    En el escenario de Coffee Break, el propietario quiere agilizar las operaciones. El propietario decide que los
                    empleados del almacén ingresen el inventario directamente en una PDA (asistente digital personal), evitando así 
                    el proceso propenso a errores de que una segunda persona realice la entrada de datos. Un objeto 
                    <code>CachedRowSet</code> es ideal en esta situación porque es ligero, serializable, y puede ser actualizado 
                    sin una conexión a la fuente de datos.
                </p>
                <p>
                    El propietario hará que el equipo de desarrollo de la aplicación cree una herramienta IGU para la PDA que 
                    los empleados del almacén usarán para introducir los datos de inventario. La oficina central creará un objeto 
                    <code>CachedRowSet</code> llenado con la tabla que muestra el inventario actual y lo enviará a través de 
                    Internet a las PDAs. Cuando un empleado del almacén introduce los datos usando la herramienta IGU, la 
                    herramienta agrega cada entrada a un vector, el cual el objeto <code>CachedRowSet</code> usará para realizar 
                    las actualizaciones en el segundo plano. Una vez completado el inventario, las PDAs envían sus nuevos datos a la 
                    sede, donde los datos se cargan en el servidor principal.
                </p>
                <p>
                    Esta sección cubre los temas siguientes:
                </p>
                <ul>
                    <li><a href="#updating-column-value">Actualizar Valores de Columna</a></li>
                    <li><a href="#inserting-and-deleting-rows">Insertar y Borrar Filas</a></li>
                </ul>
                <h3>
                    <a id="updating-column-value">Actualizar Valores de Columna</a>
                </h3>
                <p>
                    Actualizar datos en un objeto <code>CachedRowSet</code> es simplemente lo mismo que actualizar datos en un 
                    objeto <code>JdbcRowSet</code>. Por ejemplo, el fragmento de código siguiente de 
                    <code><a href="gettingstarted.html">CachedRowSetSample.java</a></code> incrementa el valor en la columna 
                    <code>QUAN</code> en 1 en la fila cuya columna <code>ITEM_ID</code> tiene un identificador de artículo de 
                    <code>12345</code>:
                </p>
                <div class="codeblock">
                    <pre>
while (crs.next()) {
    System.out.println(
        "Found item " + crs.getInt("ITEM_ID") +
        ": " + crs.getString("ITEM_NAME"));
    if (crs.getInt("ITEM_ID") == 1235) {
        int currentQuantity = crs.getInt("QUAN") + 1;
        System.out.println("Updating quantity to " +
          currentQuantity);
        crs.updateInt("QUAN", currentQuantity + 1);
        crs.updateRow();
        // Synchronizing the row
        // back to the DB
        crs.acceptChanges(con);
    }
                    </pre>
                </div>
                <h3>
                    <a id="inserting-and-deleting-rows">Insertar y Borrar Filas</a>
                </h3>
                <p>
                    Al igual que con la actualización de un valor de columna, el código para insertar y eliminar filas en un objeto 
                    <code>CachedRowSet</code> es el mismo que para un objeto <code>JdbcRowSet</code>.
                </p>
                <p>
                    El extracto siguiente de <code><a href="gettingstarted.html">CachedRowSetSample.java</a></code> inserta una fila 
                    nueva dentro del objeto <code>CachedRowSet</code> <code>crs</code>:
                </p>
                <div class="codeblock">
                    <pre>
crs.moveToInsertRow();
crs.updateInt("ITEM_ID", newItemId);
crs.updateString("ITEM_NAME", "TableCloth");
crs.updateInt("SUP_ID", 927);
crs.updateInt("QUAN", 14);
Calendar timeStamp;
timeStamp = new GregorianCalendar();
timeStamp.set(2006, 4, 1);
crs.updateTimestamp(
    "DATE_VAL",
    new Timestamp(timeStamp.getTimeInMillis()));
crs.insertRow();
crs.moveToCurrentRow();
                    </pre>
                </div>
                <p>
                    Si las oficinas centrales ha decido dejar de almacenar un artículo en particular, probablemente eliminaría la 
                    fila correspondiente a ese café. Sin embargo, en el escenario, un empleado de almacén usando una PDA también 
                    tiene la capacidad de eliminarlo. El fragmento de código siguiente encuentra la fila donde el valor en la 
                    columna <code>ITEM_ID</code> es <code>12345</code> y la borra del <code>CachedRowSet</code> <code>crs</code>:
                </p>
                <div class="codeblock">
                    <pre>
while (crs.next()) {
    if (crs.getInt("ITEM_ID") == 12345) {
        crs.deleteRow();
        break;
    }
}
                    </pre>
                </div>
                <h2>
                    <a id="updating-data-source">Actualizar Fuentes de Datos</a>
                </h2>
                <p>
                    Existe una gran diferencia entre realizar cambios a un objeto <code>JdbcRowSet</code> y hacer cambios a un 
                    objeto <code>CachedRowSet</code>. Debido a que el objeto <code>JdbcRowSet</code> está conectado a su fuente de 
                    datos, los métodos <code>updateRow</code>, <code>insertRow</code>, y <code>deleteRow</code> pueden actualizar 
                    tanto el objeto <code>JdbcRowSet</code> como la fuente de datos. En el caso de un objeto <code>RowSet</code> 
                    desconectado, sin embargo, estos métodos actualizan los datos almacenados en la memoria del objeto 
                    <code>CachedRowSet</code> pero no pueden afectar a la fuente de datos. Un objeto <code>RowSet</code> 
                    desconectado debe llamar al método <code>acceptChanges</code> para salvar sus cambios a la fuente de datos. En 
                    el escenario del inventario, de vuelta en las oficinas centrales, una aplicación llamará al método 
                    <code>acceptChanges</code> para actualizar la base de datos con los nuevos valores para la columna 
                    <code>QUAN</code>.
                </p>
                <div class="codeblock">
                    <pre>
crs.acceptChanges();
                    </pre>
                </div>
                <h2>
                    <a id="writer">Qué Hace Writer</a>
                </h2>
                <p>
                    Como el método <code>execute</code>, el método <code>acceptChanges</code> hace su trabajo de manera invisible. 
                    Mientras que el método <code>execute</code> delega su trabajo al lector del objeto <code>RowSet</code>, el 
                    método <code>acceptChanges</code> delega sus tareas al escritor del objeto <code>RowSet</code>. En segundo 
                    plano, el escritor abre una conexión a la base de datos, actualiza la base de datos con los cambios hechos al 
                    objeto <code>RowSet</code>, y después cierra la conexión.
                </p>
                <h3>
                    Usar la Implementación Predeterminada
                </h3>
                <p>
                    La dificultad es que puede surgir un <i>conflicto</i>. Un conflicto es una situación en la cual otra parte ha 
                    actualizado un valor en la base de datos que corresponde a un valor que fue actualizado en un objeto 
                    <code>RowSet</code>. ¿Qué valor deberá persistir en la base de datos? Lo que hace el escritor cuando hay un 
                    conflicto depende de cómo se implemente, y hay muchas posibilidades. En un extremo del espectro, el escritor ni 
                    siquiera busca conflictos y simplemente escribe todos los cambios en la base de datos. Este es el caso con la 
                    implementación <code>RIXMLProvider</code>, que se usa en el objeto <code>WebRowSet</code>. En el otro extremo, 
                    el escritor se asegura de que no hay conflictos estableciendo bloqueos en la base de datos que evita a otros de 
                    hacer cambios.
                </p>
                <p>
                    El escritor para el objeto <code>crs</code> es el proporcionado por la implementación predeterminada de 
                    <code>SyncProvider</code>, <code>RIOptimisticProvider</code>. La implementación 
                    <code>RIOPtimisticProvider</code> toma su nombre del hecho de que usa un modelo de concurrencia optimista. Este 
                    modelo asume de que habrá pocos conflictos, si hay alguno, y por lo tanto no establece bloqueos en la base de 
                    datos. El escritor comprueba si hay algún conflicto y, si no lo hay, escribe los cambios realizados en el 
                    objeto <code>crs</code> en la base de datos, y esos cambios se vuelven persistentes. Si hay algún conflicto, lo 
                    predeterminado es no escribir los nuevos valores de <code>RowSet</code> en la base de datos.
                </p>
                <p>
                    En el escenario, el comportamiento predeterminado funciona muy bien. Debido a que es probable que nadie en la 
                    oficina central cambie el valor en la columna <code>QUAN</code> de <code>COF_INVENTORY</code>, no habrá 
                    conflictos. Como resultado, los valores introducidos en el objeto <code>crs</code> en el almacén serán escritos 
                    en la base de datos y, por lo tanto, serán persistentes, que es el resultado deseado.
                </p>
                <h2>
                    <a id="syncresolver">Usar Objetos SyncResolver</a>
                </h2>
                <p>
                    En otras situaciones, sin embargo, es posible que existan conflictos. Para adaptarse a estas situaciones, la 
                    implementación <code>RIOPtimisticProvider</code> proporciona una opción que le permite ver los valores en 
                    conflicto y decidir cuáles deberian ser persistentes. Esta opción es el uso de un objeto 
                    <code>SyncResolver</code>.
                </p>
                <p>
                    Cuando el escritor ha finalizado de buscar conflictos y ha encontrado uno o más, crea un objeto 
                    <code>SyncResolver</code> conteniendo los valores de base de datos que causaron los conflictos. A continuación, 
                    el método <code>acceptChanges</code> lanza un objeto <code>SyncProviderException</code>, el cual puede capturar 
                    una aplicación y usar para recuperar el objeto <code>SyncResolver</code>. Las siguientes líneas de código 
                    recuperan el objeto <code>SyncResolver</code> <code>resolver</code>:
                </p>
                <div class="codeblock">
                    <pre>
try {
    crs.acceptChanges();
} catch (SyncProviderException spe) {
    SyncResolver resolver = spe.getSyncResolver();
}
                    </pre>
                </div>
                <p>
                    El objeto <code>resolver</code> es un objeto <code>RowSet</code> que replica el objeto <code>crs</code> excepto 
                    que contiene sólo los valores en la base de datos que causaron un conflicito. Todas los otros valores de 
                    columna son nulos.
                </p>
                <p>
                    Con el objeto <code>resolver</code>, puede recorrer sus filas para localizar los valores que no son nulos y, 
                    por lo tanto, son valores que causaron conflicto. Luego, puede ubicar el valor en la misma posición en el 
                    objeto <code>crs</code> y compararlos. El siguiente fragmento de código recupera <code>resolver</code> y usa el 
                    método <code>nextConflict</code> de <code>SyncResolver</code> para iterar a través de las filas que tienen 
                    valores conflictivos. El objeto <code>resolver</code> obtiene el estado de cada valor conflictivo, y si este es 
                    <code>UPDATE_ROW_CONFLICT</code>, significando que el <code>crs</code> estuvo intentando una actualización 
                    cuando ocurrió el conflicto, el objeto <code>resolver</code> obtiene el número de fila de ese valor. Entonces 
                    el código mueve el cursor para el objeto <code>crs</code> a la misma fila. Después, el código encuentra la 
                    columna en esa fila del objeto <code>resolver</code> que contiene un valor conflictivo, el cual será un valor 
                    que no es nulo. Después de recuperar el valor en esa columna de los objetos <code>resolver</code> y 
                    <code>crs</code>, puede comparar los dos y decidir cuál desea que sea persistente. Finalmente, el código 
                    establece el valor en el objeto <code>crs</code> y en la base de datos usando el método 
                    <code>setResolvedValue</code>, como se muestra en el código siguiente:
                </p>
                <div class="codeblock">
                    <pre>
try {
    crs.acceptChanges();
} catch (SyncProviderException spe) {
    SyncResolver resolver = spe.getSyncResolver();
  
    // value in crs
    Object crsValue;
  
    // value in the SyncResolver object
    Object resolverValue; 
  
    // value to be persistent
    Object resolvedValue; 

    while (resolver.nextConflict()) {
        if (resolver.getStatus() ==
            SyncResolver.UPDATE_ROW_CONFLICT) {
            int row = resolver.getRow();
            crs.absolute(row);
            int colCount =
                crs.getMetaData().getColumnCount();
            for (int j = 1; j &lt;= colCount; j++) {
                if (resolver.getConflictValue(j)
                    != null) {
                    crsValue = crs.getObject(j);
                    resolverValue = 
                        resolver.getConflictValue(j);

                    // ...
                    // compare crsValue and
                    // resolverValue to
                    // determine the value to be
                    // persistent

                    resolvedValue = crsValue;
                    resolver.setResolvedValue(
                        j, resolvedValue);
                }
            }
        }
    }
}
                    </pre>
                </div>
                <h2>
                    <a id="notifying-listeners">Notificar a los Listeners</a>
                </h2>
                <p>
                    Ser un componente JavaBeans significa que un objeto <code>RowSet</code> puede notificar a otros componentes 
                    cuándo le pasan ciertas cosas. Por ejemplo, si los datos en un objeto <code>RowSet</code> cambian, el objeto 
                    <code>RowSet</code> puede notificar a las partes interesadas de ese cambio. Lo bueno de este mecanismo de 
                    notificación es que, como programador de aplicaciones, todo lo que tiene que hacer es agregar o eliminar los 
                    componentes que serán notificados.
                </p>
                <p>
                    Esta sección cubre los siguientes temas:
                </p>
                <ul>
                    <li><a href="#setting-up-listeners">Configurar Listeners</a></li>
                    <li><a href="#how-notification-works">Como Funciona la Notificación</a></li>
                </ul>
                <h3>
                    <a id="setting-up-listeners">Configurar Listeners</a>
                </h3>
                <p>
                    Un <i>listener</i> para un objeto <code>RowSet</code> es un componente que implementa los métodos siguientes 
                    de la interfaz <code>RowSetListener</code>:
                </p>
                <ul>
                    <li>
                        <code>cursorMoved</code>: Define lo que hará el listener, en todo caso, cuando se mueva el cursor en el 
                        objeto <code>RowSet</code>.
                    </li>
                    <li>
                        <code>rowChanged</code>: Define lo que hará el listener, en todo caso, cuando uno o más valores de columna 
                        en una fila hayan cambiado, se haya insertado una fila, o se haya eliminado una fila.
                        
                    </li>
                    <li>
                        <code>rowSetChanged</code>: Define lo que hará el listener, en todo caso, cuando el objeto 
                        <code>RowSet</code> haya sido llenado con nuevos datos.
                    </li>
                </ul>
                <p>
                    Un ejemplo de un componente que podría querer ser un listener es un objeto <code>BarGraph</code> que grafica 
                    los datos en un objeto <code>RowSet</code>. A medida que cambian los datos, el objeto <code>BarGraph</code> 
                    puede actualizarse para reflejar los nuevos datos.
                </p>
                <p>
                    Como programador de aplicaciones, la única cosa que debe hacer para aprovechar el mecanismo de notificación es 
                    agregar o eliminar listeners. La línea de código siguiente significa que cada vez que el cursor para los 
                    objetos <code>crs</code> se mueva, los valores en <code>crs</code> cambien, o <code>crs</code> como un todo 
                    obtiene nuevos datos, el objeto <code>BarGraph</code> <code>bar</code> será notificado:
                </p>
                <div class="codeblock">
                    <pre>
crs.addRowSetListener(bar);
                    </pre>
                </div>
                <p>
                    Puede también parar las notificaciones eliminando un listener, como está hecho en la línea de código siguiente:
                </p>
                <div class="codeblock">
                    <pre>
crs.removeRowSetListener(bar);
                    </pre>
                </div>
                <p>
                    Usando el escenario de Coffee Break, asuma que las oficinas centrales comprueban la base de datos 
                    periódicamente para obtener la última lista de precios para los cafés que vende en línea. En este caso, el 
                    listener es el objeto <code>PriceList</code> en el sitio web Coffee Break, que debe implementar los métodos de 
                    <code>RowSetListener</code> <code>cursorMoved</code>, <code>rowChanged</code>, y <code>rowSetChanged</code>. La 
                    implementación del método <code>cursorMoved</code> podría ser no hacer nada porque la posición del cursor no 
                    afecta al objeto <code>priceList</code>. Las implementaciones para los métodos <code>rowChanged</code> y
                    <code>rowSetChanged</code>, por otra parte, deben determinar qué cambios se han realizado y actualizar 
                    <code>priceList</code> en consecuencia.
                </p>
                <h3>
                    <a id="how-notification-works">Como Funciona la Notificación</a>
                </h3>
                <p>
                    En la implementación de referencia, los métodos que causan cualquier de los eventos <code>RowSet</code> 
                    automáticamente notifican a todos los listeners registrados. Por ejemplo, cualquier método que mueve el cursor 
                    también llama al método <code>cursorMoved</code> en cada uno de los listeners. Del mismo modo, el método 
                    <code>execute</code> llama al método <code>rowSetChanged</code> en todos los listeners, y 
                    <code>acceptChanges</code> llama a <code>rowChanged</code> en todos los listeners.
                </p>
                <h2>
                    <a id="sending-large-amounts-of-data">Enviar Grandes Cantidades de Datos</a>
                </h2>
                <p>
                    El código de ejemplo <a href="gettingstarted.html"><code>CachedRowSetSample.testCachedRowSet</code></a> 
                    demuestra cuantos datos pueden ser enviados en piezas más pequeñas.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="jdbcrowset.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="joinrowset.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Utilizando Objetos JdbcRowSet<br />
            <b>Página siguiente:</b> Utilizando Objetos JoinRowSet
        </div>
    </body>
</html> 
