<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Utilizando Objetos Estructurados (Los Tutoriales de Java&trade; &gt; Acceso a Bases de Datos JDBC(TM) &gt; 
            Lo Básico de JDBC)
        </title>
        <meta name="description" content="Este tutorial de Java JDBC describe cómo usar la IPA JDBC para crear, insertar, 
              actualizar y consultar tablas. También aprenderá cómo usar declaraciones simples y preparadas, procedimientos 
              almacenados y realizar transacciones" />
        <meta name="keywords" content="java programming, learn java, java sample code, jdbc, prepared statement, result set" />
        <meta charset="UTF-8"/>
        
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Lo Básico de JDBC</a></div>
                <div class="linkAHEAD"><a href="gettingstarted.html">Empezando</a></div>
                <div class="linkAHEAD"><a href="processingsqlstatements.html">Procesando Sentencias SQL con JDBC</a></div>
                <div class="linkAHEAD"><a href="connecting.html">Estableciendo una Conexión</a></div>
                <div class="linkAHEAD"><a href="sqldatasources.html">Conectando con Objetos DataSource</a></div>
                <div class="linkAHEAD"><a href="sqlexception.html">Manejando SQLExceptions</a></div>
                <div class="linkAHEAD"><a href="tables.html">Configurando Tablas</a></div>
                <div class="linkAHEAD"><a href="retrieving.html">Recuperando y Modificando Valores de los Result Sets</a></div>
                <div class="linkAHEAD"><a href="prepared.html">Usando Prepared Statements</a></div>
                <div class="linkAHEAD"><a href="transactions.html">Usando Transacciones</a></div>
                <div class="linkAHEAD"><a href="rowset.html">Usando Objetos RowSet</a></div>
                <div class="linkAHEAD"><a href="jdbcrowset.html">Utilizando Objetos JdbcRowSet</a></div>
                <div class="linkAHEAD"><a href="cachedrowset.html">Utilizando CachedRowSetObjects</a></div>
                <div class="linkAHEAD"><a href="joinrowset.html">Utilizando Objetos JoinRowSet</a></div>
                <div class="linkAHEAD"><a href="filteredrowset.html">Utilizando Objetos FilteredRowSet</a></div>
                <div class="linkAHEAD"><a href="webrowset.html">Utilizando Objetos WebRowSet</a></div>
                <div class="linkAHEAD"><a href="sqltypes.html">Usando Tipos de Datos Avanzados</a></div>
                <div class="linkAHEAD"><a href="blob.html">Utilizando Objetos Grandes</a></div>
                <div class="linkAHEAD"><a href="sqlxml.html">Utilizando Objetos SQLXML</a></div>
                <div class="linkAHEAD"><a href="array.html">Utilizando Objetos Array</a></div>
                <div class="linkAHEAD"><a href="distinct.html">Usando el Tipo de Datos DISTINCT</a></div>
                <div class="nolinkAHEAD">Utilizando Objetos Estructurados</div>
                <div class="linkAHEAD"><a href="sqlcustommapping.html">Usando Mapeados de Tipos Personalizados</a></div>
                <div class="linkAHEAD"><a href="sqldatalink.html">Utilizando Objetos Datalink</a></div>
                <div class="linkAHEAD"><a href="sqlrowid.html">Utilizando Objetos RowId</a></div>
                <div class="linkAHEAD"><a href="storedprocedures.html">Usando Procedimientos Almacenados</a></div>
                <div class="linkAHEAD"><a href="jdbcswing.html">Usando JDBC con una IPA de IGU</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Acceso a Bases de Datos JDBC(TM)<br />
                <b>Lección:</b> Lo Básico de JDBC
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Acceso a Bases de Datos JDBC(TM)</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Lo Básico de JDBC</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="distinct.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="sqlcustommapping.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Utilizando Objetos Estructurados</h1>
            </div>
            <div id="PageContent">
                <p>
                    <strong>Nota</strong>: MySQL y Java DB actualmnte no soporta tipos definidos por el usuario. Como consecuencia, 
                    no hay disponible un ejemplo en el tutorial de JDBC para demostrar las características descritas en esta 
                    sección.
                </p>
                <p>
                    Se cubren Los siguientes temas:
                </p>
                <ul>
                    <li>
                        <a href="#overview_structured">Resumen de Tipos Estructurados</a>
                    </li>
                    <li>
                        <a href="#using_distinct_in_structured">Usar el Tipo DISTINCT en Tipos Estructurados</a>
                    </li>
                    <li>
                        <a href="#references_structured">Usar Referencias a Tipos Estructurados</a>
                    </li>
                    <li>
                        <a href="#code_ref">Código de ejemplo para Crear Objetos SQL REF</a>
                    </li>
                    <li>
                        <a href="#udt_column_values">Usar Tipos Definidos por el Usuario como Valores de Columna</a>
                    </li>
                    <li>
                        <a href="#insert_udt">Insertar Tipos Definidos por el Usuario en Tablas</a>
                    </li>
                </ul>
                <h2>
                    <a id="overview_structured">Resumen de Tipos Estructurados</a>
                </h2>
                <p>
                    Los tipos estructurados de SQL y los tipos <code>DISTINCT</code> son los dos tipos de datos que un usuario 
                    puede definir en SQL. Ellos son a menudo referidos como UDTs (<b>Nota del Traductor:</b> tipos definidos por el 
                    usuario, user-defined types), y los crea con una sentencia de SQL <code>CREATE</code> <code>TYPE</code>.
                </p>
                <p>
                    Volviendo al ejemplo de The Coffee Break, suponga que el propietario ha tenido éxito más alla de todas las 
                    expectativas y ha ha estado expandiendo con nuevas sucursales. El propietario ha decido agregar una tabla 
                    <code>STORES</code> a la base de datos conteniendo información sobre cada establecimiento. <code>STORES</code> 
                    tendrá cuatro columnas:
                </p>
                <ul>
                    <li>
                        <code>STORE_NO</code> para cada número de identificación de la tienda
                    </li>
                    <li>
                        <code>LOCATION</code> para su dirección
                    </li>
                    <li>
                        <code>COF_TYPES</code> para los cafés que venden
                    </li>
                    <li>
                        <code>MGR</code> para el nombre del gestor de la tienda
                    </li>
                </ul>
                <p>
                    El propietario hace que la columna <code>LOCATION</code> sea de un tipo estructurado SQL, la columna 
                    <code>COF_TYPES</code> un <code>ARRAY</code> de SQL, y la columna <code>MGR</code> un 
                    <code>REF(MANAGER)</code>, con <code>MANAGER</code> siendo un tipo estructurado SQL.
                </p>
                <p>
                    La primera cosa que el propietario debe definir los nuevos tipos estructurados para la dirección y el gestor. 
                    Un tipo estructurado de SQL es similar a los tipos estructurados en el lenguaje de programación Java en que 
                    tiene miembros, llamados <em>atributos</em>, que pueden ser de cualquier tipo de datos. El propietario escribe 
                    la siguiente sentencia SQL para crear el nuevo tipo de datos <code>ADDRESS</code>:
                </p>
                <div class="codeblock">
                    <pre>
CREATE TYPE ADDRESS
(
    NUM INTEGER,
    STREET VARCHAR(40),
    CITY VARCHAR(40),
    STATE CHAR(2),
    ZIP CHAR(5)
);
                    </pre>
                </div>
                <p>
                    En esta sentencia, el tipo nuevo <code>ADDRESS</code> tien cinco atributos, los cuales son análogos a los 
                    campos en una clase Java. El atributo <code>NUM</code> es un <code>INTEGER</code>, el atributo 
                    <code>STREET</code> es un <code>VARCHAR(40)</code>, el atributo <code>CITY</code> es un 
                    <code>VARCHAR(40)</code>, el atributo <code>STATE</code> es un <code>CHAR(2)</code>, y el atributo 
                    <code>ZIP</code> es un <code>CHAR(5)</code>.
                </p>
                <p>
                    El siguiente extracto, en el que <code>con</code> es un objeto válido <code>Connection</code>, envía la 
                    definición de <code>ADDRESS</code> a la base de datos:
                </p>
                <div class="codeblock">
                    <pre>
String createAddress =
    "CREATE TYPE ADDRESS " +
    "(NUM INTEGER, STREET VARCHAR(40), " +
    "CITY VARCHAR(40), STATE CHAR(2), ZIP CHAR(5))";
Statement stmt = con.createStatement();
stmt.executeUpdate(createAddress);
                    </pre>
                </div>
                <p>
                    Ahora el tipo estructurado <code>ADDRESS</code> se registra con la base de datos como un tipo de datos, y el 
                    propietario puede usarlo como un tipo de datos para una columna de una tabla o un atributo de un tipo 
                    estructurado.
                </p>
                <h2>
                    <a id="using_distinct_in_structured">Usar el Tipo DISTINCT en Tipos Estructurados</a>
                </h2>
                <p>
                    Uno de los atributos que el propietario de The Coffee Break planea incluir en el nuevo tipo estructurado 
                    <code>MANAGER</code> es el número de teléfono del gestor. Debido a que el propietario listará siempre los 
                    números de teléfono como un número de 10 dígitos (para asegurar que incluyen el código de área) y nunca los 
                    manipulará como un número, el propietario decide definir un tipo nuevo llamado <code>PHONE_NO</code> que 
                    consiste de 10 caracteres. La definición SQL de este tipo de datos, el cual puede ser pensando como un tipo 
                    estructurado con un sólo atributo, se parece a esto:
                </p>
                <div class="codeblock">
                    <pre>
CREATE TYPE PHONE_NO AS CHAR(10);
                    </pre>
                </div>
                <p>
                    O, como se señaló anteriormente, para algunos controladores, la definición podría verse así:
                </p>
                <div class="codeblock">
                    <pre>
CREATE DISTINCT TYPE PHONE_NO AS CHAR(10);
                    </pre>
                </div>
                <p>
                    Un tipo <code>DISTINCT</code> se basa siempre en otro tipo de datos, el cual debe ser un tipo predefinido. En 
                    otras palabras, un tipo <code>DISTINCT</code> no puede basarse en un tipo definido por el usuario (UDT). Para 
                    recuperar o establecer un valor que es un tipo <code>DISTINCT</code>, use el método apropiadao para el tipo 
                    subyacente (el tipo en el cual se basa). Por ejemplo, para recuperar una instancia de <code>PHONE_NO</code>, el 
                    cual se basa en un tipo <code>CHAR</code>, usaría el método <code>getString</code> porque ese es el método para 
                    recuperar un <code>CHAR</code>.
                </p>
                <p>
                    Asumiendo que un valor del tipo <code>PHONE_NO</code> está en la cuarta columna de la fila actual del objeto 
                    <code><em>rs</em></code> de  tipo <code>ResultSet</code>, la siguiente línea de código lo recupera:
                </p>
                <div class="codeblock">
                    <pre>
String phoneNumber = rs.getString(4);
                    </pre>
                </div>
                <p>
                    Del mismo modo, la siguiente línea de código establece un parámetro de entrada que tiene el tipo 
                    <code>PHONE_NO</code> para una sentencia prearar que está siendo enviada a la base de datos:
                </p>
                <div class="codeblock">
                    <pre>
pstmt.setString(1, phoneNumber);
                    </pre>
                </div>
                <p>
                    Añadiendo al fragmento del código anterior, la definición de <code>PHONE_NO</code> será enviada a la base de 
                    datos con la siguiente línea de código:
                </p>
                <div class="codeblock">
                    <pre>
stmt.executeUpdate(
    "CREATE TYPE PHONE_NO AS CHAR(10)");
                    </pre>
                </div>
                <p>
                    Después de registrar el tipo <code>PHONE_NO</code> con la base de datos, el propietario puede usarlo como tipo 
                    de columna en una tabla o com oun tipo de datos para un atributo en un tipo estructurado. La definición de 
                    <code>MANAGER</code> en la siguiente sentencia SQL usa <code>PHONE_NO</code> como el tipo de dato para el 
                    atributo <code>PHONE</code>:
                </p>
                <div class="codeblock">
                    <pre>
CREATE TYPE MANAGER
(
    MGR_ID INTEGER,
    LAST_NAME VARCHAR(40),
    FIRST_NAME VARCHAR(40),
    PHONE PHONE_NO
);
                    </pre>
                </div>
                <p>
                    Reusando <code><em>stmt</em></code>, definido previamente, el siguiente fragmento de código envía la definición 
                    del tipo estructurado <code>MANAGER</code> a la base de datos:
                </p>
                <div class="codeblock">
                    <pre>
  String createManager =
    "CREATE TYPE MANAGER " +
    "(MGR_ID INTEGER, LAST_NAME " +
    "VARCHAR(40), " +
    "FIRST_NAME VARCHAR(40), " +
    "PHONE PHONE_NO)";
  stmt.executeUpdate(createManager);
                    </pre>
                </div>
                <h2>
                    <a id="references_structured">Usar Referencias a Tipos Estructurados</a>
                </h2>
                <p>
                    El propietario de The Coffee Break ha creado tres nuevos tipos de datos usados como tipos de columna o tipos de 
                    atributo en la base de datos: los tipos estructurados <code>LOCATION</code> y <code>MANAGER</code>, y el tipo 
                    <code>DISTINCT</code> <code>PHONE_NO</code>. El empresario ha usado <code>PHONE_NO</code> como el tipo para el 
                    atributo <code>PHONE</code> en el nuevo tipo <code>MANAGER</code>, y <code>ADDRESS</code> como el tipo de datos 
                    para la columna <code>LOCATION</code> en la tabla <code>STORES</code>. El tipo <code>MANAGER</code> podría ser 
                    usado como el tipo para la columna <code>MGR</code>, pero en su lugar el empresario prefiere usar el tipo 
                    <code>REF(MANAGER)</code> porque el empresario a menudo tiene a una persona gestionando dos o tres tiendas. 
                    Usando <code>REF(MANAGER)</code> como un tipo de columna evita repetir todos los datos para 
                    <code>MANAGER</code>  cuando una persona gestiona más de una tienda.
                </p>
                <p>
                    Con el tipo estructurado <code>MANAGER</code> ya creado, el propietario puede ahora crear una tabla que 
                    contiene instancias de <code>MANAGER</code> que pueden ser referenciadas. Una referencia a una instancia de 
                    <code>MANAGER</code> tendrá el tipo <code>REF(MANAGER)</code>. Un <code>REF</code> de SQL no es más que un 
                    puntero lógico a un tipo estructurado, así que una instancia de <code>REF(MANAGER)</code> sirve como un 
                    puntero lógico a una instancia de <code>MANAGER</code>.
                </p>
                <p>
                    Ya que un valor de tipo SQL <code>REF</code> necesita estar permanentemente asociado con la instancia del 
                    tipo estructurado que referencia, es almacenado en una tabla especial junto con su instancia asociada. Un 
                    programador no crea tipos <code>REF</code> directamente sino que crea la tabla que almacenará instancias de un 
                    tipo estructurado particular al que se puede hacer referencia. Cada tipo estructurado que va a ser referenciado 
                    tendrá su propia tabla. Cuando inserta una instancia de tipo estructurado en la tabla, la base de datos 
                    automáticamente crea una instancia <code>REF</code>. Por ejemplo, para contener instancias de 
                    <code>MANAGER</code> que pueden ser referenciadas, el propietario creó la siguiente tabla especial usando SQL:
                </p>
                <div class="codeblock">
                    <pre>
  CREATE TABLE MANAGERS OF MANAGER
  (OID REF(MANAGER)
  VALUES ARE SYSTEM GENERATED);
                    </pre>
                </div>
                <p>
                    Esta sentencia crea una tabla con la columna especial <code>OID</code>,  que almacena valores del tipo 
                    <code>REF(MANAGER)</code>. Cada vez que una instancia de <code>REF(MANAGER)</code> se inserta en la tabla, la 
                    base de datos generará una instancia de <code>REF(MANAGER)</code> y la almacena en la columna <code>OID</code>. 
                    Implícitamente, una columna adicional almacena cada atributo de <code>MANAGER</code> que también se ha sido 
                    insertado en la tabla. Por ejemplo, el fragmento de código siguiente muestra cómo el empresario creó tres 
                    instancias del tipo estructurado <code>MANAGER</code> para representar tres gestores:
                </p>
                <div class="codeblock">
                    <pre>
  INSERT INTO MANAGERS (
    MGR_ID, LAST_NAME,
    FIRST_NAME, PHONE) VALUES
  (
    000001,
    'MONTOYA',
    'ALFREDO',
    '8317225600'
  );

  INSERT INTO MANAGERS (
    MGR_ID, LAST_NAME,
    FIRST_NAME, PHONE) VALUES
  (
    000002,
    'HASKINS',
    'MARGARET',
    '4084355600'
  );

  INSERT INTO MANAGERS (
    MGR_ID, LAST_NAME,
    FIRST_NAME, PHONE) VALUES
  (
    000003,
    'CHEN',
    'HELEN',
    '4153785600'
   );
                    </pre>
                </div>
                <p>
                    La tabla <code>MANAGERS</code> tendrá ahora tres filas, una fila por cada gestor insertado hasta ahora. La 
                    columna <code>OID</code> contendrá tres identificadores únicos de objeto del tipo <code>REF(MANAGER)</code>, 
                    uno para cada instancia de <code>MANAGER</code>. Estos identificadores de objeto fueron generados 
                    automáticamente por la base de datos y serán permanentemente almacenados en la tabla <code>MANAGERS</code>. 
                    Implícitamente, una columna adicional almacena cada atributo de <code>MANAGER</code>. Por ejemplo, en la tabla 
                    <code>MANAGERS</code>, una fila contiene un <code>REF(MANAGER)</code> que referencia a Alfredo Montoya, otra 
                    fila contiene un <code>REF(MANAGER)</code> que referencia Margaret Haskins, y una tercera fila contiene un 
                    <code>REF(MANAGER)</code> que referencia a Helen Chen.
                </p>
                <p>
                    Para acceder a una instancia <code>REF(MANAGER)</code>, lo selecciona de su tabla. Por ejemplo, el propietario
                    recuperó la referencia a Alfredo Montoya, cuyo número ID es 000001, con el fragmento de código siguiente:
                </p>
                <div class="codeblock">
                    <pre>
  String selectMgr =
    "SELECT OID FROM MANAGERS " +
    "WHERE MGR_ID = 000001";
  ResultSet rs = stmt.executeQuery(selectMgr);
  rs.next();
  Ref manager = rs.getRef("OID");
                    </pre>
                </div>
                <p>
                    Ahora la variable <code><em>manager</em></code> puede usarse como un valor de columna que referencia a 
                    Alfredo Montoya.
                </p>
                <h2>
                    <a id="code_ref">Código de ejemplo para Crear Objetos SQL REF</a>
                </h2>
                <p>
                    El siguiente código de ejemplo crea la tabla <code>MANAGERS</code>, una tabla de instancias del tipo 
                    estructurado <code>MANAGER</code> que puede ser referenciado, e inserta tres instancias de <code>MANAGER</code> 
                    en la tabla. La columna <code>OID</code> en esta tabla almacenará instancias de <code>REF(MANAGER)</code>. 
                    Después que se ejecute este código, la tabla <code>MANAGERS</code> tendrá una fila para cada uno de los tres 
                    objetos <code>MANAGER</code> insertados, y el valor en la columna <code>OID</code> será el tipo 
                    <code>REF(MANAGER)</code> que identifica la instancia de <code>MANAGER</code> almacenada en esa fila.
                </p>
                <div class="codeblock">
                    <pre>
package com.oracle.tutorial.jdbc;

import java.sql.*;

public class CreateRef {

    public static void main(String args[]) {

        JDBCTutorialUtilities myJDBCTutorialUtilities;
        Connection myConnection = null;

        if (args[0] == null) {
            System.err.println("Properties file not specified " +
                               "at command line");
            return;
        } else {
            try {
                myJDBCTutorialUtilities = new JDBCTutorialUtilities(args[0]);
            } catch (Exception e) {
                System.err.println("Problem reading properties " +
                                   "file " + args[0]);
                e.printStackTrace();
                return;
            }
        }

        Connection con = null;
        Statement stmt = null;

        try {
            String createManagers =
                "CREATE TABLE " +
                "MANAGERS OF MANAGER " +
                "(OID REF(MANAGER) " +
                "VALUES ARE SYSTEM " +
                "GENERATED)";

            String insertManager1 =
                "INSERT INTO MANAGERS " +
                "(MGR_ID, LAST_NAME, " +
                "FIRST_NAME, PHONE) " +
                "VALUES " +
                "(000001, 'MONTOYA', " +
                "'ALFREDO', " +
                "'8317225600')";

            String insertManager2 =
                "INSERT INTO MANAGERS " +
                "(MGR_ID, LAST_NAME, " +
                "FIRST_NAME, PHONE) " +
                "VALUES " +
                "(000002, 'HASKINS', " +
                "'MARGARET', " +
                "'4084355600')";

            String insertManager3 =
                "INSERT INTO MANAGERS " +
                "(MGR_ID, LAST_NAME, " +
                "FIRST_NAME, PHONE) " +
                "VALUES " +
                "(000003, 'CHEN', 'HELEN', " +
                "'4153785600')";
  
            con = myJDBCTutorialUtilities.getConnection();
            con.setAutoCommit(false);

            stmt = con.createStatement();
            stmt.executeUpdate(createManagers);

            stmt.addBatch(insertManager1);
            stmt.addBatch(insertManager2);
            stmt.addBatch(insertManager3);
            int [] updateCounts = stmt.executeBatch();

            con.commit();

            System.out.println("Update count for:  ");
            for (int i = 0; i &lt; updateCounts.length; i++) {
                System.out.print("    command " + (i + 1) + " = ");
                System.out.println(updateCounts[i]);
            }
        } catch(BatchUpdateException b) {
            System.err.println("-----BatchUpdateException-----");
            System.err.println("Message:  " + b.getMessage());
            System.err.println("SQLState:  " + b.getSQLState());
            System.err.println("Vendor:  " + b.getErrorCode());
            System.err.print("Update counts for " + "successful commands:  ");
            int [] rowsUpdated = b.getUpdateCounts();
            for (int i = 0; i &lt; rowsUpdated.length; i++) {
                System.err.print(rowsUpdated[i] + "   ");
            }
            System.err.println("");
        } catch(SQLException ex) {
            System.err.println("------SQLException------");
            System.err.println("Error message:  " + ex.getMessage());
            System.err.println("SQLState:  " + ex.getSQLState());
            System.err.println("Vendor:  " + ex.getErrorCode());
        } finally {
            if (stmt != null) { stmt.close(); }
              JDBCTutorialUtilities.closeConnection(con);
        }
    }
}
                    </pre>
                </div>
                <h2>
                    <a id="udt_column_values">Usar Tipos Definidos por el Usuario como Valores de Columna</a>
                </h2>
                <p>
                    Nuestro empresario ahora tiene los UDTs requeridos para crear la tabla <code>STORES</code>. El tipo 
                    estructurado <code>ADDRESS</code> es el tipo para la columna <code>LOCATION</code>, y el tipo 
                    <code>REF(MANAGER)</code> es el tipo para la columna <code>MGR</code>.
                </p>
                <p>
                    El UDT <code>COF_TYPES</code> se base en el tipo de datos SQL <code>ARRAY</code> y es el tipo para la columna 
                    <code>COF_TYPES</code>. La siguiente línea de código crea el tipo <code>COF_ARRAY</code> como un valor 
                    <code>ARRAY</code> con 10 elementos. El tipo base de <code>COF_ARRAY</code> es <code>VARCHAR(40)</code>.
                </p>
                <div class="codeblock">
                    <pre>
  CREATE TYPE COF_ARRAY AS ARRAY(10) OF VARCHAR(40);
                    </pre>
                </div>
                <p>
                    Con los nuevos tipos de datos definidos, la siguiente sentencia SQL crea la tabla <code>STORES</code>:
                </p>
                <div class="codeblock">
                    <pre>
  CREATE TABLE STORES
  (
    STORE_NO INTEGER,
    LOCATION ADDRESS,
    COF_TYPES COF_ARRAY,
    MGR REF(MANAGER)
  );
                    </pre>
                </div>
                <h2>
                    <a id="insert_udt">Insertar Tipos Definidos por el Usuario en Tablas</a>
                </h2>
                <p>
                    El siguiente fragmento de código inserta una fila en la tabla <code>STORES</code>, supliendo los valores para 
                    las columnas <code>STORE_NO</code>, <code>LOCATION</code>, <code>COF_TYPES</code>, y <code>MGR</code>,en ese 
                    orden:
                </p>
                <div class="codeblock">
                    <pre>
  INSERT INTO STORES VALUES
  (
    100001,
    ADDRESS(888, 'Main_Street',
      'Rancho_Alegre',
      'CA', '94049'),
    COF_ARRAY('Colombian', 'French_Roast',
      'Espresso', 'Colombian_Decaf',
      'French_Roast_Decaf'),
    SELECT OID FROM MANAGERS
      WHERE MGR_ID = 000001
  );
                    </pre>
                </div>
                <p>
                    Lo siguiente pasa por cada columna y el valor insertado en ella.
                </p>
                <div class="codeblock">
                    <pre>
  STORE_NO: 100001
                    </pre>
                </div>
                <p>
                    Esta columna es del tipo <code>INTEGER</code>,  y el número <code>100001</code> es un tipo 
                    <code>INTEGER</code>, similar a las entradas hechas antes en las tablas <code>COFFEES</code> y 
                    <code>SUPPLIERS</code>.
                </p>
                <div class="codeblock">
                    <pre>
  LOCATION: ADDRESS(888, 'Main_Street',
    'Rancho_Alegre', 'CA', '94049')
                    </pre>
                </div>
                <p>
                    El tipo para esta columna es el tipo estructurado <code>ADDRESS</code>, y este valor es el constructor para una 
                    instancia de <code>ADDRESS</code>. Cuando enviamos la definición de <code>ADDRESS</code> a la base de datos, 
                    una de las cosas que se hizo fue crear un constructor para el nuevo tipo. Los valores separados por comas en 
                    paréntesis son los valores de inicialización para los atributos del tipo <code>ADDRESS</code>, y deben aparecer 
                    en el mismo orden en el cual los atributos fueron listados en la definición del tipo <code>ADDRESS</code>. 
                    <code>888</code> es el valor para el atributo <code>NUM</code>, el cual es un valor <code>INTEGER</code>.
                    <code>"Main_Street"</code> es el valor para <code>STREET</code>, y <code>"Rancho_Alegre"</code> es el valor 
                    para <code>CITY</code>, con ambos atributos siendo del tipo <code>VARCHAR(40)</code>. El valor para el atributo 
                    <code>STATE</code> es <code>"CA"</code>, que es del tipo <code>CHAR(2)</code>, y el valor para el atributo 
                    <code>ZIP</code> es <code>"94049"</code>, que es del tipo <code>CHAR(5)</code>.
                </p>
                <div class="codeblock">
                    <pre>
  COF_TYPES: COF_ARRAY(
    'Colombian',
    'French_Roast',
    'Espresso',
    'Colombian_Decaf',
    'French_Roast_Decaf'),
                    </pre>
                </div>
                <p>
                    La columna <code>COF_TYPES</code> es del tipo <code>COF_ARRAY</code> con un tipo base de 
                    <code>VARCHAR(40)</code>, y los valores separados por comas entre paréntesis son los objetos 
                    <code>String</code> que son los elementos de la matriz. El propietario definió el tipo <code>COF_ARRAY</code> 
                    para que tuviera un máximo de 10 elementos. Esta matriz tiene 5 elementos porque el empresario suministró sólo 
                    5 objetos <code>String</code> para él.
                </p>
                <div class="codeblock">
                    <pre>
  MGR: SELECT OID FROM MANAGERS
    WHERE MGR_ID = 000001
                    </pre>
                </div>
                <p>
                    La columna <code>MGR</code> es del tipo <code>REF(MANAGER)</code>, lo cual significa que un valor en esta 
                    columna debe ser una referencia al tipo estructurado <code>MANAGER</code>. Todas las instancias de 
                    <code>MANAGER</code> son almacenadas en la tabla <code>MANAGERS</code>. Todas las instancias de 
                    <code>REF(MANAGER)</code> son también almacenadas en esta tabla, en la columna <code>OID</code>. El gestor para 
                    la tienda descrita en esta fila de la tabla es Alfredo Montoya, y su información se almacena en la instancia 
                    de <code>MANAGER</code> que tiene <code>100001</code> para el atributo <code>MGR_ID</code>. Para obtener la 
                    instancia <code>REF(MANAGER)</code> asociada con el objeto <code>MANAGER</code> para Alfredo Montoya, 
                    seleccione la columna <code>OID</code> que está en la fila donde <code>MGR_ID</code> es <code>100001</code> en 
                    la tabla <code>MANAGERS</code>. El valor que será almacenado en la columna <code>MGR</code> de la tabla 
                    <code>STORES</code> (el valor <code>REF(MANAGER)</code>) es el valor que la DBMS generó para identificar 
                    de forma única esta instancia del tipo estructurado <code>MANAGER</code>.
                </p>
                <p>
                    Envíe la declaración SQL anterior a la base de datos con el siguiente fragmento de código:
                </p>
                <div class="codeblock">
                    <pre>
  String insertMgr =
    "INSERT INTO STORES VALUES " +
    "(100001, " +
    "ADDRESS(888, 'Main_Street', " +
      "'Rancho_Alegre', 'CA', " +
      "'94049'), " +
    "COF_ARRAY('Colombian', " +
      "'French_Roast', 'Espresso', " +
      "'Colombian_Decaf', " +
      "'French_Roast_Decaf'}, " +
    "SELECT OID FROM MANAGERS " +
    "WHERE MGR_ID = 000001)";

  stmt.executeUpdate(insertMgr);
                    </pre>
                </div>
                <p>
                    Sin embargo, ya que va a enviar varias sentencias <code>INSERT INTO</code>, será más eficiente enviarlas todas 
                    juntas en una actualización por lotes, como en el siguiente código de ejemplo:
                </p>
                <div class="codeblock">
                    <pre>
package com.oracle.tutorial.jdbc;

import java.sql.*;

public class InsertStores {
    public static void main(String args[]) {

        JDBCTutorialUtilities myJDBCTutorialUtilities;
        Connection myConnection = null;

        if (args[0] == null) {
            System.err.println(
                "Properties file " +
                "not specified " +
                "at command line");
            return;
        } else {
            try {
                myJDBCTutorialUtilities = new
                    JDBCTutorialUtilities(args[0]);
            } catch (Exception e) {
                System.err.println(
                    "Problem reading " +
                    "properties file " +
                    args[0]);
                e.printStackTrace();
                return;
            }
        }

        Connection con = null;
        Statement stmt = null;

        try {
            con = myJDBCTutorialUtilities.getConnection();
            con.setAutoCommit(false);

            stmt = con.createStatement();

            String insertStore1 =
                "INSERT INTO STORES VALUES (" +
                "100001, " +
                "ADDRESS(888, 'Main_Street', " +
                    "'Rancho_Alegre', 'CA', " +
                    "'94049'), " +
                "COF_ARRAY('Colombian', " +
                    "'French_Roast', " +
                    "'Espresso', " +
                    "'Colombian_Decaf', " +
                    "'French_Roast_Decaf'), " +
                "(SELECT OID FROM MANAGERS " +
                "WHERE MGR_ID = 000001))";

            stmt.addBatch(insertStore1);

            String insertStore2 =
                "INSERT INTO STORES VALUES (" +
                "100002, " +
                "ADDRESS(1560, 'Alder', " +
                    "'Ochos_Pinos', " +
                    "'CA', '94049'), " +
                "COF_ARRAY('Colombian', " +
                    "'French_Roast', " +
                    "'Espresso', " +
                    "'Colombian_Decaf', " +
                    "'French_Roast_Decaf', " +
                    "'Kona', 'Kona_Decaf'), " +
                "(SELECT OID FROM MANAGERS " +
                "WHERE MGR_ID = 000001))";

            stmt.addBatch(insertStore2);

            String insertStore3 =
                "INSERT INTO STORES VALUES (" +
                "100003, " +
                "ADDRESS(4344, " +
                    "'First_Street', " +
                    "'Verona', " +
                    "'CA', '94545'), " +
                "COF_ARRAY('Colombian', " +
                    "'French_Roast', " +
                    "'Espresso', " +
                    "'Colombian_Decaf', " +
                    "'French_Roast_Decaf', " +
                    "'Kona', 'Kona_Decaf'), " +
                "(SELECT OID FROM MANAGERS " +
                "WHERE MGR_ID = 000002))";

            stmt.addBatch(insertStore3);

            String insertStore4 =
                "INSERT INTO STORES VALUES (" +
                "100004, " +
                "ADDRESS(321, 'Sandy_Way', " +
                    "'La_Playa', " +
                    "'CA', '94544'), " +
                "COF_ARRAY('Colombian', " +
                    "'French_Roast', " +
                    "'Espresso', " +
                    "'Colombian_Decaf', " +
                    "'French_Roast_Decaf', " +
                    "'Kona', 'Kona_Decaf'), " +
                "(SELECT OID FROM MANAGERS " +
                "WHERE MGR_ID = 000002))";

            stmt.addBatch(insertStore4);

            String insertStore5 =
                "INSERT INTO STORES VALUES (" +
                "100005, " +
                "ADDRESS(1000, 'Clover_Road', " +
                    "'Happyville', " +
                    "'CA', '90566'), " +
                "COF_ARRAY('Colombian', " +
                    "'French_Roast', " +
                    "'Espresso', " + 
                    "'Colombian_Decaf', " +
                    "'French_Roast_Decaf'), " +
                "(SELECT OID FROM MANAGERS " +
                "WHERE MGR_ID = 000003))";

            stmt.addBatch(insertStore5);

            int [] updateCounts = stmt.executeBatch();

            ResultSet rs = stmt.executeQuery(
                "SELECT * FROM STORES");
            System.out.println("Table STORES after insertion:");
            System.out.println("STORE_NO   " + "LOCATION   " +
                "COF_TYPE   " + "MGR");

            while (rs.next()) {
                int storeNo = rs.getInt("STORE_NO");
                Struct location = (Struct)rs.getObject("LOCATION");
                Object[] locAttrs = location.getAttributes();
                Array coffeeTypes = rs.getArray("COF_TYPE");
                String[] cofTypes = (String[])coffeeTypes.getArray();

                Ref managerRef = rs.getRef("MGR");
                PreparedStatement pstmt = con.prepareStatement(
                    "SELECT MANAGER " +
                    "FROM MANAGERS " +
                    "WHERE OID = ?");
  
                pstmt.setRef(1, managerRef);
                ResultSet rs2 = pstmt.executeQuery();
                rs2.next();
                Struct manager = (Struct)rs2.getObject("MANAGER");
                Object[] manAttrs = manager.getAttributes();
      
                System.out.print(storeNo + "   ");
                System.out.print(
                    locAttrs[0] + " " +
                    locAttrs[1] + " " +
                    locAttrs[2] + ", " +
                    locAttrs[3] + " " +
                    locAttrs[4] + " ");

                for (int i = 0; i &lt; cofTypes.length; i++)
                    System.out.print( cofTypes[i] + " ");
          
                System.out.println(
                    manAttrs[1] + ", " +
                    manAttrs[2]);
        
                rs2.close();
                pstmt.close();
            }

            rs.close();

        } catch(BatchUpdateException b) {
            System.err.println("-----BatchUpdateException-----");
            System.err.println("SQLState:  " + b.getSQLState());
            System.err.println("Message:  " + b.getMessage());
            System.err.println("Vendor:  " + b.getErrorCode());
            System.err.print("Update counts:  ");
            int [] updateCounts = b.getUpdateCounts();

            for (int i = 0; i &lt; updateCounts.length; i++) {
                System.err.print(updateCounts[i] + "   ");
            }
            System.err.println("");

        } catch(SQLException ex) {
            System.err.println("SQLException: " + ex.getMessage());
            System.err.println("SQLState:  " + ex.getSQLState());
            System.err.println("Message:  " + ex.getMessage());
            System.err.println("Vendor:  " + ex.getErrorCode());
        } finally {
            if (stmt != null) { stmt.close(); }
                JDBCTutorialUtilities.closeConnection(con);
            }
        }
    }
}
                    </pre>
                </div>
            </div>
            <div class="NavBit">
                <a target="_top" href="distinct.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="sqlcustommapping.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Usando el Tipo de Datos DISTINCT<br />
            <b>Página siguiente:</b> Usando Mapeados de Tipos Personalizados
        </div>
    </body>
</html> 
