<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Recuperando y Modificando Valores de los Result Sets (Los Tutoriales de Java&trade; &gt; 
            Acceso a Bases de Datos JDBC(TM) &gt; Lo Básico de JDBC)
        </title>
        <meta name="description" content="Este tutorial de Java JDBC describe cómo usar la IPA JDBC para crear, insertar, 
              actualizar y consultar tablas. También aprenderá cómo usar declaraciones simples y preparadas, procedimientos 
              almacenados y realizar transacciones" />
        <meta name="keywords" content="java programming, learn java, java sample code, jdbc, prepared statement, result set" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Lo Básico de JDBC</a></div>
                <div class="linkAHEAD"><a href="gettingstarted.html">Empezando</a></div>
                <div class="linkAHEAD"><a href="processingsqlstatements.html">Procesando Sentencias SQL con JDBC</a></div>
                <div class="linkAHEAD"><a href="connecting.html">Estableciendo una Conexión</a></div>
                <div class="linkAHEAD"><a href="sqldatasources.html">Conectando con Objetos DataSource</a></div>
                <div class="linkAHEAD"><a href="sqlexception.html">Manejando SQLExceptions</a></div>
                <div class="linkAHEAD"><a href="tables.html">Configurando Tablas</a></div>
                <div class="nolinkAHEAD">Recuperando y Modificando Valores de los Result Sets</div>
                <div class="linkAHEAD"><a href="prepared.html">Usando Prepared Statements</a></div>
                <div class="linkAHEAD"><a href="transactions.html">Usando Transacciones</a></div>
                <div class="linkAHEAD"><a href="rowset.html">Usando Objetos RowSet</a></div>
                <div class="linkAHEAD"><a href="jdbcrowset.html">Utilizando Objetos JdbcRowSet</a></div>
                <div class="linkAHEAD"><a href="cachedrowset.html">Utilizando CachedRowSetObjects</a></div>
                <div class="linkAHEAD"><a href="joinrowset.html">Utilizando Objetos JoinRowSet</a></div>
                <div class="linkAHEAD"><a href="filteredrowset.html">Utilizando Objetos FilteredRowSet</a></div>
                <div class="linkAHEAD"><a href="webrowset.html">Utilizando Objetos WebRowSet</a></div>
                <div class="linkAHEAD"><a href="sqltypes.html">Usando Tipos de Datos Avanzados</a></div>
                <div class="linkAHEAD"><a href="blob.html">Utilizando Objetos Grandes</a></div>
                <div class="linkAHEAD"><a href="sqlxml.html">Utilizando Objetos SQLXML</a></div>
                <div class="linkAHEAD"><a href="array.html">Utilizando Objetos Array</a></div>
                <div class="linkAHEAD"><a href="distinct.html">Usando el Tipo de Datos DISTINCT</a></div>
                <div class="linkAHEAD"><a href="sqlstructured.html">Utilizando Objetos Estructurados</a></div>
                <div class="linkAHEAD"><a href="sqlcustommapping.html">Usando Mapeados de Tipos Personalizados</a></div>
                <div class="linkAHEAD"><a href="sqldatalink.html">Utilizando Objetos Datalink</a></div>
                <div class="linkAHEAD"><a href="sqlrowid.html">Utilizando Objetos RowId</a></div>
                <div class="linkAHEAD"><a href="storedprocedures.html">Usando Procedimientos Almacenados</a></div>
                <div class="linkAHEAD"><a href="jdbcswing.html">Usando JDBC con una IPA de IGU</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Acceso a Bases de Datos JDBC(TM)<br />
                <b>Lección:</b> Lo Básico de JDBC
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Acceso a Bases de Datos JDBC(TM)</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Lo Básico de JDBC</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="tables.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="prepared.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Recuperando y Modificando Valores de los Result Sets</h1>
            </div>
            <div id="PageContent">
                <p>
                    El método siguiente, <code><a href="gettingstarted.html">CoffeesTable.viewTable</a></code> genera los 
                    contenidos de la tabla <code>COFFEES</code>, y demuestra el uso de objetos <code>ResultSet</code> y cursores:
                </p>
                <div class="codeblock">
                    <pre>
public static void viewTable(Connection con, String dbName)
    throws SQLException {

    Statement stmt = null;
    String query =
        "select COF_NAME, SUP_ID, PRICE, " +
        "SALES, TOTAL " +
        "from " + dbName + ".COFFEES";

    try {
        stmt = con.createStatement();
        ResultSet rs = stmt.executeQuery(query);
        while (rs.next()) {
            String coffeeName = rs.getString("COF_NAME");
            int supplierID = rs.getInt("SUP_ID");
            float price = rs.getFloat("PRICE");
            int sales = rs.getInt("SALES");
            int total = rs.getInt("TOTAL");
            System.out.println(coffeeName + "\t" + supplierID +
                               "\t" + price + "\t" + sales +
                               "\t" + total);
        }
    } catch (SQLException e ) {
        JDBCTutorialUtilities.printSQLException(e);
    } finally {
        if (stmt != null) { stmt.close(); }
    }
}
                    </pre>
                </div>
                <p>
                    Un objeto <code>ResultSet</code> es una tabla de datos que representa un conjunto de resultado de una base de 
                    datos, el cual es usualmente generado al ejecutar una sentencia que consulta la base de datos. Por ejemplo, el 
                    método <code><a href="gettingstarted.html">CoffeeTables.viewTable</a></code> crea un <code>ResultSet</code>,
                    <code>rs</code>, cuando ejecuta la consulta a través del objeto <code>Statement</code>, <code>stmt</code>. Dese 
                    cuenta de que un objeto <code>ResultSet</code> puede crearse a través de cualquier objeto que implemente la 
                    interfaz <code>Statement</code>, incluyendo <code>PreparedStatement</code>, <code>CallableStatement</code>, y
                    <code>RowSet</code>.
                </p>
                <p>
                    Puede acceder a los datos en un objeto <code>ResultSet</code> a través de un cursor. Dese cuenta de que este 
                    cursor no es un cursor de base de datos. Este cursor es un puntero que apunta a una fila de datos en el 
                    <code>ResultSet</code>. Inicialmente, el cursor se posiciona antes de la primera fila. El método 
                    <code>ResultSet.next</code> mueve el cursor a la siguiente fila. Este método devuelve <code>false</code> si el 
                    cursor se posicionó después de la última fila. Este método llama repetidamente al método 
                    <code>ResultSet.next</code> dentro de un bucle <code>while</code> para iterar a través de todos los datos en el 
                    <code>ResultSet</code>.
                </p>
                <p>
                    Esta página cubre los temas siguientes:
                </p>
                <ul>
                    <li><a href="#rs_interface">La Interfaz ResultSet</a></li>
                    <li><a href="#retrieve_rs">Recuperar Valores de Columnas de Filas</a></li>
                    <li><a href="#cursors">Cursores</a></li>
                    <li><a href="#rs_update">Actualizar Filas en Objetos ResultSet</a></li>
                    <li><a href="#batch_updates">Usar Objetos Statement para Actualizaciones Por Lotes</a></li>
                    <li><a href="#rs_insert">Insertar Filas en Objetos ResultSet</a></li>
                </ul>
                <h2>
                    <a id="rs_interface">La Interfaz ResultSet</a>
                </h2>
                <p>
                    La interfaz <code>ResultSet</code> proporciona métodos para recuperar y manipular los resultados de las 
                    consultas ejecutadas, y los objetos <code>ResultSet</code> pueden tener diferentes funcionalidades y 
                    características. Estas características son tipo, concurrencia, y <em>permanencia</em> del cursor.
                </p>
                <h3>
                    Tipos de ResultSet
                </h3>
                <p>
                    El tipo de un objeto <code>ResultSet</code> determina el nivel de su funcionalidad en dos áreas: Las formas en 
                    las cuales el cursor puede ser manipulado, y cómo los cambios concurrentes realizados a la fuente de datos 
                    subyacente son reflejados por el objeto <code>ResultSet</code>.
                </p>
                <p>
                    La sensibilidad de un objeto <code>ResultSet</code> se determina por uno de tres tipos diferentes de 
                    <code>ResultSet</code>:
                </p>
                <ul>
                    <li>
                        <code>TYPE_FORWARD_ONLY</code>: El conjunto de resultados no se puede recorrer; su cursor sólo se mueve 
                        hacia delante, desde antes de la primera fila hasta después de la última fila. Las filas contenidas en el 
                        conjunto de resultados dependen de cómo la base de datos subyacente genera los resultados. Es decir, 
                        contiene las filas que satisfacen la consulta en el momento que se ejecuta la consulta o cuando se 
                        recuperan las filas.
                    </li>
                    <li>
                        <code>TYPE_SCROLL_INSENSITIVE</code>: El conjunto de resultados se puede recorrer; su cursor puede moverse 
                        tanto hacia adelante como hacia atrás en relación a su posición actual, y puede moverse a una posición 
                        absoluta. El conjunto de resultados es insensible a los cambios hechos a la fuente de datos subyacente 
                        mientras está abierto. Contiene las filas que satisfacen la consulta en el momento que se ejecuta la 
                        consulta o cuando se recuperan las filas.
                    </li>
                    <li>
                        <code>TYPE_SCROLL_SENSITIVE</code>: El conjunto de resultados se puede recorrer; Su cursor puede moverse 
                        tanto hacia adelante como hacia atrás en relación a su posición actual, y puede moverse a una posición 
                        absoluta. El conjunto de resultados refleja los cambios realizados a la fuente de datos subyacente mientras 
                        el conjunto de resultados permanece abierto.
                    </li>
                </ul>
                <p>
                    El tipo predeterminado de <code>ResultSet</code> es <code>TYPE_FORWARD_ONLY</code>.
                </p>
                <p>
                    <strong>Nota</strong>: No todas las bases de datos y controladores JDBC admiten todos los tipos de 
                    <code>ResultSet</code>. El método <code>DatabaseMetaData.supportsResultSetType</code> devuelve 
                    <code>true</code> si el tipo de <code>ResultSet</code> especificado es admitido y <code>false</code> en caso 
                    contrario.
                </p>
                <h3>
                    Concurrencia en el ResultSet
                </h3>
                <p>
                    La concurrencia de un objeto <code>ResultSet</code> determina qué nivel de funcionalidad de actualización se 
                    admite.
                </p>
                <p>
                    Hay dos niveles de concurrencia:
                </p>
                <ul>
                    <li>
                        <code>CONCUR_READ_ONLY</code>: El objeto <code>ResultSet</code> no puede actualizarse usando la interfaz de 
                        <code>ResultSet</code>.
                    </li>
                    <li>
                        <code>CONCUR_UPDATABLE</code>: El objeto <code>ResultSet</code> puede actualizarse usando la interfaz de 
                        <code>ResultSet</code>.
                    </li>
                </ul>
                <p>
                    La concurrencia predeterminada de un <code>ResultSet</code> es <code>CONCUR_READ_ONLY</code>.
                </p>
                <p>
                    <strong>Nota</strong>: No todos los controladores JDBC y bases de datos admiten la concurrencia. El método 
                    <code>DatabaseMetaData.supportsResultSetConcurrency</code> devuelve <code>true</code> si el nivel de 
                    concurrencia especificado es admitido por el controlador y <code>false</code> en caso contrario.
                </p>
                <p>
                    El método <code><a href="gettingstarted.html">CoffeesTable.modifyPrices</a></code> demuestra cómo usar un 
                    objeto<code>ResultSet</code> cuyo nivel de concurrencia es <code>CONCUR_UPDATABLE</code>.
                </p>
                <h3>
                    Permanencia del Cursor
                </h3>
                <p>
                    Llamar al método <code>Connection.commit</code> puede cerrar los objetos <code>ResultSet</code> que han sido 
                    creados durante la transacción actual. En algunos casos, sin embargo, esto puede que no sea el comportamiento 
                    deseado. La propiedad <em>holdability</em> del <code>ResultSet</code> da a la aplicación el control sobre si 
                    los objetos (cursores) <code>ResultSet</code> se cierran cuando se llama a confirmar.
                </p>
                <p>
                    Las constantes siguientes de <code>ResultSet</code> pueden ser suministradas a los métodos de 
                    <code>Connection</code> <code>createStatement</code>, <code>prepareStatement</code>, y <code>prepareCall</code>:
                </p>
                <ul>
                    <li>
                        <code>HOLD_CURSORS_OVER_COMMIT</code>: Los cursores del <code>ResultSet</code> no se cierran; son 
                        <em>retenibles</em>; se mantienen abiertos cuando se llama al método <code>commit</code>. Los cursores 
                        retenibles podrían ser ideales si su aplicación usa mayormente objetos <code>ResultSet</code> de sólo 
                        lectura.
                    </li>
                    <li>
                        <code>CLOSE_CURSORS_AT_COMMIT</code>: Los objetos (cursores) <code>ResultSet</code> se cierran cuando se 
                        llama al método <code>commit</code>. Cerrar los cursores cuando se llama a este método puede resultar en 
                        un mejor rendimiento para algunas aplicaciones.
                    </li>
                </ul>
                <p>
                    La permanencia predeterminada del curso varía dependiendo de su DBMS.
                </p>
                <p>
                    <strong>Nota</strong>: No todos los controladores JDBC y bases de datos soportan los cursores retenibles y
                    no retenibles. El método siguiente, <code>JDBCTutorialUtilities.cursorHoldabilitySupport</code>, muestra la 
                    permanencia predeterminada del curos de los objetos <code>ResultSet</code> y si se admiten 
                    <code>HOLD_CURSORS_OVER_COMMIT</code> y <code>CLOSE_CURSORS_AT_COMMIT</code>:
                </p>
                <div class="codeblock">
                    <pre>
public static void cursorHoldabilitySupport(Connection conn)
    throws SQLException {

    DatabaseMetaData dbMetaData = conn.getMetaData();
    System.out.println("ResultSet.HOLD_CURSORS_OVER_COMMIT = " +
        ResultSet.HOLD_CURSORS_OVER_COMMIT);

    System.out.println("ResultSet.CLOSE_CURSORS_AT_COMMIT = " +
        ResultSet.CLOSE_CURSORS_AT_COMMIT);

    System.out.println("Default cursor holdability: " +
        <strong>dbMetaData.getResultSetHoldability()</strong>);

    System.out.println("Supports HOLD_CURSORS_OVER_COMMIT? " +
        <strong>dbMetaData.supportsResultSetHoldability(
            ResultSet.HOLD_CURSORS_OVER_COMMIT)</strong>);

    System.out.println("Supports CLOSE_CURSORS_AT_COMMIT? " +
        <strong>dbMetaData.supportsResultSetHoldability(
            ResultSet.CLOSE_CURSORS_AT_COMMIT)</strong>);
}
                    </pre>
                </div>
                <h2>
                    <a id="retrieve_rs">Recuperar Valores de Columnas de Filas</a>
                </h2>
                <p>
                    La interfaz <code>ResultSet</code> declara métodos obtenedores (getter, en inglés) (por ejemplo, 
                    <code>getBoolean</code> y <code>getLong</code>) para recuperar valores de columna de la fila actual. Puede 
                    recuperar valores usando el número de índice de la columna o el alias o nombre de la columna. El índice de la 
                    columna es usualmente más eficiente. Las columnas se numeran desde 1. Para una portabilidad máxima, las 
                    columnas del conjunto de resultados dentro de cada fila se deben leer en el orden de izquierda a derecha, y 
                    cada columna debe ser leída sólo una vez.
                </p>
                <p>
                    Por ejemplo, el método siguiente, 
                    <code><a href="gettingstarted.html">CoffeesTable.alternateViewTable</a></code>, recupera los valores de las 
                    columnas por sus números:
                </p>
                <div class="codeblock">
                    <pre>
public static void alternateViewTable(Connection con)
    throws SQLException {

    Statement stmt = null;
    String query =
        "select COF_NAME, SUP_ID, PRICE, " +
        "SALES, TOTAL from COFFEES";

    try {
        stmt = con.createStatement();
        ResultSet rs = stmt.executeQuery(query);
        while (rs.next()) {
            String coffeeName = rs.getString(1);
            int supplierID = rs.getInt(2);
            float price = rs.getFloat(3);
            int sales = rs.getInt(4);
            int total = rs.getInt(5);
            System.out.println(coffeeName + "\t" + supplierID +
                               "\t" + price + "\t" + sales +
                               "\t" + total);
        }
    } catch (SQLException e ) {
        JDBCTutorialUtilities.printSQLException(e);
    } finally {
        if (stmt != null) { stmt.close(); }
    }
}
                    </pre>
                </div>
                <p>
                    Las cadenas usadas como entrada en los métodos obtenedores no distinguen entre mayúsculas y minúsculas. Cuando 
                    se llama a un método obtenedor con una cadena y más de una columna tiene el mismo alias o nombre que la cadena, 
                    el valor de la primera columna coincidente se devuelve. La opción para usar una cadena en lugar de un entero 
                    se diseñó para usarse cuando los alias de columna y nombres se usasen en la consulta SQL que generó el conjunto 
                    de resultados. Para columnas que <em>no</em> son explícitamente nombradas en la consulta (por ejemplo, 
                    <code>select * from COFFEES</code>) es mejor usar números de columna. Si se usan nombres de columna, el 
                    desarrollador debe garantizar que se refieran de forma exclusiva a las columnas deseadas mediante el uso de un 
                    alias de columna. Una alias de columna renombra de forma efectiva la columna de un conjunto de resultados. Para 
                    especifica un alias de columna, use la cláusula de SQL <code>AS</code> en la sentencia <code>SELECT</code>.
                </p>
                <p>
                    El método obtenedor del tipo apropiado recupera el valor en cada columna. Por ejemplo, en el método 
                    <code><a href="gettingstarted.html">CoffeeTables.viewTable</a></code>, la primera columna en cada fila del 
                    <code>ResultSet</code> <code>rs</code> es <code>COF_NAME</code>, el cual almacena una valor de tipo SQL 
                    <code>VARCHAR</code>. El método para recuperar un valor de tipo SQL <code>VARCHAR</code> es 
                    <code>getString</code>. La segunda columna en cada fila almacena un valor de tipo SQL <code>INTEGER</code>, y 
                    el método para recuperar valores de ese tipo es <code>getInt</code>.
                </p>
                <p>
                    Dese cuenta de que aunque se recomienda el método <code>getString</code>para recuperar los tipos SQL 
                    <code>CHAR</code> y <code>VARCHAR</code>, es posible recuperar cualquiera de los tipos SQL básicos con éste. 
                    Obtener todos los valores con <code>getString</code> puede ser muy útil, pero también tiene sus limitaciones. 
                    Por ejemplo, si se usó para recuperar un tipo numérico, <code>getString</code> convierte el valor numérico a un 
                    objeto <code>String</code> de Java, y el valor tiene que ser convertido de vuelta a un tipo numérico antes de 
                    que puede operarse como un número. En los casos donde el valor es tratado como una cadena de todos modos, no 
                    hay ningún inconveniente. Es más, si quiere que una aplicación recupere los valores de cualquier tipo estándar 
                    de SQL distinto de los tipos SQL3, use el método <code>getString</code>.
                </p>
                <h2>
                    <a id="cursors">Cursores</a>
                </h2>
                <p>
                    Como se mencionó previamente, puede acceder a los datos en un objeto <code>ResultSet</code> a través de un 
                    cursor, el cual apunta a una fila en el objeto <code>ResultSet</code>. Sin embargo, cuando un objeto 
                    <code>ResultSet</code> se crea por primera vez, el cursor está posicionado antes de la primera fila. El método 
                    <code><a href="gettingstarted.html">CoffeeTables.viewTable</a></code> mueve el cursor llamando al método 
                    <code>ResultSet.next</code>. Hay otros métodos disponibles para mover el cursor:
                </p>
                <ul>
                    <li>
                        <code>next</code>: Mueve el cursor hacia adelante una fila. Devuelve <code>true</code> si el cursor está 
                        ahora posicionado en una fila y <code>false</code> si el cursor se posicionó después de la última fila.
                    </li>
                    <li>
                        <code>previous</code>: Mueve el cursor hacia atrás una fila. Devuelve <code>true</code> si el cursor está 
                        ahora posicionado en una fila y <code>false</code> si el cursor está posicionado antes de la primera fila.
                    </li>
                    <li>
                        <code>first</code>: Mueve el cursor a la primera fila en el objeto <code>ResultSet</code>. Devuelve 
                        <code>true</code> si el cursor está ahora posicionado en la primera columna y <code>false</code> si el 
                        objeto no contiene ninguna fila.
                    </li>
                    <li>
                        <code>last:</code>: Mueve el cursor a la última fila en el objeto <code>ResultSet</code>. Devuelve 
                        <code>true</code> si el cursor está ahora posicionado en la última fila y <code>false</code> si el objeto 
                        <code>ResultSet</code> no contiene ninguna fila.
                    </li>
                    <li>
                        <code>beforeFirst</code>: Posiciona el cursor al principio del objeto <code>ResultSet</code>, antes de la 
                        primera fila. Si el objeto <code>ResultSet</code> no contiene filas, este método no tiene efecto.
                    </li>
                    <li>
                        <code>afterLast</code>: Posiciona el cursor al final del objeto <code>ResultSet</code>, después de la 
                        última fila. Si el objeto <code>ResultSet</code> no contiene filas, este método no tiene efecto.
                    </li>
                    <li>
                        <code>relative(int rows)</code>: Mueve el cursor de forma relativa a su posición actual.
                    </li>
                    <li>
                        <code>absolute(int row)</code>: Posiciona el cursor en la fila especifica por el parámetro <code>row</code>.
                    </li>
                </ul>
                <p>
                    Dese cuenta de que la sensibilidad predeterminada de un <code>ResultSet</code> es 
                    <code>TYPE_FORWARD_ONLY</code>, lo que significa que no puede ser desplazado; no puede llamar a ninguno de 
                    estos métodos que mueven el cursor, excepto <code>next</code>, si su <code>ResultSet</code> no puede ser 
                    recorrido. El método 
                    <code><a href="gettingstarted.html">CoffeesTable.modifyPrices</a></code>, descrito en la sección siguiente, 
                    le demuestra cómo puede mover el cursor de un <code>ResultSet</code>.
                </p>
                <h2>
                    <a id="rs_update">Actualizar Filas en Objetos ResultSet</a>
                </h2>
                <p>
                    No puede actualizar un objeto <code>ResultSet</code> predeterminado, y puede sólo mover su cursor hacia 
                    adelante. Sin embargo, puede crear objetos <code>ResultSet</code> que pueden ser recorridos (el cursor puede 
                    moverse hacia atrás o moverse a una posición absoluta) y ser actualizados.
                </p>
                <p>
                    El método siguiente, <code><a href="gettingstarted.html">CoffeesTable.modifyPrices</a></code>, multiplica la 
                    columna <code>PRICE</code> de cada fila por el argumento <code>percentage</code>:
                </p>
                <div class="codeblock">
                    <pre>
public void modifyPrices(float percentage) throws SQLException {

    Statement stmt = null;
    try {
        stmt = con.createStatement();
        stmt = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,
                   ResultSet.CONCUR_UPDATABLE);
        ResultSet uprs = stmt.executeQuery(
            "SELECT * FROM " + dbName + ".COFFEES");

        while (uprs.next()) {
            float f = uprs.getFloat("PRICE");
            uprs.updateFloat( "PRICE", f * percentage);
            uprs.updateRow();
        }

    } catch (SQLException e ) {
        JDBCTutorialUtilities.printSQLException(e);
    } finally {
        if (stmt != null) { stmt.close(); }
    }
}
                    </pre>
                </div>
                <p>
                    El campo <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> crea un objeto <code>ResultSet</code> cuyo cursor puede 
                    moverse hacia adelante y hacia atrás en relación a su posición actual y a una posición absoluta. El campo 
                    <code>ResultSet.CONCUR_UPDATABLE</code> crea un objeto <code>ResultSet</code> que puede ser actualizado. Vea la 
                    documentación de Java para <code>ResultSet</code> para otros campos que puede especificar para modificar el 
                    comportamiento de los objetos <code>ResultSet</code>.
                </p>
                <p>
                    El método <code>ResultSet.updateFloat</code> actuliza la columna especificada (en este ejemplo, 
                    <code>PRICE</code>) con el valor <code>float</code> especificado en la fila donde está posicionado el cursor.
                    <code>ResultSet</code> contiene varios métodos actualizadores que le posibilitan actualizar valores de columna 
                    de varios tipos de datos. Sin embargo, ninguno de estos métodos actualizadores modifican la base de datos; debe 
                    llamar al método <code>ResultSet.updateRow</code> para actualizar la base de datos.
                </p>
                <h2>
                    <a id="batch_updates">Usar Objetos Statement para Actualizaciones Por Lotes</a>
                </h2>
                <p>
                    Los objetos <code>Statement</code>, <code>PreparedStatement</code> y <code>CallableStatement</code> tienen una 
                    lista de comandos que están asociados con ellos. Esta lista puede contener sentencias para actualizar, insertar, 
                    o borrar una fila; y pueden también contener sentencias DDL tales como <code>CREATE TABLE</code> y 
                    <code>DROP TABLE</code>. No pueden, sin embargo, contener una sentencia que produjese un objeto 
                    <code>ResultSet</code>, tal como una sentencia <code>SELECT</code>. En otras palabras, la lista puede contener 
                    sólo sentencias que produzcan un recuento de actualizaciones.
                </p>
                <p>
                    La lista, que está asociada con un objeto <code>Statement</code> como en su creación, está inicialmente vacía. 
                    Puede agregar comandos SQL a esta lista con el método <code>addBatch</code> y vaciarla con el método 
                    <code>clearBatch</code>. Cuando ha terminado de agregar sentencias a la lista, llame al método 
                    <code>executeBatch</code> para enviarlas todas a que se ejecuten en la base de datos como una unidad, o lote.
                </p>
                <p>
                    Por ejemplo, el método siguiente <code><a href="gettingstarted.html">CoffeesTable.batchUpdate</a></code> agrega 
                    cuatro filas a la tabla <code>COFFEES</code> con una actualización por lotes:
                </p>
                <div class="codeblock">
                    <pre>
public void batchUpdate() throws SQLException {

    Statement stmt = null;
    try {
        this.con.setAutoCommit(false);
        stmt = this.con.createStatement();

        stmt.addBatch(
            "INSERT INTO COFFEES " +
            "VALUES('Amaretto', 49, 9.99, 0, 0)");

        stmt.addBatch(
            "INSERT INTO COFFEES " +
            "VALUES('Hazelnut', 49, 9.99, 0, 0)");

        stmt.addBatch(
            "INSERT INTO COFFEES " +
            "VALUES('Amaretto_decaf', 49, " +
            "10.99, 0, 0)");

        stmt.addBatch(
            "INSERT INTO COFFEES " +
            "VALUES('Hazelnut_decaf', 49, " +
            "10.99, 0, 0)");

        int [] updateCounts = stmt.executeBatch();
        this.con.commit();

    } catch(BatchUpdateException b) {
        JDBCTutorialUtilities.printBatchUpdateException(b);
    } catch(SQLException ex) {
        JDBCTutorialUtilities.printSQLException(ex);
    } finally {
        if (stmt != null) { stmt.close(); }
        this.con.setAutoCommit(true);
    }
}
                    </pre>
                </div>
                <p>
                    La línea siguiente deshabilita el modo auto-confirmación para el objeto <code>Connection</code> de forma que la 
                    transacción no será automáticamente confirmada o rechazada cuando se llame al método <code>executeBatch</code>.
                </p>
                <div class="codeblock">
                    <pre>
this.con.setAutoCommit(false);
                    </pre>
                </div>
                <p>
                    Para permitir un manejo correcto de los errores, siempre debe deshabilitar el modo de auto-confirmación antes 
                    de empezar una actualización por lotes.
                </p>
                <p>
                    El método <code>Statement.addBatch</code> agrega un comando a la lista de comandos asociados con el objeto 
                    <code>Statement</code> <code>stmt</code>. En este ejemplo, estos comandos son todos sentencias 
                    <code>INSERT INTO</code>, cada una agregando una fila que consiste de cinco valores de columna. Los valores 
                    para las columnas <code>COF_NAME</code> y <code>PRICE</code> son el nombre del café y su precio, 
                    respectivamente. El segundo valor en cada fila es 49 porque ese es el número de identificación para el 
                    proveedor, Superior Coffee. Los dos últimos valores, las entradas para las columnas <code>SALES</code> y 
                    <code>TOTAL</code>, empiezan todas siendo cero porque todavía no ha habido ventas. (<code>SALES</code> es el 
                    número de libras de café vendidas de esta columna en la semana actual; <code>TOTAL</code> es el total de todas 
                    las ventas acumuladas de este café).
                </p>
                <p>
                    La línea siguiente envía los cuatro comandos SQL que fueron agregados a su lista de comandos a la base de datos 
                    para ser ejecutados como un lote:
                </p>
                <div class="codeblock">
                    <pre>
int [] updateCounts = stmt.executeBatch();
                    </pre>
                </div>
                <p>
                    Dese cuenta de que <code>stmt</code> usa el método <code>executeBatch</code> para enviar el lote de inserciones, 
                    no el método <code>executeUpdate</code>, el cual envía sólo un comando y devuelve un sólo recuento de 
                    actualización. El DBMS ejecuta los comandos en el orden en el cual fuerona agregados a la lista de comandos, 
                    así que primero agrega la fila de valores para Amaretto, después agrega la fila para Hazelnut, después Amaretto 
                    decaf, y finalmente Hazelnut decaf. Si los cuatro comandos se ejecutan satisfactoriamente, el DBMS devolverá un 
                    recuento de actualización para cada comando en el orden en el que fue ejecutado. El recuento de actualización 
                    indica cuantas filas fueron afectadas por cada comando se almacenan en el vector<code>updateCounts</code>.
                </p>
                <p>
                    Si los cuatro comandos del lote se ejecutan correctamente, <code>updateCounts</code> contendrá cuatro valores, 
                    todos los cuales son 1 porque una inserción afecta a una fila. La lista de comandos asociados con 
                    <code>stmt</code> ahora está vacía porque los cuatro comandos agregados previamente fueron enviados a la base 
                    de datos cuando <code>stmt</code> llamó al método <code>executeBatch</code>. Puede en cualquier momento vaciar 
                    explícitamente esta lista de comandos con el método <code>clearBatch</code>.
                </p>
                <p>
                    El método <code>Connection.commit</code> hace el lote de actualizaciones a la tabla <code>COFFEES</code> 
                    permanente. Este método necesita ser llamado explícitamente porque el modo de auto-confirmación para esta 
                    conexión fue deshabilitado previamente.
                </p>
                <p>
                    La línea siguiente habilita el modo de auto-confirmación para el objeto <code>Connection</code> actual.
                </p>
                <div class="codeblock">
                    <pre>
this.con.setAutoCommit(true);
                    </pre>
                </div>
                <p>
                    Ahora cada sentencia en el ejemplo será automáticamente confirmada después de ejecutarse, y ya no se necesita 
                    llamar más al método <code>commit</code>.
                </p>
                <h3>
                    Realizar Actualización Por Lotes Parametrizada
                </h3>
                <p>
                    También es posible tener una actualización por lotes parametrizada, como se muestra en el fragmento de código 
                    siguiente, donde 
                    <code>con</code> es un objeto <code>Connection</code>:
                </p>
                <div class="codeblock">
                    <pre>
con.setAutoCommit(false);
PreparedStatement pstmt = con.prepareStatement(
                              "INSERT INTO COFFEES VALUES( " +
                              "?, ?, ?, ?, ?)");
pstmt.setString(1, "Amaretto");
pstmt.setInt(2, 49);
pstmt.setFloat(3, 9.99);
pstmt.setInt(4, 0);
pstmt.setInt(5, 0);
pstmt.addBatch();

pstmt.setString(1, "Hazelnut");
pstmt.setInt(2, 49);
pstmt.setFloat(3, 9.99);
pstmt.setInt(4, 0);
pstmt.setInt(5, 0);
pstmt.addBatch();

<strong>// ... and so on for each new
// type of coffee</strong>

int [] updateCounts = pstmt.executeBatch();
con.commit();
con.setAutoCommit(true);
                    </pre>
                </div>
                <h3>
                    Manejar Excepciones en Actualizaciones Por Lotes
                </h3>
                <p>
                    Obtendrá una <code>BatchUpdateException</code> cuando llame al método <code>executeBatch</code> si (1) una de 
                    las sentencias SQL que agregó al lote produce un conjunto de resultados (usualmente una consulta) o (2) una de 
                    las sentencias SQL en el lote no se ejecuta correctamente por alguna otra razón.
                </p>
                <p>
                    No debe agregar una consulta (una sentencia <code>SELECT</code>) a un lote de comandos SQL porque el método 
                    <code>executeBatch</code>, el cual devuelve un vector de recuento de actualizaciones, espera un recuento de 
                    actualización de cada sentencia SQL que ejecuta correctamente. Esto significa que sólo los comandos que 
                    devuelven una cuenta de actualización (comandos tales como <code>INSERT INTO</code>, <code>UPDATE</code>, 
                    <code>DELETE</code>) o que devuelven 0 (tales como <code>CREATE TABLE</code>, <code>DROP TABLE</code>, 
                    <code>ALTER TABLE</code>) pueden ser ejecutados correctamente como un lote con el comando 
                    <code>executeBatch</code>.
                </p>
                <p>
                    Una <code>BatchUpdateException</code> contiene un vector de recuentos de actualización que es similar al vector 
                    devuelto por el método <code>executeBatch</code>. En ambos casos, el recuento de actualizaciones está en el 
                    mismo orden que los comandos que los producen. Esto le indica cuantos comandos en el lote se ejecutaron 
                    correctamente y cuales eran. Por ejemplo, si cinco comandos se ejecutaron correctamente, el vector contendrá 
                    cinco números: el primero será el recuento de actualización para el primer comando, el segundo será el recuento 
                    de actualización para el segundo comando, etcétera.
                </p>
                <p>
                    <code>BatchUpdateException</code> se deriva de <code>SQLException</code>. Esto significa que puede usar todos 
                    los métodos disponibles en un objeto <code>SQLException</code> en ella. El método siguiente, 
                    <code><a href="gettingstarted.html">JDBCTutorialUtilities.printBatchUpdateException</a></code> imprime toda la 
                    información de <code>SQLException</code> mas los recuentos de actualización contenidos en un objeto 
                    <code>BatchUpdateException</code>, Ya que <code>BatchUpdateException.getUpdateCounts</code> devuelve un vector 
                    de <code>int</code>, el código usa un bucle <code>for</code> para imprimir cada uno de los recuentos de 
                    actualización:
                </p>
                <div class="codeblock">
                    <pre>
public static void printBatchUpdateException(BatchUpdateException b) {

    System.err.println("----BatchUpdateException----");
    System.err.println("SQLState:  " + b.getSQLState());
    System.err.println("Message:  " + b.getMessage());
    System.err.println("Vendor:  " + b.getErrorCode());
    System.err.print("Update counts:  ");
    int [] updateCounts = b.getUpdateCounts();

    for (int i = 0; i &lt; updateCounts.length; i++) {
        System.err.print(updateCounts[i] + "   ");
    }
}
                    </pre>
                </div>
                <h2>
                    <a id="rs_insert">Insertar Filas en Objetos ResultSet</a>
                </h2>
                <p>
                    <strong>Nota</strong>: No todos los controladores JDBC soportan la inserción de nuevas filas con la interfaz 
                    <code>ResultSet</code>. Si intenta insertar una fila nueva y su controlador de base de datos JDBC no admite 
                    esta característica, se lanza una excepción <code>SQLFeatureNotSupportedException</code>.
                </p>
                <p>
                    El método siguiente, <code><a href="gettingstarted.html">CoffeesTable.insertRow</a></code>, inserta una fila 
                    dentro de <code>COFFEES</code> a través de un objeto <code>ResultSet</code>:
                </p>
                <div class="codeblock">
                    <pre>
public void insertRow(String coffeeName, int supplierID,
                      float price, int sales, int total)
    throws SQLException {

    Statement stmt = null;
    try {
        stmt = con.createStatement(
            ResultSet.TYPE_SCROLL_SENSITIVE
            ResultSet.CONCUR_UPDATABLE);

        ResultSet uprs = stmt.executeQuery(
            "SELECT * FROM " + dbName +
            ".COFFEES");

        uprs.moveToInsertRow();
        uprs.updateString("COF_NAME", coffeeName);
        uprs.updateInt("SUP_ID", supplierID);
        uprs.updateFloat("PRICE", price);
        uprs.updateInt("SALES", sales);
        uprs.updateInt("TOTAL", total);

        uprs.insertRow();
        uprs.beforeFirst();
    } catch (SQLException e ) {
        JDBCTutorialUtilities.printSQLException(e);
    } finally {
        if (stmt != null) { stmt.close(); }
    }
}
                    </pre>
                </div>
                <p>
                    Este ejemplo llama al método <code>Connection.createStatement</code> con dos argumentos,
                    <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> y <code>ResultSet.CONCUR_UPDATABLE</code>. El primer valor 
                    habilita que el cursor del objeto <code>ResultSet</code> pueda moverse hacia adelante y hacia atrás. El segundo 
                    valor, <code>ResultSet.CONCUR_UPDATABLE</code>, se requiere si quiere insertar filas dentro de un objeto 
                    <code>ResultSet</code>; Especifica que puede ser actualizado.
                </p>
                <p>
                    Las mismas estipulaciones para usar cadenas en los métodos obtenedores también se aplican a los métodos 
                    actualizadores.
                </p>
                <p>
                    El método <code>ResultSet.moveToInsertRow</code> mueve el cursor para insertar la fila. La fila de inserción es 
                    una fila especial asociada con un conjunto de resultados actualizable. Es esencialmente un buffer donde se puede 
                    construir una nueva fila llamando a los métodos actualizadores antes de insertar la fila en el conjunto de 
                    resultados. Por ejemplo, este método llama al método <code>ResultSet.updateString</code> para actualizar la 
                    columna <code>COF_NAME</code> de la fila de inserción a <code>Kona</code>.
                </p>
                <p>
                    El método <code>ResultSet.insertRow</code> inserta los contenidos de la fila de inserción en el objeto 
                    <code>ResultSet</code> y dentro de la base de datos.
                </p>
                <p>
                    <strong>Nota</strong>: Después de insertar una fila con <code>ResultSet.insertRow</code>, debe mover el cursor 
                    a una fila distinta de la fila de inserción. Por ejemplo, este ejemplo lo mueve antes de la primera fila en el 
                    conjunto de resultados con el método <code>ResultSet.beforeFirst</code>. Pueden ocurrir resultados inesperados 
                    si otra parte de su aplicación usa el mismo conjunto de resultados y el cursor está aún apuntando a la fila de 
                    inserción.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="tables.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="prepared.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Configurando Tablas<br />
            <b>Página siguiente:</b> Usando Prepared Statements
        </div>
    </body>
</html> 
