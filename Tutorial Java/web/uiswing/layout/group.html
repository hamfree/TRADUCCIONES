<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Cómo Usar GroupLayout (Los Tutoriales de Java&trade; &gt; Creando una IGU (Interfaz Gráfica de Usuario) con JFC/Swing
            &gt; Disponer Componentes Dentro de un Contenedor)
        </title>
        <meta name="description" content="Este tutorial de Swing Java describe el desarrollo de interfaces gráficas de usuario (GUI)
              para aplicaciones y applets que utilizan componentes Swing" />
        <meta name="keywords" content="java programming, learn java, java sample code, java swing, java ui, java user interface,
              swing components, swing events, swing layout  " />
        <link rel="stylesheet" href="../../indice.css" type="text/css" />
        <script  src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Disponer Componentes Dentro de un Contenedor</a></div>
                <div class="linkAHEAD"><a href="visual.html">Una Guía Visual a los Gestores de Diseño</a></div>
                <div class="linkAHEAD"><a href="using.html">Usando los Gestores de Diseño</a></div>
                <div class="linkAHEAD"><a href="howLayoutWorks.html">Cómo Funciona la Gestión de Diseño</a></div>
                <div class="linkAHEAD"><a href="layoutlist.html">Cómo Usar Varios Gestores de Diseño</a></div>
                <div class="linkAHEAD"><a href="border.html">Cómo Usar BorderLayout</a></div>
                <div class="linkAHEAD"><a href="box.html">Cómo Usar BoxLayout</a></div>
                <div class="linkAHEAD"><a href="card.html">Cómo Usar CardLayout</a></div>
                <div class="linkAHEAD"><a href="flow.html">Cómo Usar FlowLayout</a></div>
                <div class="linkAHEAD"><a href="gridbag.html">Cómo Usar GridBagLayout</a></div>
                <div class="linkAHEAD"><a href="grid.html">Cómo Usar GridLayout</a></div>
                <div class="nolinkAHEAD">Cómo Usar GroupLayout</div>
                <div class="linkBHEAD"><a href="groupExample.html">Un Ejemplo de GroupLayout</a></div>
                <div class="linkAHEAD"><a href="spring.html">Cómo Usar SpringLayout</a></div>
                <div class="linkAHEAD"><a href="custom.html">Creando un Gestor de Diseño Personalizado</a></div>
                <div class="linkAHEAD"><a href="none.html">Haciendo Sin un Gestor de Diseño (Posicionamiento Absoluto)</a></div>
                <div class="linkAHEAD"><a href="problems.html">Resolviendo Problemas Comunes de Diseño</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Creando una IGU (Interfaz Gráfica de Usuario) con JFC/Swing<br />
                <b>Lección:</b> Disponer Componentes Dentro de un Contenedor
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Creando una IGU (Interfaz Gráfica de Usuario) con JFC/Swing</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Disponer Componentes Dentro de un Contenedor</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="grid.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="groupExample.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Cómo Usar GroupLayout</h1>
            </div>
            <div id="PageContent">
                <p>
                    <code>GroupLayout</code> es un gestor de diseño que fue desarrollado para los constructores de IGUs tales como
                    Matisse, el constructor de IGUs suministrado por el EID Netbeans. Aunque el gestor de diseño fuera
                    originalmente diseñado para ajustarse a las necesidades del constructor IGU, también funciona bien con la
                    codificación nanual. Esta descripción le enseñará cómo funciona <code>GroupLayout</code> y le mostrará cómo
                    usar <code>GroupLayout</code> para construir IGUs, si elige usar un constructor de IGUs como Matisse o escribe
                    su propio código.
                </p>
                <div class="note">
                    <hr />
                    <strong>Nota:</strong>&nbsp;Esta lección cubre la escritura de código de diseño a mano, lo cual puede ser
                    desafiante. Si no está interesado en aprender todos los detalles de la gestión del diseño, preferirá usar el
                    gestor de diseño <code>GroupLayout</code> combinado con una herramienta de construcción para diseñar su IGU.
                    Una de tales herramientas de construcción es el
                    <a class="TutorialLink" target="_top" href="../learn/index.html">EID NetBeans</a>. De otra manera, si quiere
                    codificar a mano y no quiere usar <code>GroupLayout</code>, entonces se recomienda <code>GridBagLayout</code>
                    como el gestor de diseño más flexible y potente.
                    <hr />
                </div>
                <p>
                    Si está interesado en usar JavaFX para crear su IGU, vea
                    <a class="OutsideLink" target="_blank"
                       href="https://docs.oracle.com/javase/8/javafx/layout-tutorial/index.html">Trabajar Con Diseños en JavaFX</a>.
                </p>
                <h2>Principio de Diseño: Dimensiones Independientes</h2>
                <p>
                    <code>GroupLayout</code> funciona con los diseños horizontales y verticales separadamente. El diseño está
                    definido para cada dimensión independientemente. No necesita preocuparse sobre la dimensión <i>vertical</i>
                    cuando define el diseño <i>horizontal</i>, y vice versa, ya que el diseño a lo largo de cada eje es totalmente
                    independiente del diseño a lo largo del otro eje.
                </p>
                <p>
                    Cuando se enfoca en simplemente una dimensión, sólo tiene que resolver la mitad del problema al mismo tiempo. 
                    Esto es más fácil que manejar ambas dmenmsiones a la vez. Esto significa, por supuesto, que cada componente 
                    necesita ser definido dos veces en el diseño. Si olvida hacer esto, <code>GroupLayout</code> generará una
                    excepción.
                </p>
                <h2>Organización del Diseño: Grupos Jerárquicos</h2>
                <p>
                    <code>GroupLayout</code> usa dos tipos de arreglos -- secuencial y paralelo, combinado con la compsición
                    jerárquica.
                </p>
                <ol>
                    <li>
                        Con el arreglo <b>secuencia</b>, los componentes son simplemennte ccolocados uno detrás de otro, justo como
                        <code>BoxLayout</code> o <code>FlowLayout</code> harían a lo largo de un eje. La posición de cada
                        componente es definida como relativa al componente precedente.
                    </li>
                    <li>
                        La segunda forma coloca los componentes en <b>paralelo</b>&mdash; uno encima del otro en el mismo espacio.
                        Pueden estar alineados con la línea base, la parte superior o inferior del eje vertical. A lo largo del eje
                        horizontal, pueden alinearse a la izquierda, a la derecha o al centro si los componentes no son todos del
                        mismo tamaño.
                    </li>
                </ol>
                <p>
                    Usualmente, los componentes colocados en paralelo en una dimensión están en una secuencia en la otra, de forma
                    que no se solapan.
                </p>
                <p>
                    Lo que hace que estos dos arreglos sean poderosos es que se pueden anidar jerárquicamente. Para este propósito
                    <code>GroupLayout</code> define <b>grupos de diseño</b>. Un grupo es o secuencia o paralelo y puede contener
                    componetes, otros gurpos y espacios (descritos abajo).
                </p>
                <p>
                    El tamaño de un grupo secuencial es la suma de los tamaños de los elementos contenidos, y el tamaño de un
                    grupo paralelo corresponde al tamaño del elemento más grande (aunque, dependiendo de los elementos y dónde
                    aterriza la línea base, el tamaño de un grupo alineado a una línea base puede ser un poquito más grande que el
                    elemento más grande).
                </p>
                <p>
                    Definir un diseño significa definir cómo los componente serán agrupados combinando los arreglos secuenciales y
                    paralelos.
                </p>
                <p>
                    Usemos un ejemplo simple para ver cómo funciona en la práctica.
                </p>
                <h2>Un Ejemplo</h2>
                <p>
                    Empecemos con algo simple, justo tres componentes en una fila:
                </p>
                <p style="text-align:center">
                    <img src="../../figures/uiswing/layout/example1a.PNG" width="151" height="31" class="imgbottom"
                         alt="Tres componentes en una fila." />
                </p>
                <p>
                    Expresaremos este diseño usando grupos. Empezando con el eje horizontal es facil ver que hay un
                    <i>grupo secuencial</i> de tres componentes dispuestos de izquierda a derecha. A lo largo del eje vertical hay
                    un <i>grupo paralelo</i> de los mismos 3 componentes con la misma ubicación, tamaño y línea base
                </p>
                <p style="text-align:center">
                    <img src="../../figures/uiswing/layout/groups1a.PNG" width="397" height="69" class="imgbottom"
                         alt="groups1a." />
                </p>
                <p>
                    En pseudo código, la especificación de diseño podría parecer como esto (el código real está en la sección 
                    <i>Escribir código</i> de abajo):
                </p>
                <div class="codeblock">
                    <pre>
horizontal layout = sequential group { c1, c2, c3 }
vertical layout = parallel group (BASELINE) { c1, c2, c3 }
                    </pre>
                </div>
                <p>
                    Esto ilustra un principio mencionado anteriormente: los componentes agrupados secuencialmente en una dimensión
                    usualmente forma un grupo paralelo en la otra dimensión.
                </p>
                <p>
                    Ahora permítanos añadir un componente más, C4, alineado a la zquierda con C3:
                </p>
                <p style="text-align:center">
                    <img src="../../figures/uiswing/layout/example1b.PNG" width="160" height="62" class="imgbottom"
                         alt="example1b." />
                </p>
                <p>
                    A lo largo del eje horizontal, el nuevo componente ocupa el mismo espacio horizontal que C3, de modo que forma
                    un grupo paralelo con C3. A lo largo del eje vertical C4 forma un grupo secuencial con el grupo paralelo
                    original de los tres componentes.
                </p>
                <p style="text-align:center">
                    <img src="../../figures/uiswing/layout/groups1b.PNG" width="413" height="112" class="imgbottom"
                         alt="groups1b." />
                </p>
                <p>
                    En pseudo código, la especificación de diseño ahora se parece a esto:
                </p>
                <div class="codeblock">
                    <pre>
horizontal layout = sequential group { c1, c2, <b>parallel group (LEFT) { </b>c3,<b> c4 }</b> }
vertical layout = <b>sequential group {</b> parallel group (BASELINE) { c1, c2, c3 }, <b>c4 }</b>
                    </pre>
                </div>
                <p>
                    Ahora que entiende los aspectos más importantes de diseñar diseños con <code>GroupLayout</code>. Hay
                    simplemente unos pocos detalles más que explicar: cómo añadir espacios, cómo definir el tamaño y el
                    comportamiento al redimiensionar, cómo definir el diseño justificado, y cómo escribir código real.
                </p>
                <h2>Espacios</h2>
                <p>
                    Un espacio puede ser considerado como un componente invisible de un cierto tamaño. Los espacios de tamaño
                    arbitrairo pueden ser añadidos a los grupos simplemente como componentes u otros grupos. Usando espacios
                    puede controlar precisamente la distancia entre componentes o desde el borde del contenedor. 
                </p>
                <p>
                    <code>GroupLayout</code> también define espacios <i>automáticos</i> que corresponden a las
                    <i>distancias preferidas</i> entre los componente vecinos (o entre un componente y el borde contenedor). El
                    tamaño de tal espacio es calculado dinámicamente basándose en la apariencia que está usando la aplicación 
                    (la clase <code>LayoutStyle</code> es usada para esto). Hay dos ventajas al usar espacios automáticos
                    (preferidos): no tiene que especificar los tamaños en pixeles de los espacios, y estos se ajustan
                    automáticamente a la apariencia que el IU ejecuta, reflejando las pautas de apariencia reales.
                </p>
                <p>
                    <code>GroupLayout</code> distingue entre (a) el espacio preferido entre dos componentes y (b) el espacio
                    preferido entre un componente y el borde del contenedor. Hay métodos correspondientes en la IPA de
                    <code>GroupLayout</code> para añadir estos espacios (<code>addPreferredGap</code> y
                    <code>addContainerGap</code>). Hay tres tipos de espacios para componente: <b>related</b>, <b>unrelated</b> e
                    <b>indented</b>. La enumeración <code>LayoutStyle.ComponentPlacement</code> define las constantes
                    correspondientes que son usadas como parámetros del método <code>addPreferredGap</code>:
                    <code>RELATED</code>, <code>UNRELATED</code> e <code>INDENT</code>. La diferencia entre los espacios
                    relacionados y los no relacionados es simplemente en tamaño &mdash; la distancia entre los componentes no
                    relacionados es un poco más grande. <i>Indented</i> representa una distancia horizontal preferida de dos
                    componentes cuando uno de ellos se coloca debajo del segundo con sangría.
                </p>
                <p style="text-align:center">
                    <img src="../../figures/uiswing/layout/gaps.PNG" width="340" height="77" class="imgbottom"
                         alt="espacios." />
                </p>
                <p>
                    Como se mencionó arriba, <code>GroupLayout</code> puede insertar espacios automáticamente &mdash; si no añade
                    sus propios espacios explícitamente, éste añade los espacios preferidos <i>relacionados</i> por usted. Este no
                    es el comportamiento por defecto, sin embargo. Tiene que activar esta característica invocando 
                    <code>setAutoCreateGaps(true)</code> y
                    <code>setAutoCreateContainerGaps(true)</code> sobre el <code>GroupLayout</code>. Entonces obtendrá el espaciado
                    correcto automáticamente.
                </p>
                <h2>Escribir Código</h2>
                <p>
                    Ahora, echemos un vistazo al código real que crea el diseño descrito arriba.
                </p>
                <p>
                    Supongamos que tenemos un contenedor llamado <code>panel</code> y los mismos cuatro componentes ya presentados
                    (<code>c1</code>, <code>c2</code>, <code>c3</code>, y <code>c4</code>). Primero, creamos un nuevo objeto
                    <code>GroupLayout</code> y lo asociamos con el panel:
                </p>
                <div class="codeblock">
                    <pre>
GroupLayout layout = new GroupLayout(panel);
 panel.setLayout(layout);
                    </pre>
                </div>
                <p>
                    Especificamos la inserción automática de espacios:
                </p>
                <div class="codeblock">
                    <pre>
layout.setAutoCreateGaps(true);
layout.setAutoCreateContainerGaps(true);
                    </pre>
                </div>
                <p>
                    Entonces, definimos los grupos y añadimos los componentes. Establecemos un grupo raíz para cada dimensión 
                    usando los métodos <code>setHorizontalGroup</code> y <code>setVerticalGroup</code>. Los grupos osn creados
                    con los métodos <code>createSequentialGroup</code> y <code>createParallelGroup</code>. Los componentes son
                    añadidos a los grupos usando el método <code>addComponent</code>.
                </p>
                <div class="codeblock">
                    <pre>
layout.setHorizontalGroup(
   layout.createSequentialGroup()
      .addComponent(c1)
      .addComponent(c2)
      .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
           .addComponent(c3)
           .addComponent(c4))
);
layout.setVerticalGroup(
   layout.createSequentialGroup()
      .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
           .addComponent(c1)
           .addComponent(c2)
           .addComponent(c3))
      .addComponent(c4)
);
                    </pre>
                </div>
                <p>
                    Puede especificar la alineación para los grupos paralelos. Puede ser una de las siguientes constantes definidas
                    en la enumeración <code>GroupLayout.Alignment</code>: <code>LEADING</code>, <code>TRAILING</code>,
                    <code>CENTER</code>, y <code>BASELINE</code>. Estas constante son usadas para ambas dimensiones y dependen de
                    si la orientación del componente es de izquierda-a-derecha o de derecha-a-izquierda (arriba-a-abajo o 
                    abajo-a-arriba). Por ejemplo, si la orientación horizontal (vertical) del componente es izquierda-a-derecha 
                    (arriba-a-abajo) <code>LEADING</code> significa izquierda (arriba) mientras <code>TRAILING</code> significa
                    derecha (abajo). <code>CENTER</code> significa &quot;centrado&quot; en ambas dimensiones. Si no especifica el
                    alineamiento, <code>LEADING</code> será usado. El alineamiento <code>BASELINE</code> es válido sólo en la
                    dimensión vertical.
                </p>
                <div class="note">
                    <hr />
                    <strong>Nota:</strong>&nbsp;<p>La alineación en el diseño de un grupo sólo tiene significado para componentes
                        de diferentes tamaños. Los componentes del mismo tamaño serán automáticamente alineados para cada una de las
                        constantes <code>GroupLayout.Alignment</code>.
                    </p>
                    <hr />
                </div>
                <p>Algunos comentarios sobre el código:</p>
                <ul>
                    <li>
                        No necestia añadir el componente directamente al contenedor&mdash;eso es hecho por usted implícitamente
                        cuando usa uno de los métodos addComponent.
                    </li>
                    <li>
                        Fíjese en las llamadas encadenadas de los métodos <code>addComponent</code> usadas para rellenar los
                        grupos. El método <code>addComponent</code> siempre devuelve el grupo en el cual es llamado. Gracias a esto
                        no necesita usar variables locales para contener los grupos.
                    </li>
                    <li>
                        Es una buena idea indentar el código de forma que sea fácil ver la estructura jerárquica de los grupos. De 
                        a cada componente una línea nueva, añade un nivel de indentación para cada grupo nuevo en la jerarquía. Un 
                        buen editor de código fuente le ayudará con el pareado de los paréntesis para cerrar los métodos 
                        <code>createXXXGroup</code>. Siguiente estas regls simples, es más fácil añadir un componente nuevo o
                        eliminar uno existente.
                    </li>
                </ul>
                <h2>Tamaño del Componente y Dimensionamiento</h2>
                <p>
                    No hay límite en el número de componentes redimensionables en un diseño.
                </p>
                <p>
                    El tamaño de cada componente en un <code>GroupLayout</code> está restringido por tres valores; tamaño mínimo,
                    tamaño preferido y tamaño máximo. Estos tamaños controlan cómo el componente se redimensiona dentro del diseño. 
                    El método <code>GroupLayout.addComponent(...)</code> permite que las restricciones de tamaño sean especificadas.
                </p>
                <p>
                    Si no se especifican explícitamente, el diseño le pide al componnete sus tamaños por defecto (usando los 
                    métodos <code>getMinimumSize()</code>, <code>getPreferredSize()</code> y <code>getMaximumSize()</code> del
                    componente). No necesita especificar nada para la mayoría de los componentes, como hacer un
                    <code>JTextField</code> redimensionable o un <code>JButton</code> fijo, porque los componentes por sí mismos
                    tienen el comportamiento de redimensionado deseado por defecto. Por otro lado puede sobreescribir el
                    comportamiento por defecto. Por ejemplo puede hacer un <code>JTextField</code> fijo o un <code>JButton</code>
                    redimensionable.
                </p>
                <p>
                    <code>GroupLayout</code> define constantes que suministran un control preciso sobre el comportamiento del
                    redimensionamiento. Pueden ser usadas como parámetros en el método
                    <code>addComponent(Component comp, int min, int pref, int max)</code>. Aquí tiene dos ejemplos:
                </p>
                <ol>
                    <li>
                        Para forzar a un componente a que sea redimensionable (permitir encogerse y expandirse):
                        <div class="codeblock">
                            <pre>
<i>group</i>.addComponent(component, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) ...
                            </pre>
                        </div>
                        <p>
                            Esto permite al componente a redimensionarse entre el tamaño cero (mínimo) a cualquier tamaño
                            (<code>Short.MAX_VALUE</code> donde tamaño máximo significa &quot;infinite&quot;). Si queríamos que el
                            componente no encoja por debajo de su tamaño mínimo por defecto, usaríamos 
                            <code>GroupLayout.DEFAULT_SIZE</code> en vez de un <code>0</code> en el segundo parámetro.
                        </p>
                    </li>
                    <li>
                        Para hacer un componente de tamaño fijo (suprime el cambio de tamaño):
                        <div class="codeblock">
                            <pre>
group.addComponent(component, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,
          GroupLayout.PREFERRED_SIZE) ...
                            </pre>
                        </div>
                    </li>
                </ol>
                <p>
                    En estos ejemplos el tamaño inicial del componente no es alterado, su tamaño por defecto es el tamaño preferido
                    del compoente. Si queríamos un tamaño específico para el compoente, lo especificaríamos en el segundo parámetro
                    en vez de usar <code>GroupLayout.DEFAULT_SIZE</code>.
                </p>
                <p style="font-weight: bold">
                    Espacios Dimensionables
                </p>
                <p>
                    Especificar el tamaño y la resizabilidad se aplica a los espacios también, incluyendo los preferidos. Por 
                    ejemplo, puede especificar un espacio preferido entre dos componentes que actúe como un <i>muelle</i>
                    empujando los componentes el uno lejos del otro (a los lados opuestos del contenedor). La distancia preferida
                    de los dos componentes es usada sólo como el tamaño mínimo del espacio. Vea el siguiente esbozo:
                </p>
                <div class="codeblock">
                    <pre>
layout.createSequentialGroup()
    .addComponent(c1)
    .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED,
                     GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
    .addComponent(c2);
                    </pre>
                </div>
                <h2>Dimensionamiento en grupos paralelos</h2>
                <p>
                    Los elementos redimensionables colocados en un grupo paralelo se estiran para llenar el espacio del grupo
                    determinado por el elemento más grande del grupo, de forma que terminen alineados con el mismo tamaño.
                    <code>GroupLayout</code> también proporciona control sobre si el grupo paralelo que lo rodea debe cambiar el
                    tamaño. Si el cambio de tamaño del grupo es suprimido, esto previene a los elementos contenidos de crecer por
                    encima del tamaño preferido del grupo. De esta forma puede hacer un bloque de componentes se alinee en ambos
                    lados, o restringir a componentes individuales a tener el mismo tamaño.
                </p>
                <p>
                    Tratemos de lograr el mismo tamaño para dos componentes de nuestro ejemplo (<code>c3</code> y <code>c4</code>
                    en la dimensión horizontal):
                </p>
                <div class="codeblock">
                    <pre>
layout.createParallelGroup(GroupLayout.Alignment.LEADING, false)
  .addComponent(c3, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
  .addComponent(c4, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE);
                    </pre>
                </div>
                <p>
                    El mecanismo subyacente funciona como sigue:
                </p>
                <ol>
                    <li>
                        El tramaño del grupo paralelo es establecido al tamaño preferido del elemento más grande; como el tamaño 
                        preferido de <code>c4</code> en nuestro ejemplo.
                    </li>
                    <li>
                        Los elementos redimensionables se estiran al tamaño del grupo. En nuestro ejemplo, sólo <code>c3</code> es
                        efectivamente estirado, el tamaño de <code>c4</code> ya corresponde al tamaño del grupo.
                    </li>
                </ol>
                <p>
                    Como resultado, <code>c3</code> y <code>c4</code> tendrán el mismo ancho. Los componentes no se
                    redimensionarían aún más porque el grupo paralelo en sí mismo no es redimensionable (el segundo parámetro del
                    método <code>createParallelGroup</code>, encima, es <code>false</code>).
                </p>
                <p style="text-align:center">
                    <img src="../../figures/uiswing/layout/same_size_stretched.PNG" width="160" height="62" class="imgbottom"
                         alt="estirado." />
                </p>
                <p>
                    Pregunta para lectores atentos: ¿Porqué definimos ambos componentes en el grupo paralelo como redimensionables
                    en este ejemplo? Parece suficiente tener solo <code>c3</code> redimensionable ya que <code>c4</code> no se
                    estira de todos modos ...
                </p>
                <p>
                    La respuesta es: debido a la independencia de plataforma y localización. De otra forma tendríamos que confiar 
                    en que el componente <code>c4</code> siempre sea más grande que <code>c3</code>. Pero esto puede cambiar cuando
                    la aplicación se ejecuta en una plataforma diferente o es traducida a otro lenguaje. Al tener ambos componentes 
                    redimensionables, se ajustan entre sí, sin importar cuál sea más grande en un momento dado.
                </p>
                <h2>Hacer los Componentes del Mismo Tamaño</h2>
                <p>
                    El caso previo es especial porque los componentes están en el mismo grupo paralelo. Pero, ¿y si quisiéramos que
                    los componentes no relacionados tuvieran el mismo tamaño? Claramente, el mismo tamaño no siempre se puede
                    garantizar agrupando . Los botones OK y Cancel en una fila en la parte inferior de un diálogo son un buen
                    ejemplo, Para este propósito<code>GroupLayout</code> proporciona un método <code>linkSize</code>. Este método
                    permite que el tamaño de componentes arbitrarios estén enlazados independientemente de donde estén ubicados.
                    El tamaño resultante de los componentes enlazados es establedico de acuerdo al componente más grande. Por
                    ejemplo:
                </p>
                <div class="codeblock">
                    <pre>
layout.linkSize(SwingConstants.HORIZONTAL, c3, c4);
                    </pre>
                </div>
                <p>
                    En este ejemplo, el tamaño está enlazado selectivamente para la dimensión horizontal.
                </p>
                <h2>Cambios en Tiempo de Ejecución a Su IGU</h2>
                <p>
                    Hay dos métodos importantes que puede usar para hacer cambios a su IGU en tiempo de ejecución, 
                    <code>replace()</code> y <code>setHonorsVisibility()</code>. Usar estos dos métodos, puede intercambiar
                    componentes o cambiar la visibilidad de los componentes en tiempo de ejecución y hacer que el IGU se reordene
                    en consecuencia.
                </p>
                <p>
                    <code>replace(Component existingComponent, Component newComponent)</code> reemplaza un componente existente con
                    uno nuevo. Una de las operaciones comunes necesitadas para los diseños dinámicos es la habilidad para
                    reemplazar componentes como este. Por ejemplo, quizás una casilla de verificación alterna entre un componente
                    que muestra un gráfico o un árbol. <code>GroupLayout</code> hace este escenario simple con el método
                    <code>replace()</code>. Puede intercambiar componentes sin recrear todos los grupos.
                </p>
                <p>
                    Otra operación común en interfaces de usuario es cambiar dinámicamente al visibilidad de los componentes.
                    Quizás los componentes son son mostrados sólo cuando un usuario completa más temprano porciones de un
                    formulario. Para evitar que los componentes se revuelvan en tal escenario, se debe tomar espacio
                    independientemente de la visibilidad de los componentes. <code>GroupLayout</code> ofrece dos formas de
                    configurar cómo los componentes invisibles son tratados. El método <code>setHonorsVisibility(boolean)</code>
                    establece globalmente cómo son manejados los componentes invisibles. Un valor verdadero, el predeterminado,
                    indica que los componentes invisibles son tratados como si no estuvieran ahí. Por otro lado, un valor falso
                    suministra espacio para los componentes invisibles, tratándolos como si fueran visibles. El método
                    <code>setHonorsVisibility(Component,Boolean)</code> pued ser usada para configurar el comportamiento al nivel
                    de un componente específico. Para determinar cómo la visibilidad es manejada, <code>GroupLayout</code>
                    comprueba primero si un valor ha sido especificado para el componente, si no, comprueba el establecimiento
                    de la propiedad global.
                </p>
                <div class="note">
                    <hr />
                    <strong>Algo de historia:</strong>&nbsp;
                    <p>
                        <code>GroupLayout</code> en la Edición Estandar de Java 6 consiste de tres distintos cuerpos de trabajo: la 
                        facilidad de obtener la línea base para un componente, la habilidad para obtener el espacio preferido 
                        entre componentes (<code>LayoutStyle</code>), y <code>GroupLayout</code>. Este trabajo fue originalmente
                        hecho como un proyecto de fuente abierta en
                        <a class="OutsideLink" target="_blank" 
                           href="http://java.net/projects/swing-layout/">http://java.net/projects/swing-layout/</a>
                    </p>
                    <p>
                        NetBeans 5.0 soporta <code>GroupLayout</code> por medio del proyecto swing-layout. Debido al éxito de este
                        trabajo, las tres porciones de <code>GroupLayout</code> han sido incorporadas  en la Edición Estándar de
                        Java version 6. La principal diferencia entre el <code>GroupLayout</code>en Java SE 6 y swing-layout está
                        en el nombre del paquete y los nombres del método. NetBeans 5.5 proporciona la habilidad de usar
                        <code>GroupLayout</code> en Java SE 6, o el <code>GroupLayout</code> en swing-layout. Qué versión usa
                        NetBeans es determinado por la versión de la plataforma Java que su proyecto tiene. Un proyecto que utiliza
                        Java SE 6 usa el <code>GroupLayout</code> de Java SE, de otra manera se usará el <code>GroupLayout</code>
                        del proyecto swing-layout.
                    </p>
                    <hr />
                </div>
            </div>
            <div class="NavBit">
                <a target="_top" href="grid.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="groupExample.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.</p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente <a target="_blank" href="../../information/run-examples.html">
                                Compilando y Ejecutando los Ejemplos: PFs</a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Cómo Usar GridLayout<br />
            <b>Página siguiente:</b> Un Ejemplo de GroupLayout
        </div>
    </body>
</html>