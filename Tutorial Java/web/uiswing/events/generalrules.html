<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Información General sobre la Escritura de Listener Events (Los Tutoriales de Java&trade; &gt; Creando una IGU (Interfaz
            Gráfica de Usuario) &gt; Escribiendo Listener Events)
        </title>
        <meta name="description" content="Este tutorial de Swing Java describe el desarrollo de interfaces gráficas de usuario (GUI)
              para aplicaciones y applets que utilizan componentes Swing" />
        <meta name="keywords" content="java programming, learn java, java sample code, java swing, java ui, java user interface,
              swing components, swing events, swing layout  " />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper  clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Escribiendo Listener Events</a></div>
                <div class="linkAHEAD"><a href="intro.html">Introducción a los Listener Events</a></div>
                <div class="nolinkAHEAD">Información General sobre la Escritura de Listener Events</div>
                <div class="linkAHEAD"><a href="eventsandcomponents.html">Listeners Soportados por los Componentes Swing</a></div>
                <div class="linkAHEAD"><a href="handling.html">Implementando Listeners para los Eventos Comunmente Manejados</a></div>
                <div class="linkBHEAD"><a href="actionlistener.html">Cómo Escribir una Action Listener</a></div>
                <div class="linkBHEAD"><a href="caretlistener.html">Cómo Escribir un Caret Listener</a></div>
                <div class="linkBHEAD"><a href="changelistener.html">Cómo Escribir un Change Listener</a></div>
                <div class="linkBHEAD"><a href="componentlistener.html">Cómo Escribir un Component Listener</a></div>
                <div class="linkBHEAD"><a href="containerlistener.html">Cómo Escribir un Container Listener</a></div>
                <div class="linkBHEAD"><a href="documentlistener.html">Cómo Escribir un Document Listener</a></div>
                <div class="linkBHEAD"><a href="focuslistener.html">Cómo Escribir un Focus Listener</a></div>
                <div class="linkBHEAD"><a href="internalframelistener.html">Cómo Escribir un Internal Frame Listener</a></div>
                <div class="linkBHEAD"><a href="itemlistener.html">Cómo Escribir un Item Listener</a></div>
                <div class="linkBHEAD"><a href="keylistener.html">Cómo Escribir un Key Listener</a></div>
                <div class="linkBHEAD"><a href="listdatalistener.html">Cómo Escribir un List Data Listener</a></div>
                <div class="linkBHEAD"><a href="listselectionlistener.html">Cómo Escribir un List Selection Listener</a></div>
                <div class="linkBHEAD"><a href="mouselistener.html">Cómo Escribir un Mouse Listener</a></div>
                <div class="linkBHEAD"><a href="mousemotionlistener.html">Cómo Escribir un Mouse-Motion Listener</a></div>
                <div class="linkBHEAD"><a href="mousewheellistener.html">Cómo Escribir un Mouse-Wheel Listener</a></div>
                <div class="linkBHEAD"><a href="propertychangelistener.html">Cómo Escribir un Property Change Listener</a></div>
                <div class="linkBHEAD"><a href="tablemodellistener.html">Cómo Escribir un Table Model Listener</a></div>
                <div class="linkBHEAD"><a href="treeexpansionlistener.html">Cómo Escribir un Tree Expansion Listener</a></div>
                <div class="linkBHEAD"><a href="treemodellistener.html">Cómo Escribir un Tree Model Listener</a></div>
                <div class="linkBHEAD"><a href="treeselectionlistener.html">Cómo Escribir un Tree Selection Listener</a></div>
                <div class="linkBHEAD"><a href="treewillexpandlistener.html">Cómo Escribir un Tree-Will-Expand Listener</a></div>
                <div class="linkBHEAD"><a href="undoableeditlistener.html">Cómo Escribir un Undoable Edit Listener</a></div>
                <div class="linkBHEAD"><a href="windowlistener.html">Cómo Escribir Window Listeners</a></div>
                <div class="linkAHEAD"><a href="api.html">Tabla del IPA de Listeners</a></div>
                <div class="linkAHEAD"><a href="problems.html">Resolviendo Problemas Comunes en el Manejo de Eventos</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Creando una IGU (Interfaz Gráfica de Usuario) con JFC/Swing<br />
                <b>Lección:</b> Escribiendo Listener Events
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Creando una IGU (Interfaz Gráfica de Usuario) con JFC/Swing</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Escribiendo Listener Events</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="intro.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="eventsandcomponents.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Información General sobre la Escritura de Listener Events</h1>
            </div>
            <div id="PageContent">
                <p>
                    Esta sección describe varias consideraciones de diseño a tener en cuenta cuando implemente manejadores de 
                    eventos <b>(Nota del Traductor: event handlers en inglés)</b> en su aplicación. Luego le presentamos a los 
                    pequeños objetos de eventos de objeto que describen cada evento. En particular, hablamos sobre 
                    <code>EventObject</code>, la superclase para todos los eventos de AWT y Swing. A continuación, presentamos los 
                    conceptos de los eventos de bajo nivel y los eventos semánticos, recomendando que elija los eventos semánticos 
                    siempre que sea posible. El resto de esta sección analiza las técnicas de implementación que puede utilizar en 
                    algunos event listeners o ver en event listeners creados por otras personas o por constructores de GUI.
                </p>
                <ul>
                    <li><a href="#design">Consideraciones de Diseño</a></li>
                    <li><a href="#eventobjects">Obtener Información de Eventos: Objetos Evento</a></li>
                    <li><a href="#twokinds">Conceptos: Eventos de Bajo-Nivel y Eventos Semánticos</a></li>
                    <li><a href="#eventAdapters">Adaptadores de Evento</a></li>
                    <li><a href="#innerClasses">Clases Internas y Clases Anónimas Internas</a></li>
                    <li><a href="#eventHandlers">La Clase EventHandler</a></li>
                </ul>
                <p>
                    <a id="design"></a>
                </p>
                <h2>
                    <a id="design__1">Consideraciones de Diseño</a>
                </h2>
                <p>
                    La regla más importante a tener en cuenta sobre los event listeners es que se deberían ejecutar muy 
                    rápidamente. Debido a que todos los métodos de escucha de eventos y de dibujo se ejecutan en el mismo hilo, un 
                    método de event listener lento puede hacer que el programa parezca que no responde y que se repinta lentamente. 
                    Si necesita ejecutar alguna operación larga como resultado de un evento, hágalo iniciando otro hilo (o de 
                    alguna forma mandando una petición a otro hilo) para realizar la operación. Para ayuda sobre el uso de hilos, 
                    vea
                    <a class="TutorialLink" target="_top" href="../concurrency/index.html">Concurrencia en Swing</a>.
                </p>
                <p>
                    Tiene muchas opciones de cómo implementar un event listener. No podemos recomendar un enfoque específico porque 
                    una solución no se adapta a todas las situaciones. Sin embargo, podemos darte algunas pistas y mostrarte 
                    algunas técnicas que puede ver, incluso si no usa la misma solución en su programa.
                </p>
                <p>
                    Por ejemplo, podría elegir implementar clases separadas para diferentes clases de event listeners. Esto puede 
                    ser una arquitectura fácil de mantener, pero el tener muchas clases puede también significar un rendimiento 
                    reducido.
                </p>
                <p>
                    Al diseñar su programa, es posible que desee implementar sus event listeners en una clase que no sea pública, 
                    sino en algún lugar más oculto. Una implementación privada es una implementación más segura.
                </p>
                <p>
                    Si tiene un tipo muy específico de un simple event listener, es posible que pueda evitar la creación de una 
                    clase mediante el uso de la clase <code>EventHandler</code>.<a id="eventobjects"></a>
                </p>
                <h2>
                    <a id="eventobjects__1">Obtener Información de Eventos: Objetos Evento</a>
                </h2>
                <p>
                    Cada método de un event listener tiene como único argumento un objeto que hereda de la clase 
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/EventObject.html">
                        <code>EventObject</code></a>. Aunque el argumento siempre desciende desde <code>EventObject</code>, su 
                    tipo es generalmente especifcado de forma más precisa. Por ejemplo, el argumento para los métodos que 
                    gestionan eventos del ratón es una instancia de <code>MouseEvent</code>, donde <code>MouseEvent</code> 
                    es una subclase indirecta de <code>EventObject</code>.
                </p>
                <p>
                    La clase <code>EventObject</code> define un método muy útil:
                </p>
                <dl>
                    <dt>
                        <strong><code>Object getSource()</code></strong>
                    </dt>
                    <dd>
                        Devuelve el objeto que disparó el evento.
                    </dd>
                </dl>
                <p>
                    Dese cuenta de que el método <code>getSource</code> devuelve un <code>Object</code>. Las clases de evento 
                    algunas veces definen métodos similares a <code>getSource</code>, pero que tienen tipos de retorno más 
                    restringidos. Por ejemplo, la clase <code>ComponentEvent</code> define un método <code>getComponent</code> que 
                    igual que <code>getSource</code> devuelve el objeto que disparó el evento. La diferencia es que 
                    <code>getComponent</code> siempre devuelve un <code>Component</code>. Cada página de procedimientos para los 
                    event listeners menciona si usar <code>getSource</code> u otro método para obtener la fuente del evento.
                </p>
                <p>
                    A menudo una clase de evento define métodos que devuelven información sobre el evento. Por ejemplo, puede 
                    preguntar a un objeto <code>MouseEvent</code> por información sobre dónde ocurrió el evento, cuantas 
                    pulsaciones ha hecho el usuario, qué modificadores de tecla fueron presionados, etc.
                </p>
                <h2>
                    <a id="twokinds">Conceptos: Eventos de Bajo-Nivel y Eventos Semánticos</a>
                </h2>
                <p>
                    Los eventos pueden ser divididos en dos grupos: eventos <em>de bajo nivel</em> y eventos <em>semánticos</em>. 
                    Los eventos de bajo nivel representan ocurrencias del sistema de ventanas o entradas de bajo nivel. Todo lo 
                    demás es un evento semántico.
                </p>
                <p>
                    Ejemplos de eventos de bajo nivel incluyen eventos de teclado y ratón, los cuales resultan directamente
                    de la entrada del usuario. Ejemplos de eventos semánticos incluyen las acciones y los eventos de elemento. Un 
                    evento semántico podría ser disparado por una entrada de usuario; por ejemplo, un botón normalmente activa un 
                    evento de acción cuando el usuario hace clic en él, y un campo de texto dispara un evento de acción cuando el 
                    usuario presiona <i>Intro</i>. Sin embargo, algunos eventos semánticos no son disparados por eventos de 
                    bajo nivel, en absoluto. Por ejemplo, un evento del modelo de tabla podría ser disparado cuando un modelo de 
                    tabla recibe nuevos datos desde una base de datos.
                </p>
                <p>
                    Siempre que sea posible, debe escuchar eventos semánticos en lugar de eventos de bajo nivel. De esa forma, 
                    puede hacer su código tan robusto y portable como sea posible. Por ejemplo, escuchar por eventos de acción en 
                    los botones, en vez de eventos del ratón, significa que el botón reaccionará apropiadamente cuando el usuario 
                    intente activar el botón usando un teclado alternativo o un gesto específico de Aspecto y Sensación. Cuando 
                    trate con un componente compuesto como un cuadro combinado, Es imperativo que se ciña a los eventos semánticos, 
                    ya que no dispone de una forma fiable de registrar a los listeners en todos los componentes específicos de 
                    apariencia y sensación que podrían utilizarse para formar el componente compuesto.
                </p>
                <h2>
                    <a id="eventAdapters">Adaptadores de Evento</a>
                </h2>
                <p>
                    Algunos interfaces de listener contienen más de un método. Por ejemplo, el interfaz <code>MouseListener</code> 
                    contiene cinco métodos: <code>mousePressed</code>, <code>mouseReleased</code>, <code>mouseEntered</code>,
                    <code>mouseExited</code>, y <code>mouseClicked</code>. Incluso si solo te preocupan los clics del mouse, si tu 
                    clase implementa directamente <code>MouseListener</code>, entonces debes implementar los cinco métodos 
                    <code>MouseListener</code>. Los métodos para esos eventos que no te importan pueden tener cuerpos vacíos. Aquí 
                    tiene un ejemplo:
                </p>
                <div class="codeblock">
                    <pre>
//An example that implements a listener interface directly.
public class MyClass implements MouseListener {
    ...
        someObject.addMouseListener(this);
    ...
    /* Empty method definition. */
    public void mousePressed(MouseEvent e) {
    }

    /* Empty method definition. */
    public void mouseReleased(MouseEvent e) {
    }

    /* Empty method definition. */
    public void mouseEntered(MouseEvent e) {
    }

    /* Empty method definition. */
    public void mouseExited(MouseEvent e) {
    }

    public void mouseClicked(MouseEvent e) {
        <em>...//Event listener implementation goes here...</em>
    }
}
                    </pre>
                </div>
                <p>
                    La colección resultante de cuerpos de método vacíos puede hacer el código más difícil de leer y mantener, Para 
                    ayudarle a evitar la implementación de cuerpos de método vacíos, la IPA incluye generalmente una clase 
                    <em>adaptador</em> para cada interfaz de listener con más de un método. (La <a href="api.html">Tabla del IPA de 
                        Listeners</a> lista todos los listeners y sus adaptadores). Por ejemplo, la clase <code>MouseAdapter</code> 
                    implementa el interfaz <code>MouseListener</code>. Una clase adaptador implementa versiones vacías de todos 
                    los métodos de su interfaz.
                </p>
                <p>
                    Para usar un adaptador, cree una subclase de ella y sobreescriba sólo los métodos que le interesen, en vez de 
                    implementar directamente todos los métodos del interfaz del listener. Aquí tiene un ejemplo que modifica el 
                    código precedente para extender <code>MouseAdapter</code>. Extendiendo <code>MouseAdapter</code>, hereda las 
                    definiciones vacías de los cinco métodos que contiene <code>MouseListener</code>.
                </p>
                <div class="codeblock">
                    <pre>
/*
 * An example of extending an adapter class instead of
 * directly implementing a listener interface.
 */
public class MyClass extends MouseAdapter {
    ...
        someObject.addMouseListener(this);
    ...
    public void mouseClicked(MouseEvent e) {
        <em>...//Event listener implementation goes here...</em>
    }
}
                    </pre>
                </div>
                <h2>
                    <a id="innerClasses">Clases Internas y Clases Anónimas Internas</a>
                </h2>
                <p>
                    ¿Qué sucede si desea utilizar una clase de adaptador, pero no desea que su clase pública herede de una clase de 
                    adaptador? Por ejemplo, suponga que escribe un applet, y quiere que su subclase de <code>Applet</code> contenga 
                    algún código que gestione eventos del ratón. Ya que el lenguaje Java no permite la herencia múltiple, su clase 
                    no puede extender a la vez de las clases <code>Applet</code> y <code>MouseAdapter</code>. Una solución es 
                    definir una <em>clase interna</em> en una clase dentro de su subclase de <code>Applet</code> que extienda la 
                    clase <code>MouseAdapter</code>.
                </p>
                <p>
                    Las clases internas son también útiles para los event listeners que implementan uno o más interfaces 
                    directamente.
                </p>
                <div class="codeblock">
                    <pre>
//An example of using an inner class.
public class MyClass extends Applet {
    ...
        someObject.addMouseListener(new MyAdapter());
    ...
    class MyAdapter extends MouseAdapter {
        public void mouseClicked(MouseEvent e) {
            <em>...//Event listener implementation goes here...</em>
        }
    }
}
                    </pre>
                </div>
                <div class="note">
                    <hr />
                    <strong>Nota de rendimiento:</strong>&nbsp;
                    <p>
                        Cuando considere si usar una clase interna, tenga en cuenta que el tiempo de inicio de la aplicación y el 
                        consumo de memoria es habitualmente directamente proporcional al número de clases que carga. Cuanto más 
                        clases cree usted, más tardará su programa en iniciarse y más memoria ocupará. Como desarrollador de 
                        aplicaciones, debe equilibrar esto con otras restricciones de diseño que pueda tener. No estamos sugiriendo 
                        que convierta su aplicación en una sola clase monolítica con la esperanza de reducir el tiempo de inicio y 
                        la huella de memoria, esto provocaría dolores de cabeza innecesarios y cargas de mantenimiento.
                    </p>
                    <hr />
                </div>
                <p>
                    Puede crear una clase interna sin especificar un nombre, esto se conoce como una 
                    <em>clase interna anónima</em>. Si bien puede parecer extraño a primera vista, las clases internas anónimas 
                    pueden hacer que su código sea más fácil de leer porque la clase está definida donde se referencia. 
                    Sin embargo, debe sopesar la convenencia con las posibles implicaciones de rendimiento de aumentar el 
                    número de clases.
                </p>
                <p>
                    Aquí tiene un ejemplo usando una clase interna anónima:
                </p>
                <div class="codeblock">
                    <pre>
//An example of using an anonymous inner class.
public class MyClass extends Applet {
    ...
        someObject.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent e) {
                <em>...//Event listener implementation goes here...</em>
            }
        });
    ...
    }
}
                    </pre>
                </div>
                <div class="note">
                    <hr />
                    <strong>Nota:</strong>&nbsp;
                    <p>
                        Un inconveniente de las clases internas anónimas es que el mecanismo de persistencia a largo plazo no las 
                        puede ver. Para más información vea la documentación de la IPA para 
                        <a class="APILink" target="_blank"
                           href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html#package_description">
                            Paquete JavaBeans&trade;</a> y la lección 
                        <a class="TutorialLink" target="_top"
                           href="../../javabeans/advanced/persistence.html">Persistencia del Bean</a> en el recorrido 
                        <a class="TutorialLink" target="_top" href="../../javabeans/">JavaBeans</a>.
                    </p>
                    <hr />
                </div>
                <p>
                    Las clases internas funcionan incluso si su event listener necesita acceder a variables de instancia privadas 
                    de la clase adjunta. Siempre que no declare que una clase interna sea <code>static</code>, una clase interna 
                    puede referirse a variables y métodos de instancia como si su código estuviera en la clase contenedora.
                    Para hacer una variable local disponible a una clase interna, simplemente guarde una copia de la variable como 
                    una variable local <code>final</code>.
                </p>
                <p>
                    Para referirse a la instancia adjunta, puede usar <code><em>EnclosingClass</em>.this</code>. Para más 
                    información sobre las clases internas, vea 
                    <a class="TutorialLink" target="_top" href="../../java/javaOO/nested.html">Clases Anidadas</a>.
                </p>
                <h2>
                    <a id="eventHandlers">La Clase EventHandler</a>
                </h2>
                <p>
                    Una clase 
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/beans/EventHandler.html">
                        <code>EventHandler</code>
                    </a> soporta la generación dinámica de event listeners simples, de una sentencia. Aunque 
                    <code>EventHandler</code> sólo es útil para un cierto tipo de event listener extremadamente simples, vale la 
                    pena mencionarla por dos razones. Es útil para:
                </p>
                <ul>
                    <li>
                        Hacer un event listener que la persistencia pueda ver y, sin embargo, no obstruya sus propias clases con 
                        interfaces y métodos de event listener.
                    </li>
                    <li>
                        No agregar al número de clases definidas en una aplicación, esto puede ayudar al rendimiento.
                    </li>
                </ul>
                <p>
                    Crear un <code>EventHandler</code> a mano es difícil. Un <code>EventHandler</code> debe ser cuidadosamente 
                    construído. Si comete un error, no se le notificará en el momento de la compilación, se producirá una excepción 
                    oscura en el tiempo de ejecución. Por esta razón, los <code>EventHandler</code>s se crean mejor con un 
                    constructor de IGU. Se deben documentar cuidadosamente los <code>EventHandler</code>s. De otra forma corre el 
                    riesgo de producir código difícil de leer.
                </p>
                <p>
                    La clase <code>EventHandler</code> está destinada a ser utilizada por herramientas interactivas, como los 
                    constructores de aplicaciones, que permiten a los desarrolladores hacer conexiones entre beans. Habitualmente 
                    las conexiones se hacen desde un bean del interfaz de usuario (el origen del evento) a un bean de la lógica de 
                    la aplicación (el destino). Las conexiona más efectivas de esta clase aislan la lógica de la aplicación del 
                    interfaz de usuario. Por ejemplo, el <code>EventHandler</code> para una conexión de un JCheckBox a un método 
                    que acepta un valor booleano puede tratar de extraer el estado de la casilla de verificación y pasárselo 
                    directamente al método de forma que el método está aislado de la capa del interfaz de usuario.
                </p>
                <p>
                    Las clases internas son otra forma más general de manejar eventos desde interfaces de usuario. La clase 
                    <code>EventHandler</code> maneja sólo un subconjunto de lo que es posible usando clases internas. Sin embargo 
                    <code>EventHandler</code> funciona mejor con el esquema de la persistencia a largo plazo que las clases 
                    internas. Además, usando <code>EventHandler</code> en aplicaciones grandes en las cuales el mismo interfaz es 
                    implementado muchas veces puede reducir la huella de disco y memoria de la aplicación.
                </p>
                <p>
                    Ejemplos de Usar <code>EventHandler</code> El uso más simple de <code>EventHandler</code> es instalar un 
                    listener que llame a un método en el objeto destino sin argumentos. En el ejemplo siguiente creamos un 
                    ActionListener que invoca el método toFront en una instancia de <code>javax.swing.JFrame</code>.
                </p>
                <div class="codeblock">
                    <pre>
    myButton.addActionListener(
        (ActionListener)EventHandler.create(ActionListener.class, frame, "toFront"));
                    </pre>
                </div>
                <p>
                    Cuando myButton es presionado, la sentencia frame.toFront() será ejecutada. Uno podría obtener el mismo efecto, 
                    con algo de seguridad de tipo en tiempo de compilación adicional, definiendo una nueva implementación de la 
                    interfaz ActionListener y agregando una instancia de la misma al botón:
                </p>
                <div class="codeblock">
                    <pre>
    //Equivalent code using an inner class instead of <code>EventHandler</code>.
    myButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            frame.toFront();
        }
    });
                    </pre>
                </div>
                <p>
                    El siguiente uso más simple de <code>EventHandler</code> es extraer un valor de propiedad del primer argumento 
                    del método en la interfaz de escucha (generalmente un objeto de evento) y usarlo para establecer el valor de 
                    una propiedad en el objeto de destino. En el ejemplo siguiente creamos un ActionListener que establece la 
                    propiedad nextFocusableComponent del objeto destino (myButton) al valor de la propiedad &quot;fuente&quot; del 
                    evento.
                </p>
                <div class="codeblock">
                    <pre>
    EventHandler.create(ActionListener.class, myButton, "nextFocusableComponent", "source")
                    </pre>
                </div>
                <p>
                    Esto correspondería a la siguiente implementación de clase interna:
                </p>
                <div class="codeblock">
                    <pre>
    //Equivalent code using an inner class instead of <code>EventHandler</code>.
    new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            myButton.setNextFocusableComponent((Component)e.getSource());
        }
    }
                    </pre>
                </div>
                <p>
                    Es también posible crear un <code>EventHandler</code> que simplemente pase el objeto de evento entrante a la 
                    acción del destino. Si el cuarto argumento de <code>EventHandler</code> es una cadena vacía, entonces el evento 
                    simplemente se transmite:
                </p>
                <div class="codeblock">
                    <pre>
    EventHandler.create(ActionListener.class, target, "doActionEvent", "")
                    </pre>
                </div>
                <p>
                    Esto correspondería a la siguiente implementación de clase interna:
                </p>
                <div class="codeblock">
                    <pre>
    //Equivalent code using an inner class instead of <code>EventHandler</code>.
    new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            target.doActionEvent(e);
        }
    }
                    </pre>
                </div>
                <p>
                    Probablemente el uso más común de <code>EventHandler</code> es extraer un valor de propiedad de la fuente del 
                    objeto evento y establecer este valor como el valor de una propiedad del objeto destino. En el ejemplo 
                    siguiente creamos un ActionListener que establece la propiedad &quot;label&quot; del objeto destino al valor de 
                    la propiedad &quot;text&quot; de la fuente (el valor de la propiedad &quot;source&quot;) del evento.
                </p>
                <div class="codeblock">
                    <pre>
    EventHandler.create(ActionListener.class, myButton, "label", "source.text")
                    </pre>
                </div>
                <p>
                    Esto correspondería a la siguiente implementación de clase interna:
                </p>
                <div class="codeblock">
                    <pre>
    //Equivalent code using an inner class instead of <code>EventHandler</code>.
    new ActionListener {
        public void actionPerformed(ActionEvent e) {
            myButton.setLabel(((JTextField)e.getSource()).getText());
        }
    }
                    </pre>
                </div>
            </div>
            <div class="NavBit">
                <a target="_top" href="intro.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="eventsandcomponents.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.</p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente <a target="_blank" href="../../information/run-examples.html">
                                Compilando y Ejecutando los Ejemplos: PFs</a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Introducción a los Listener Events<br />
            <b>Página siguiente:</b> Listeners Soportados por los Componentes Swing
        </div>
    </body>
</html>