<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Características del Componente de Texto (Los Tutoriales de Java&trade; &gt; Creando una IGU (Interfaz Gráfica de 
            Usuario) con JFC/Swing &gt; Usando Componentes Swing)
        </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Este tutorial de Swing Java describe el desarrollo de interfaces gráficas de usuario (GUI)
              para aplicaciones y applets que utilizan componentes Swing" />
        <meta name="keywords" content="java programming, learn java, java sample code, java swing, java ui, java user interface,
              swing components, swing events, swing layout  " />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Usando Componentes Swing</a></div>
                <div class="linkAHEAD"><a href="toplevel.html">Usando Contenedores de Nivel Superior</a></div>
                <div class="linkAHEAD"><a href="jcomponent.html">La Clase JComponent</a></div>
                <div class="linkAHEAD"><a href="text.html">Usando Componentes de Texto</a></div>
                <div class="nolinkBHEAD">Características del Componente de Texto</div>
                <div class="linkBHEAD"><a href="textapi.html">La IPA del Componente de Texto</a></div>
                <div class="linkAHEAD"><a href="componentlist.html">Cómo Usar Varios Componentes</a></div>
                <div class="linkBHEAD"><a href="applet.html">Cómo Hacer Applets</a></div>
                <div class="linkBHEAD"><a href="button.html">Cómo Usar Botones, Casillas de Verificación y Botones de Radio</a></div>
                <div class="linkBHEAD"><a href="buttongroup.html">Cómo Usar el Componente Grupo De Botones</a></div>
                <div class="linkBHEAD"><a href="colorchooser.html">Cómo Usar Selectores de Color</a></div>
                <div class="linkBHEAD"><a href="combobox.html">Cómo Usar Cuadros Combinados</a></div>
                <div class="linkBHEAD"><a href="dialog.html">Cómo Hacer Diálogos</a></div>
                <div class="linkBHEAD"><a href="editorpane.html">Cómo Usar Paneles de Edición y Paneles de Texto</a></div>
                <div class="linkBHEAD"><a href="filechooser.html">Cómo Usar Selectores de Fichero</a></div>
                <div class="linkBHEAD"><a href="formattedtextfield.html">Cómo Usar Campos de Texto Formateado</a></div>
                <div class="linkBHEAD"><a href="frame.html">Cómo Hacer Marcos (Ventanas Principales)</a></div>
                <div class="linkBHEAD"><a href="internalframe.html">Cómo Usar Marcos Internos</a></div>
                <div class="linkBHEAD"><a href="label.html">Cómo Usar Etiquetas</a></div>
                <div class="linkBHEAD"><a href="layeredpane.html">Cómo Usar Paneles Estratificados</a></div>
                <div class="linkBHEAD"><a href="list.html">Cómo Usar Listas</a></div>
                <div class="linkBHEAD"><a href="menu.html">Cómo Usar Menús</a></div>
                <div class="linkBHEAD"><a href="panel.html">Cómo Usar Paneles</a></div>
                <div class="linkBHEAD"><a href="passwordfield.html">Cómo Usar Campos de Contraseña</a></div>
                <div class="linkBHEAD"><a href="progress.html">Cómo Usar Barras de Progreso</a></div>
                <div class="linkBHEAD"><a href="rootpane.html">Cómo Usar los Paneles Raíz</a></div>
                <div class="linkBHEAD"><a href="scrollpane.html">Cómo Usar Los Paneles de Desplazamiento</a></div>
                <div class="linkBHEAD"><a href="separator.html">Cómo Usar los Separadores</a></div>
                <div class="linkBHEAD"><a href="slider.html">Cómo Usar Deslizadores</a></div>
                <div class="linkBHEAD"><a href="spinner.html">Como Usar Contadores Numéricos</a></div>
                <div class="linkBHEAD"><a href="splitpane.html">Cómo Usar Paneles de División</a></div>
                <div class="linkBHEAD"><a href="tabbedpane.html">Cómo Usar Paneles Tabulados</a></div>
                <div class="linkBHEAD"><a href="table.html">Cómo Usar Tablas</a></div>
                <div class="linkBHEAD"><a href="textarea.html">Cómo Usar Áreas de Texto</a></div>
                <div class="linkBHEAD"><a href="textfield.html">Cómo Usar Campos de Texto</a></div>
                <div class="linkBHEAD"><a href="toolbar.html">Cómo Usar Barras de Herramientas</a></div>
                <div class="linkBHEAD"><a href="tooltip.html">Cómo Usar Tool Tips</a></div>
                <div class="linkBHEAD"><a href="tree.html">Cómo Usar Árboles</a></div>
                <div class="linkAHEAD"><a href="html.html">Cómo Usar HTML en Componentes Swing</a></div>
                <div class="linkAHEAD"><a href="model.html">Cómo Usar Modelos</a></div>
                <div class="linkAHEAD"><a href="icon.html">Cómo Usar Iconos</a></div>
                <div class="linkAHEAD"><a href="border.html">Cómo Usar Bordes</a></div>
                <div class="linkAHEAD"><a href="problems.html">Resolviendo Problemas Comunes con los Componentes</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Creando una IGU (Interfaz Gráfica de Usuario) con JFC/Swing<br />
                <b>Lección:</b> Usando Componentes Swing<br />
                <b>Sección:</b> Usando Componentes de Texto
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Creando una IGU (Interfaz Gráfica de Usuario) con JFC/Swing</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Usando Componentes Swing</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="text.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="textapi.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Características del Componente de Texto</h1>
            </div>
            <div id="PageContent">
                <p>
                    La clase
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/JTextComponent.html">
                        <code>JTextComponent</code></a> es la base para los componentes de texto de Swing. Esta clase ofrece las
                    siguientes características personalizables para todos sus descendientes:
                </p>
                <ul>
                    <li>
                        Un modelo, conocido como un <em>documento</em>, que gestiona el contenido del componente.
                    </li>
                    <li>
                        Una vista, la cual visualiza el componente en pantalla.
                    </li>
                    <li>
                        Un controlador, conocido como un <em>kit de editor</em>, que lee y escribe texto e implementa las
                        capacidades de edición con <a class="TutorialLink" target="_top" href="../misc/action.html">acciones</a>.
                    </li>
                    <li>
                        Soporte para deshacer y rehacer infinito.
                    </li>
                    <li>
                        Un signo de intercalación (o cursor) enchufable y soporte para oyentes del cambio de cursor y filtros de
                        navegación.
                    </li>
                </ul>
                <p>
                    Vea el ejemplo llamado <code>TextComponentDemo</code> para explorar estas capacidades. Aunque el ejemplo
                    <code>TextComponentDemo</code> contiene una instancia personalizada de <code>JTextPane</code>, las
                    características descritas en esta sección son heredadas por todas las subclases de <code>JTextComponent</code>.
                </p>
                <p style="text-align:center">
                    <img src="../../figures/uiswing/components/TextComponentDemoMetal.png" width="343" height="368" 
                         alt="Una instantánea de TextComponentDemo, que contiene un panel de texto personalizado y un área de texto
                         estándar" />
                </p>
                <p>
                    El componente de texto de más arriba es el panel de texto personalizado. El componente de texto de más abajo es
                    una instancia de <code>JTextArea</code>, la cual sirve como un histórico que informa de todos los cambios hechos
                    al contenido del panel de texto. La línea de estado en la parte inferior de la ventana informa de la ubicación
                    de la selección o de la posición del cursor en función del texto seleccionado.
                </p>
                <div class="note">
                    <hr />
                    <strong>Pruebe esto:</strong>&nbsp;
                    <ol>
                        <li>
                            Pulse el botón Lanzar para ejecutar TextComponentDemo usando
                            <a class="OutsideLink" target="_blank" 
                               href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html">
                                Java&trade; Web Start
                            </a> (
                            <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                descargue el EDD 7 o posterior
                            </a>)
                            . Alternativamente, para compilar y ejecutar el ejemplo por usted mismo, consulte el
                            <a href="../examples/components/index.html#TextComponentDemo">índice de ejemplos</a>.
                            <a href="https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/TextComponentDemoProject/TextComponentDemo.jnlp">
                                <img src="../../images/jws-launch-button.png" width="88" height="23" 
                                     alt="Lanza la Aplicación TextComponentDemo" />
                            </a>
                            <br />
                        </li>
                        <li>
                            Use el ratón para seleccionar texto y coloque el cursor en el panel de texto. La información sobre la
                            selección y el cursor es visualizada al final de la ventana.
                        </li>
                        <li>
                            Introduzca texto tecleando en el teclado. Puede mover el cursor alrededor usando las teclas de fecha del
                            teclado o los cuatro atajos de teclado de emacs: Ctrl-B (un carácter hacia atrás), Ctrl-F (un carácter
                            hacia delante), Ctrl-N (abajo una línea), and Ctrl-P (arriba una línea).
                        </li>
                        <li>
                            Abra el menú de Edición, y use los items de menú para editar texto en el panel de texto. Haga una
                            selección en el área de texto al final de ventana. Debido a que el área de texto no es editable, sólo
                            algunos de los comandos del menú Editar, como copiar al portapapeles, funcionan. Es importante tener en
                            cuenta, sin embargo, que el menú funciona en ambos componentes de texto.
                        </li>
                        <li>
                            Use los ítems del menú Estilo para aplicar diferentes estilos al texto en el panel de texto.
                        </li>
                    </ol>
                    <hr />
                </div>
                <p>
                    Usando el ejemplo <code>TextComponentDemo</code> como un punto de referencia, esta sección cubre los siguientes
                    tópicos:
                </p>
                <ul>
                    <li><a href="#commands">Asociar Acciones de Texto con Menús y Botones</a></li>
                    <li><a href="#bindingkeystrokes">Asociar Acciones de Texto con Pulsaciones de Teclas</a></li>
                    <li><a href="#undo">Implementar Deshacer y Rehacer</a></li>
                    <li><a href="#document">Conceptos: Acerca de los Documentos</a></li>
                    <li><a href="#filter">Implementar un Filtro de Documento</a></li>
                    <li><a href="#doclisteners">Monitorizar Cambios en un Documento</a></li>
                    <li><a href="#caret">Monitorizar los Cambios de Selección y del Cursor</a></li>
                    <li><a href="#editorkits">Conceptos: Acerca de los Kits de Editor</a></li>
                </ul>
                <h2>
                    <a id="commands">Asociar Acciones de Texto con Menús y Botones</a>
                </h2>
                <p>
                    Todos los componentes de texto de Swing soportan los comandos de edición estándar tales como cortar, copiar, 
                    pegar, e insertar caracteres. Cada comando de edición es representado e implementado por un objeto 
                    <code>Action</code>. (Para aprender más sobre las acciones vea
                    <a class="TutorialLink" target="_top" href="../misc/action.html">Cómo Usar Acciones</a>). Las acciones le
                    permiten asociar un comando con un componente del IGU, tal como un item de menú o un botón, y de esta forma
                    construir un IGU alrededor de un componente de texto.
                </p>
                <p>
                    Puede invocar el método <code>getActions</code> en cualquier componente de texto para recibir un vector
                    conteniendo todas las acciones soportadas por este componente. Es también posible cargar el vector de acciones
                    en un <code>HashMap</code> de forma que su programa pueda recuperar una acción por nombre. Aquí tiene el código
                    del ejemplo <code>TextComponentDemo</code> que toma las acciones del panel de texto y las carga en un 
                    <code>HashMap</code>.
                </p>
                <div class="codeblock">
                    <pre>
private HashMap&lt;Object, Action&gt; createActionTable(JTextComponent textComponent) {
        HashMap&lt;Object, Action&gt; actions = new HashMap&lt;Object, Action&gt;();
        Action[] actionsArray = textComponent.getActions();
        for (int i = 0; i &lt; actionsArray.length; i++) {
            Action a = actionsArray[i];
            actions.put(a.getValue(Action.NAME), a);
        }
        return actions;
    }
                    </pre>
                </div>
                <p>
                    Aquí está el método para recuperar una acción por su nombre desde el mapa hash:
                </p>
                <div class="codeblock">
                    <pre>
private Action getActionByName(String name) {
    return actions.get(name);
}
                    </pre>
                </div>
                <p>
                    Puede usar ambos métodos literalmente en sus programas.
                </p>
                <p>
                    El siguiente código muestra cómo el item de menú Cortar es creado y asociado con la acción de eliminar texto
                    del componente de texto.
                </p>
                <div class="codeblock">
                    <pre>
protected JMenu createEditMenu() {
    JMenu menu = new JMenu("Edit");
    ...
    menu.add(getActionByName(DefaultEditorKit.cutAction));
    ...
                    </pre>
                </div>
                <p>
                    Este código obtiene la acción por nombre usando el método práctico mostrado previamente. Entonces añade la
                    acción al menú. Eso es todo lo que necesita hacer. El menú y la acción se ocupan de todo lo demás. Dese cuenta
                    de que el nombre de la acción viene desde
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/DefaultEditorKit.html">
                        <code>DefaultEditorKit</code></a>. Este kit ofrece acciones para la edición básica de texto y es la
                    superclase para todos los kits de editor ofrecidos por Swing. Así sus capacidades están disponibles para
                    todos los componentes de texto a menos que sean sobreescritos por una personalización.
                </p>
                <p>
                    Por eficiencia, los componentes de texto comparten acciones. El objeto <code>Action</code> devuelto por
                    <code>getActionByName(DefaultEditorKit.cutAction)</code> es compartido por el <code>JTextArea</code> no editable
                    al final de la ventana. Esta característica de reparto tiene dos importantes ramificaciones:
                </p>
                <ul>
                    <li>
                        En general, usted no modificará objetos <code>Action</code> que obtiene de los kits de editor. Si usted lo
                        hace, los cambios afectarán a todos los componentes de texto en su programa.
                    </li>
                    <li>
                        Los objetos <code>Action</code> pueden operar sobre otros componentes de texto en el programa, algunas veces
                        más de lo que usted querría. En este ejemplo, incluso aunque no es editable, la <code>JTextArea</code>
                        comparte acciones con el <code>JTextPane</code>. (Seleccione algún texto en el área de texto, entonces
                        elija el item de menu cortar-al-portapapeles. Oirá un pitido porque el área de texto no es editable). Si no
                        quiere compartir, instancie el objeto <code>Action</code> usted mismo. <code>DefaultEditorKit</code> define
                        una variedad de útiles subclases <code>Action</code>.
                    </li>
                </ul>
                <p>
                    Aquí está el código que crea el menú Estilo y coloca el item de Menú Negrita en él:
                </p>
                <div class="codeblock">
                    <pre>
protected JMenu createStyleMenu() {
    JMenu menu = new JMenu("Style");
 
    Action action = new StyledEditorKit.BoldAction();
    action.putValue(Action.NAME, "Bold");
    menu.add(action);
    ...
                    </pre>
                </div>
                <p>
                    El <code>StyledEditorKit</code> ofrece subclases <code>Action</code> para implementar comandos de edición para
                    texto estilizado. Observará que en lugar de obtener la acción del kit del editor, este código crea una instancia
                    de la clase <code>BoldAction </code>. De esta forma, esta acción no está compartida con ningún otro componente
                    de texto, y cambiar su nombre no afectará a ningún otro componente de texto.
                </p>
                <h2>
                    <a id="bindingkeystrokes">Asociar Acciones de Texto con Pulsaciones de Teclas</a>
                </h2>
                <p>
                    Además de asociar una acción con un componente del IGU, puede también asociar una acción con una pulsación de
                    tecla usando el mapa de entrada de un componente de texto. Los mapas de entrada están descritos en
                    <a class="TutorialLink" target="_top" href="../misc/keybinding.html">Cómo Usar Atajos de Teclado</a>.
                </p>
                <p>
                    El panel de texto en el ejemplo <code>TextComponentDemo</code> soporta cuatro atajos de teclado no ofrecidos por
                    defecto.
                </p>
                <ul>
                    <li>Ctrl-B para mover el cursor hacia atrás un carácter</li>
                    <li>Ctrl-F para mover el cursor hacia delante un carácter</li>
                    <li>Ctrl-N para mover el cursor hacia abajo una línea</li>
                    <li>Ctrl-P para mover el cursor hacia arriba una línea</li>
                </ul>
                <p>
                    El código siguiente añade el atajo de teclado Ctrl-B al panel de texto. El código para añadir los otros tres
                    atajos listados encima es similar.
                </p>
                <div class="codeblock">
                    <pre>
InputMap inputMap = textPane.getInputMap();

KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_B,
                                       Event.CTRL_MASK);
inputMap.put(key, DefaultEditorKit.backwardAction);
                    </pre>
                </div>
                <p>
                    Primero, el código obtiene el mapa de entrada del componente de texto. A continuación, encuentra un objeto
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/javax/swing/KeyStroke.html">
                        <code>KeyStroke</code></a> que representa la secuencia de teclas Ctrl-B. Finalmente, el código enlaza la
                    pulsación de la tecla a la <code>Acción</code> que mueve el cursor hacia atrás.
                </p>
                <h2>
                    <a id="undo">Implementar Deshacer y Rehacer</a>
                </h2>
                <p>Implementar deshacer y rehacer tiene dos partes:</p>
                <ul>
                    <li>
                        <a href="#undoableedits">Recordar las ediciones que no se pueden modificar</a>.
                    </li>
                    <li>
                        <a href="#undoredoactions">Implementar los comandos deshacer y rehacer</a> y ofrecer un interfaz de usuario
                        para ellos.
                    </li>
                </ul>
                <p>
                    <a id="undoableedits"><strong>Parte 1: Recordar las ediciones que no se pueden modificar</strong></a>
                    <br />
                    Para soportar deshacer y rehacer, un componente de texto debe recordar cada edición que ocurra, el orden de las
                    ediciones, y qué es necesario para deshacer cada edición. El programa de ejemplo usa una instancia de la clase
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/javax/swing/undo/UndoManager.html">
                        <code>UndoManager</code></a> para gestionar su lista de ediciones que no se pueden modificar. El gestor de
                    deshacer es creado donde las variables miembro están declaradas:
                </p>
                <div class="codeblock">
                    <pre>
protected UndoManager undo = new UndoManager();
                    </pre>
                </div>
                <p>
                    Ahora, veamos como el programa descubre ediciones no reversibles y las añade al gestor de deshacer.
                </p>
                <p>
                    Un documento notifica a los oyentes interesados si una edición no reversible ocurre en el contenido del
                    documento. Un paso importante en la implementación del deshacer y rehacer es registrar un oyente de ediciones
                    no reversibles en el documento del componente de texto. El siguiente código añade una instancia de
                    <code>MyUndoableEditListener</code> al documento del panel de texto:
                </p>
                <div class="codeblock">
                    <pre>
doc.addUndoableEditListener(new MyUndoableEditListener());
                    </pre>
                </div>
                <p>
                    El oyente de ediciones no reversibles usado en nuestro ejemplo añade la edición a la lista del gestor de
                    deshacer:
                </p>
                <div class="codeblock">
                    <pre>
protected class MyUndoableEditListener
          implements UndoableEditListener {
    public void undoableEditHappened(UndoableEditEvent e) {
        //Recuerda las ediciones y actualiza los menúe
        undo.addEdit(e.getEdit());
        undoAction.updateUndoState();
        redoAction.updateRedoState();
    }
}  
                    </pre>
                </div>
                <p>
                    Note que este método actualiza dos objetos: <code>undoAction</code> y <code>redoAction</code>. Estos son los
                    objetos acción enlazados a los items de menú Deshacer y Rehacer, respectivamente. El siguiente paso le muestra
                    cómo crear los items de menú y cómo implementar las dos acciones. Para información general sobre los oyentes de
                    ediciones no reversibles y los eventos de ediciones no reversibles, vea
                    <a href="../events/undoableeditlistener.html">Cómo Escribir un Undoable Edit Listener</a>.
                </p>
                <div class="note">
                    <hr />
                    <strong>Nota:</strong>&nbsp;
                    <p>
                        Por defecto, cada edición no reversible deshace una entrada de carácter simple. Es posible con algún
                        esfuerzo agrupar las ediciones de forma que una serie de pulsacoines de tecla estén combinadas en una
                        edición no reversible. Agrupar las ediciones de esta manera requerirá que defina una clase que intercepte
                        los eventos de ediciones no reversibles desde el documento, combinándolas si es apropiado y reenviando los
                        resultado a su oyente de ediciones no reversibles.
                    </p>
                    <hr />
                </div>
                <p>
                    <a id="undoredoactions"><strong>Parte 2: Implementar los comandos deshacer y rehace</strong></a>
                    <br />
                    El primer paso en implementar deshacer y rehacer es crear las acciones a colocar en el menú Edicióm.
                </p>
                <div class="codeblock">
                    <pre>
JMenu menu = new JMenu("Edit");

//Deshacer y reahcer son acciones de nuestra propia creación
undoAction = new UndoAction();
menu.add(undoAction);

redoAction = new RedoAction();
menu.add(redoAction);
...
                    </pre>
                </div>
                <p>
                    Las acciones deshacer y rehacer son implementadas por subclases personalizadas <code>AbstractAction</code>:
                    <code>UndoAction</code> y <code>RedoAction</code>, respectivamente. Estas clases son clases interiores de la
                    clase primaria del ejemplo.
                </p>
                <p>
                    Cuando el usuario invoca el comando <code>deshacer</code>, el método <code>actionPerformed</code> de la clase
                    <code>UndoAction</code> es llamado:
                </p>
                <div class="codeblock">
                    <pre>
public void actionPerformed(ActionEvent e) {
    try {
        undo.undo();
    } catch (CannotUndoException ex) {
        System.out.println("Incapaz de deshacer: " + ex);
        ex.printStackTrace();
    }
    updateUndoState();
    redoAction.updateRedoState();
}
                    </pre>
                </div>
                <p>
                    Este método llama al método <code>undo</code> del gestor de deshacer y actualiza los items de menú para reflejar
                    el nuevo estado deshacer/rehacer.
                </p>
                <p>
                    Similarmente, cuando el usuario invoca el comando <code>rehacer</code>, el método <code>actionPerformed</code>
                    de la clase <code>RedoAction</code> es llamado:
                </p>
                <div class="codeblock">
                    <pre>
public void actionPerformed(ActionEvent e) {
    try {
        undo.redo();
    } catch (CannotRedoException ex) {
        System.out.println("Incapaz de rehacer: " + ex);
        ex.printStackTrace();
    }
    updateRedoState();
    undoAction.updateUndoState();
}
                    </pre>
                </div>
                <p>
                    Este método es similar al de deshacer, excepto que llama al método <code>redo</code> del gestor de deshacer.
                </p>
                <p>
                    La mayoría del código en las clases <code>UndoAction</code> y <code>RedoAction</code> está dedicado a habilitar
                    u deshabilitar las acciones como sea apropiado al estado actual, y cambian los nombres de los items de menú para
                    reflejar la edición a ser deshecha o rehecha.
                </p>
                <div class="note">
                    <hr />
                    <strong>Nota:</strong>&nbsp;
                    <p>
                        La implmentación de deshacer y rehacer en el ejemplo <code>TextComponentDemo</code> fue tomada de la demo
                        <code>NotePad</code> que viene con el software del KDJ (JDK, en inglés). Muchos programadores también podrán
                        copiar esta implementación de deshacer / rehacer sin modificación.
                    </p>
                    <hr />
                </div>
                <h2>
                    <a id="document">Conceptos: Acerca de los Documentos</a>
                </h2>
                <p>
                    Como otros componentes de Swing, un componente de texto separa sus datos (conocidos como el <em>modelo</em>) de
                    su vista de los datos. Si uste no está aún familiarizado con la división modelo-vista usada por los componentes
                    de Swing, refíerase a
                    <a href="model.html">Cómo Usar Modelos</a>.
                </p>
                <p>
                    Un modelo de un componente de texto es conocido como un <em>documento</em> y es una instancia de una clase que
                    implementa el interfaz
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/Document.html"><code>Document</code></a> 
                    . Un documento ofrece los siguientes servicios a un componente de texto:
                </p>
                <ul>
                    <li>
                        Contiene el texto. Un documento almacena el contenido textual en objetos <code>Element</code>, los cuales
                        pueden representar cualquier estructura lógica de texto, tales como parráfos, o texto que comparten estilos.
                        No describiremos los objetos <code>Element</code> aquí.
                    </li>
                    <li>
                        Ofrece soporte para editar el texto a través de los métodos <code>remove</code> y <code>insertString</code>.
                    </li>
                    <li>
                        Notifica a los oyentes del documento y a los oyentes de ediciones no reversibles de los cambios en el texto.
                    </li>
                    <li>
                        Gestiona los objetos <code>Position</code> , los cuales monitorizan una ubicación particular dentro del
                        texto incluso mientraws el texto es modificado.
                    </li>
                    <li>
                        Le permite obtener información sobre el texto, tal como su longitud, y segmentos del texto como una cadena.
                    </li>
                </ul>
                <p>
                    El paquete de texto de Swing contiene una subinterfaz de <code>Document</code>,
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/StyledDocument.html">
                        <code>StyledDocument</code></a>, que añade soporte para marcar el texto con estilos. Una subclase de
                    <code>JTextComponent</code>, <code>JTextPane</code>, requiere que su documento sea un
                    <code>StyledDocument</code> más que simplemente un <code>Document</code>.
                </p>
                <p>
                    El paquete <code>javax.swing.text</code> ofrece la siguiente jerarquía de clases documento, las cuales
                    implementan los documentos especializados para las varias subclases de <code>JTextComponent</code>:
                </p>
                <p style="text-align:center">
                    <img src="../../figures/uiswing/components/10model.gif" width="444" height="187" 
                         alt="La jerarquía de clases documento que javax.swing.text ofrece." />
                </p>
                <p>
                    Un <code>PlainDocument</code> es el documento por defecto para los campos de texto, los campos de contraseña y
                    las áreas de texto. <code>PlainDocument</code> ofrece un contenedor básico para el texto donde todo el texto
                    es mostrado con la misma fuente. Incluso aunque un panel editor es una componente de texto estilizado, usa una
                    instancia de <code>PlainDocument</code> por defecto. El documento por defecto para un <code>JTextPane</code>
                    estándar es una instancia de <code>DefaultStyledDocument</code> &HorizontalLine; un contenedor para texto
                    estilizado en ninguna forma particular. Sin embargo, la instancia de documento usada por un panel de edición 
                    particular o panel de texto depende del tipo de contenido vinculado a él. Si usted usa el método 
                    <code>setPage</code> para cargar texto en un panel de edición o panel de texto, la instancia del documento usado
                    por el panel podría cambiar. Refíerase a <a href="editorpane.html">
                        Cómo Usar Paneles de Edición y Paneles de Texto</a> para los detalles.
                </p>
                <p>
                    Aunque puede establecer el documento de un componente de texto, es usualmente más facil permitirle establecerlo
                    automáticamente, y si es necesario usar un <em>filtro de documento</em> para cambiar cómo los datos de un
                    componente de texto son establecidos. Puede implementar ciertas personalizaciones ya sea instalando un filtro
                    de documento o reemplazando el documento del componente de texto con uno propio. Por ejemplo, el panel de texto
                    en el ejemplo <code>TextComponentDemo</code> tiene un filtro de documento que limita el número de caracteres que
                    el panel de texto puede contener.
                </p>
                <h2>
                    <a id="filter">Implementar un Filtro de Documento</a>
                </h2>
                <p>
                    Para implementar un filtro de documento, cree una subclase de
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/DocumentFilter.html">
                        <code>DocumentFilter</code></a> y entonces engánchela a un documento usando el método 
                    <code>setDocumentFilter</code> definido en la clase <code>AbstractDocument</code>. Aunque es posible tener
                    documentos que no desciendan de <code>AbstractDocument</code>, por deefecto los componentes de texto de
                    Swing usan las subclases de <code>AbstractDocument</code> para sus documentos.
                </p>
                <p>
                    La aplicación <code>TextComponentDemo</code> tiene un filtro de documento,
                    <a class="SourceLink" target="_blank" 
                       href="../examples/components/TextComponentDemoProject/src/components/DocumentSizeFilter.java" 
                       onclick="showCode('../../displayCode.html',
                                       '../examples/components/TextComponentDemoProject/src/components/DocumentSizeFilter.java');
                               return false;">
                        <code>DocumentSizeFilter</code>
                    </a>, que limita el número de caracteres que el panel de texto puede contener. Aquí está el código que crea el
                    filtro y lo engancha al documento del panel de texto:
                </p>
                <div class="codeblock">
                    <pre>
<em>...//Donde las variables miembro son declaradas:</em>
JTextPane textPane;
AbstractDocument doc;
static final int MAX_CHARACTERS = 300;
...
textPane = new JTextPane();
...
StyledDocument styledDoc = textPane.getStyledDocument();
if (styledDoc instanceof AbstractDocument) {
    doc = (AbstractDocument)styledDoc;
    doc.setDocumentFilter(new DocumentSizeFilter(MAX_CHARACTERS));
} 
                    </pre>
                </div>
                <p>
                    Para limitar los caracteres permitidos en el documento, <code>DocumentSizeFilter</code> sobreescribe el método
                    <code>insertString</code> de la clase <code>DocumentFilter</code>, la cual es llamada cada vez que se inserta
                    texto en el documento. También sobreescribe el método <code>replace</code>, que es más probable que se llame
                    cuando el usuario pega en un nuevo texto. En general, la inserción de texto puede resultar cuando el usuario
                    teclea o pega nuevo texto, o cuando el método <code>setText</code> es llamado. Aquí está la implementación del
                    método <code>insertString</code> de la clase <code>DocumentSizeFilter</code>:
                </p>
                <div class="codeblock">
                    <pre>
public void insertString(FilterBypass fb, int offs,
                         String str, AttributeSet a)
    throws BadLocationException {

    if ((fb.getDocument().getLength() + str.length()) &lt;= maxCharacters)
        super.insertString(fb, offs, str, a);
    else
        Toolkit.getDefaultToolkit().beep();
}
                    </pre>
                </div>
                <p>
                    El código para <code>replace</code> es similar. El parámetro
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/DocumentFilter.FilterBypass.html">
                        <code>FilterBypass</code></a> a los métodos definidos por la clase <code>DocumentFilter</code> es
                    simplemente un objeto que habilita al documento ser actualizado de forma segura en multihilo.
                </p>
                <p>
                    Debido a que el filtro de documentos anterior se refiere a las adicciones a los datos del documento, sólo 
                    sobreescribe los métodos <code>insertString</code> y <code>replace</code>. La mayoría de los filtros de
                    documentos sobreescribirán también el método <code>remove</code> de <code>DocumentFilter</code>.
                </p>
                <h2>
                    <a id="doclisteners">Monitorizar Cambios en un Documento</a>
                </h2>
                <p>
                    Puede registrar dos tipos diferentes de oyentes sobre un documento: oyentes de documento y oyentes de ediciones
                    no reversibles. Esta subsección describe los oyentes de docomento. Para información sobre los oyentes de
                    ediciones no reversibles, refíerase a <a href="#undo">Implementar Deshacer y Rehacer</a>.
                </p>
                <p>
                    Un documento notifica a los oyentes de documento registrados de los cambios al documento. Use un oyente de
                    documento para crear una reacción cuando el sea insertado o eliminado de un documento, o cuando el estilo de
                    texto cambia.
                </p>
                <p>
                    El programa <code>TextComponentDemo</code> usa un oyente de documento para actualizar el historial de cambios
                    cuando un cambio es hecho al panel de texto. La siguiente línea de código registra una instancia de la clase
                    <code>MyDocumentListener</code> como un oyente del documento del panel de texto:
                </p>
                <div class="codeblock">
                    <pre>
doc.addDocumentListener(new MyDocumentListener());
                    </pre>
                </div>
                <p>
                    Aquí está la implementación de la clase <code>MyDocumentListener</code>:
                </p>
                <div class="codeblock">
                    <pre>
protected class MyDocumentListener implements DocumentListener {
    public void insertUpdate(DocumentEvent e) {
        displayEditInfo(e);
    }
    public void removeUpdate(DocumentEvent e) {
        displayEditInfo(e);
    }
    public void changedUpdate(DocumentEvent e) {
        displayEditInfo(e);
    }
    private void displayEditInfo(DocumentEvent e) {
            Document document = (Document)e.getDocument();
            int changeLength = e.getLength();
            changeLog.append(e.getType().toString() + ": "
                + changeLength + " character"
                + ((changeLength == 1) ? ". " : "s. ")
                + " Text length = " + document.getLength()
                + "." + newline);
    }
} 
                    </pre>
                </div>
                <p>
                    El oyente implementa tres métodos para manejar tres tipos diferentes de eventos del documento: inserción,
                    eliminación y cambios de estilo. Las instancia de <code>StyledDocument</code> pueden dispara los tres tipos de
                    eventos. Las instancias de <code>PlainDocument</code> disparan sólo los eventos de inserción y eliminación. Para
                    información general sobre los oyentes del documento y eventos del documento, vea
                    <a href="../events/documentlistener.html">Cómo Escribir un Document Listener</a>.
                </p>
                <p>
                    <a id="dontdothis"></a> Recuerde que el filtro de documento para este panel de texto limita el número de 
                    caracteres permitidos en el documento. Si intenta añadir más texto del que el filtro de documento permite, el 
                    filtro de documento bloqueará el cambio y el método del oyente <code>insertUpdate</code> no será llamado. Los
                    oyentes de documento son notificados de los cambios sólo si el cambio ha ocurrido ya.
                </p>
                <p>
                    Puede querer cambiar el texto del documento dentro de un oyente de documento.
                    <strong>
                        Sin embargo, nunca debería modificar el contenido de un componente de texto desde dentro de un oyente de
                        documento.
                    </strong>
                    Si lo hace, el programa probablemente se bloqueará. En vez de eso, puede usar un campo de texto formateado o
                    proveer un filtro de documento.
                </p>
                <h2>
                    <a id="caret">Monitorizar los Cambios de Selección y del Cursor</a>
                </h2>
                <p>
                    El programa <code>TextComponentDemo</code> usa un oyente de cursor para mostrar la posición actual del cursor o,
                    si se ha seleccionado texto, la extensión de la selección.
                </p>
                <p>
                    La clase del oyente del cursor en este ejemplo es una subclase de <code>JLabel</code>. Aquí está el código que
                    crea la etiqueta oyente del cursor y la hace un oyente del cursor del panel de texto:
                </p>
                <div class="codeblock">
                    <pre>
//Crea el área de estado
CaretListenerLabel caretListenerLabel = new CaretListenerLabel(
                                                "Caret Status");
...
textPane.addCaretListener(caretListenerLabel);
                    </pre>
                </div>
                <p>
                    Un oyente de cursor debe implementar un método, <code>caretUpdate</code>, el cual es llamadao cada vez que el
                    cursor se mueve o se cambia la selección. Aquí está la implementación de <code>caretUpdate</code> de
                    <code>CaretListenerLabel</code>:
                </p>
                <div class="codeblock">
                    <pre>
public void caretUpdate(CaretEvent e) {
    //Obtiene la ubicación en el texto
    int dot = e.getDot();
    int mark = e.getMark();
    if (dot == mark) {  // sin selección
        try {
            Rectangle caretCoords = textPane.modelToView(dot);
            //Lo convierte a coordenadas de vista
            setText("caret: text position: " + dot +
                    ", view location = [" +
                    caretCoords.x + ", " + caretCoords.y + "]" +
                    newline);
        } catch (BadLocationException ble) {
            setText("caret: text position: " + dot + newline);
        }
     } else if (dot &lt; mark) {
        setText("selection from: " + dot + " to " + mark + newline);
     } else {
        setText("selection from: " + mark + " to " + dot + newline);
     }
}

                    </pre>
                </div>
                <p>
                    Como puede ver, este oyente actualiza su etiqueta de texto para reflejar el estado actual del cursor o la 
                    selección. El oyente obtiene la información a mostrar del objeto de evento del cursor. Para información general 
                    sobre los oyentes del cursor y los eventos del cursor, vea 
                    <a href="../events/caretlistener.html">Cómo Escribir un Caret Listener</a>.
                </p>
                <p>
                    Como con los oyentes del documento, un oyente del cursor es pasivo. Reacciona a cambios en el cursor o en la 
                    selección, pero no cambia el cursor o la selección por sí mismo. Si quiere cambiar el cursor o la selección, use
                    un <em>filtro de navegación</em> o un cursor personalizado.
                </p>
                <p>
                    Implementar un filtro de navegación es similar a implementar un filtro de documento. Primero, escriba una
                    subclase de
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/NavigationFilter.html">
                        <code>NavigationFilter</code></a>. Entonces enganche una instancia de la subclase a un componente de texto
                    con el método <code>setNavigationFilter</code>.
                </p>
                <p>
                    Podría crear un cursor personalizado para personalizar la apariencia de un cursor. Para crear un cursor
                    personalizado, escriba una clase que implemente el interfaz
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/Caret.html"><code>Caret</code></a>
                    &HorizontalLine; quizás extendiendo la clase
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/DefaultCaret.html">
                        <code>DefaultCaret</code></a>. Entonces provea una instancia de su clase como un argumento al método
                    <code>setCaret</code> del componente de texto.
                </p>
                <h2>
                    <a id="editorkits">Conceptos: Acerca de los Kits de Editor</a>
                </h2>
                <p>
                    Los componentes de texto usan un <code>EditorKit</code> para unir las distintas partes de un componente de texto
                    juntas. El kit editor ofrece la factoría de vista, el documento, el cursor, y las acciones. Un kit editor
                    también lee y escribe documentos de un formato particular. Aunque todos los componentes de texto usan kits
                    editor, algunos componentes ocultan los suyos. Usted no puede establecer u obtener el kit editor usado por un
                    campo de texto o un área de texto. Los paneles de edición y los paneles de texto ofrecen el método
                    <code>getEditorKit</code> para obtener el kit editor actual y el método <code>setEditorKit</code> para
                    cambiarlo.
                </p>
                <p>
                    Para todos los componentes, la clase <code>JTextComponent</code> ofrece la IPA para que usted indirectamente
                    invoque o personalize algunas capacidades del kit editor. Por ejemplo, <code>JTextComponent</code> ofrece los
                    métodos <code>read</code> y <code>write</code>, los cuales invocan los métodos <code>read</code> y
                    <code>write</code> del kit editor. <code>JTextComponent</code> también ofrece un método,
                    <code>getActions</code>, el cual devuelve todas las acciones soportadas por un componente.
                </p>
                <p>
                    El paquete de texto de Swing ofrece los siguientes kits de editor:
                </p>
                <dl>
                    <dt>
                        <a class="APILink" target="_blank" 
                           href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/DefaultEditorKit.html">
                            <code>DefaultEditorKit</code></a>
                    </dt>
                    <dd>
                        Lee y escribe texto plano, y ofrece un conjunto básico de comandos de edición. Los detalles sobre cómo 
                        el sistema de texto trata los saltos de línea pueden ser encontrados en la documentación del IPA de 
                        <code>DefaultEditorKit</code>. Brevemente, el carácter &#39;\n&#39; es usado internamente, pero el
                        documento o los separadores de línea de la plataforma son usados cuando se escriben ficheros. Todos los
                        otros kits de editor son descendientes de la clase <code>DefaultEditorKit</code>.
                    </dd>
                    <dt>
                        <a class="APILink" target="_blank" 
                           href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/StyledEditorKit.html">
                            <code>StyledEditorKit</code></a>
                    </dt>
                    <dd>
                        Lee y escribe texto estilizado, y ofrece un conjunto mínimo de accinoes para texto estilizado. Esta clase es
                        una subclase de <code>DefaultEditorKit</code> y es el kit de editor usado por <code>JTextPane</code> por
                        defecto.
                    </dd>
                    <dt>
                        <a class="APILink" target="_blank" 
                           href="https://docs.oracle.com/javase/8/docs/api/javax/swing/text/html/HTMLEditorKit.html">
                            <code>HTMLEditorKit</code></a>
                    </dt>
                    <dd>
                        Lee, escribe, y edita HTML. Este es una sublcase de <code>StyledEditorKit</code>.
                    </dd>
                </dl>
                <p>
                    Cada uno de los kits de editor listados encima han sido registrados con la clase <code>JEditorPane</code>
                    y asociados con el formato de texto que el kit lee, escribe, y edita. Cuando un fichero es cargado dentro de un
                    panel de edición, el panel comprueba el formato del fichero contra sus kits registrados. Si un kit registrado es
                    encontrado que soporta ese formato de fichero, el panel usa el kit para leer el fichero, mostrarlo, y editarlo.
                    Así, el panel de edición efectivamente se transforma a sí mismo en un editor para ese formato de texto. Puede
                    extender <code>JEditorPane</code> para soportar su propio formato de texto creando un kit de editor para él, y
                    entonces usar <code>registerEditorKitForContentType</code> del <code>JEditorPane</code> para asociar su kit con
                    su formato de texto.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="text.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="textapi.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta </a>página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales </a>.
                        </p>
                        <p class="footertext">Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.</p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente <a target="_blank" href="../../information/run-examples.html">
                                Compilando y Ejecutando los Ejemplos: PFs</a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página Anterior:</b> Usando Componentes de Texto<br />
            <b>Página Siguiente:</b> La IPA del Componente de Texto
        </div>
    </body>
</html>