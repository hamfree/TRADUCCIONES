<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Expresiones Lambda (Los Tutoriales de Java&trade; &gt; Aprendiendo el Lenguaje Java &gt; Clases y Objetos)
        </title>
        <meta name="description" content="Este tutorial de Java para principiantes describe los fundamentos de la programación en el
              lenguaje de programación Java" />
        <meta name="keywords" content="java programming, learn java, java sample code, java objects, java classes, java inheritance,
              interfaces, variables, arrays, data types, operators, control flow, number, string" />
        <link rel="stylesheet" href="../../indice.css" type="text/css" />
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper  clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName" >Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div> 
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Clases y Objetos</a></div>
                <div class="linkAHEAD"><a href="classes.html">Clases</a></div>
                <div class="linkBHEAD"><a href="classdecl.html">Declarando Clases</a></div>
                <div class="linkBHEAD"><a href="variables.html">Declarando Variables Miembro</a></div>
                <div class="linkBHEAD"><a href="methods.html">Definiendo Métodos</a></div>
                <div class="linkBHEAD"><a href="constructors.html">Proporcionando Constructores Para Sus Clases</a></div>
                <div class="linkBHEAD"><a href="arguments.html">Pasando Información a un método o a un constructor</a></div>
                <div class="linkAHEAD"><a href="objects.html">Objetos</a></div>
                <div class="linkBHEAD"><a href="objectcreation.html">Creando Objetos</a></div>
                <div class="linkBHEAD"><a href="usingobject.html">Usando Objetos</a></div>
                <div class="linkAHEAD"><a href="more.html">Más sobre Clases</a></div>
                <div class="linkBHEAD"><a href="returnvalue.html">Devolviendo un Valor de un Método</a></div>
                <div class="linkBHEAD"><a href="thiskey.html">Usando la Palabra Clave this</a></div>
                <div class="linkBHEAD"><a href="accesscontrol.html">Controlando el Acceso a los Miembros de una Clase</a></div>
                <div class="linkBHEAD"><a href="classvars.html">Entendiendo los Miembros de una Clase</a></div>
                <div class="linkBHEAD"><a href="initial.html">Inicializando Campos</a></div>
                <div class="linkBHEAD"><a href="summaryclasses.html">Sumario de Creando y Usando Clases y Objetos</a></div>
                <div class="linkQUESTIONS"><a href="QandE/creating-questions.html">Preguntas y Ejercicios</a></div>
                <div class="linkQUESTIONS"><a href="QandE/objects-questions.html">Preguntas y Ejercicios</a></div>
                <div class="linkAHEAD"><a href="nested.html">Clases Anidadas</a></div>
                <div class="linkBHEAD"><a href="innerclasses.html">Ejemplo de Clase Interior</a></div>
                <div class="linkBHEAD"><a href="localclasses.html">Clases Locales</a></div>
                <div class="linkBHEAD"><a href="anonymousclasses.html">Clases Anónimas</a></div>
                <div class="nolinkBHEAD">Expresiones Lambda</div>
                <div class="linkCHEAD"><a href="methodreferences.html">Referencias a Métodos</a></div>
                <div class="linkBHEAD"><a href="whentouse.html">Cuándo Usar Clases Anidadas, Clases Locales, Clases Anónimas y Expresiones Lambda</a></div>
                <div class="linkQUESTIONS"><a href="QandE/nested-questions.html">Preguntas y Ejercicios</a></div>
                <div class="linkAHEAD"><a href="enum.html">Enum Types</a></div>
                <div class="linkQUESTIONS"><a href="QandE/enum-questions.html">Preguntas y Ejercicios</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Aprendiendo el Lenguaje Java<br />
                <b>Lección:</b> Clases y Objetos<br />
                <b>Sección:</b> Clases Anidadas
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Aprendiendo el Lenguaje Java</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Clases y Objetos</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="anonymousclasses.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="methodreferences.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Expresiones Lambda</h1>
            </div>
            <div id="PageContent">
                <p>
                    Un problema con las clases anónimas es que la implementación de sus clases anónimas es muy simple, tal como
                    un interfaz que contiene sólo un método, entonces la sintaxis de las clases anónimas puede parecer difícil de
                    manejar y poco clara. En estos casos, usualmente intentará pasar la funcionalidad como un argumento a otro
                    método, tal como la acción que se debe tomar cuando alguien hace clic en un botón. Las expresiones Lambda le
                    habilitan a hacer esto, para tratar la funcionalidad como un argumento de método, o código como datos.
                </p>
                <p>
                    La sección previa,
                    <a class="TutorialLink" target="_top" href="anonymousclasses.html">Clases Anónimas</a>, muestra cómo implementar 
                    una clase base sin darle un nombre. Aunque esto es a menudo más conciso que una clase nombrada, para las clases
                    con sólo un método, incluso una clase anónima parece un poco excesivo y pesado. Las expresiones Lambda le
                    permiten expresar instancias de clases de un-sólo-método más compactadamente.
                </p>
                <p>
                    Esta sección cubre los siguientes tópicos:
                </p>
                <ul>
                    <li>
                        <a href="#use-case">Caso de Uso Ideal para las Expresiones Lambda</a>
                        <ul>
                            <li>
                                <a href="#approach1">Enfoque 1: Crear Métodos que Busquen Miembros Que Concuerden con una
                                    Característica</a>
                            </li>
                            <li>
                                <a href="#approach2">Enfoque 2: Crear Métodos de Búsqueda Más Generalizados</a>
                            </li>
                            <li>
                                <a href="#approach3">Enfoque 3: Especificar Código de Criterio de Búsqueda en una Clase Local</a>
                            </li>
                            <li>
                                <a href="#approach4">Enfoque 4: Especificar Código de Criterio de Búsqueda en una Clase Anónima</a>
                            </li>
                            <li>
                                <a href="#approach5">Enfoque 5: Especificar Código de Criterio de Búsqueda con una Expresión
                                    Lambda</a>
                            </li>
                            <li>
                                <a href="#approach6">Enfoque 6: Usar Interfaces Funcionales Estándar con Expresiones Lambda</a>
                            </li>
                            <li>
                                <a href="#approach7">Enfoque 7: Usar Expresiones Lambda a lo Largo de Su Aplicación</a>
                            </li>
                            <li>
                                <a href="#approach8">Enfoque 8: Usar Genéricos Más Extensamente</a>
                            </li>
                            <li>
                                <a href="#approach9">Enfoque 9: Usar Operaciones de Agregados que Aceptan Expresiones Lambda como
                                    Parámetros</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="#lambda-expressions-in-gui-applications">Expresiones Lambda en Aplicaciones IGU (GUI en inglés)</a>
                    </li>
                    <li>
                        <a href="#syntax">Sintaxis de las Expresiones Lambda</a>
                    </li>
                    <li>
                        <a href="#accessing-local-variables">Acceder a las Variables Locales del Alcance Envolvente</a>
                    </li>
                    <li>
                        <a href="#target-typing">Tipos de Destino</a>
                        <ul>
                            <li>
                                <a href="#target-types-and-method-arguments">Tipos de Destino y Argumentos de Métodos</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="#serialization">Serialización</a>
                    </li>
                </ul>
                <h2>
                    <a id="use-case">Caso de Uso Ideal para las Expresiones Lambda</a>
                </h2>
                <p>
                    Suponga que está creando una aplicación de red social. Quiere crear una característica que habilite a un 
                    administrador a ejecutar cualquier clase de acción, como el envío de un mensaje, a miembros de la aplicación de 
                    red social que satisfagan ciertos criterios. La siguiente tabla describe éste caso de uso en detalle:
                </p>
                <table class="celda">
                    <caption>Use case for social networking application</caption>
                    <tr>
                        <th id="h1" class="celda">Campo</th>
                        <th id="h2" class="celda">Descripción</th>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda">Nombre</td>
                        <td headers="h2" class="celda">Ejecuta acción sobre miembros seleccionados</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda">Actor Primario</td>
                        <td headers="h2" class="celda">Administrador</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda">Precondiciones</td>
                        <td headers="h2" class="celda">El Administrador está conectado en el sistema.</td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda">Postcondiciones</td>
                        <td headers="h2" class="celda">
                            La acción es ejecutada sólo sobre miembros que se ajustan al criterio especificado.
                        </td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda">Escenario Principal de Éxito</td>
                        <td headers="h2" class="celda">
                            <ol>
                                <li>
                                    El administrador especifica el criterio de los miembros sobre los cuales ejecutar una cierta
                                    acción.
                                </li>
                                <li>
                                    El administrador especifica una acción a ejecutar sobre esos miembros seleccionados.
                                </li>
                                <li>
                                    El administrador selecciona el boton <strong>Enviar</strong>.
                                </li>
                                <li>
                                    El sistema encuentra todos los miembros que coinciden con el criterio especificado.
                                </li>
                                <li>
                                    El sistema ejecuta la acción especificad sobre todos los miembros coincidentes.
                                </li>
                            </ol>
                        </td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda">Extensiones</td>
                        <td headers="h2" class="celda">
                            <p>
                                1a. El administrador tiene una opción para previsualizar esos miembros que coinciden con el criterio
                                especificado antes de que él o ella especifiquen la acción a ser ejecutada o antes de seleccionar el
                                botón <strong>Enviar</strong>.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td headers="h1" class="celda">Frecuencia de Ocurrencia</td>
                        <td headers="h2" class="celda">Muchas veces durante el día.</td>
                    </tr>
                </table>
                <p>
                    Suponga que los miembros de esta aplicación de red social son representados por la siguiente clase
                    <a class="SourceLink" target="_blank" href="examples/Persona.java"
                       onclick="showCode('../../displayCode.html', 'examples/Persona.java'); return false;">
                        <code>Persona</code></a> :
                </p>
                <pre class="codeblock">
public class Persona {

    public enum Sexo {
        MASCULINO, FEMENINO
    }

    String nombre;
    LocalDate cumpleaños;
    Sexo genero;
    String correoElectronico;

    public int getEdad() {
        // ...
    }

    public void imprimePersona() {
        // ...
    }
}
                </pre>
                <p>
                    Suponga que los miembros de su aplicación de red social están almacenados en una instancia
                    <code>List&lt;Person&gt;</code>.
                </p>
                <p>
                    Esta sección empieza con un enfoque ingenuo para este caso de uso. Mejora en este enfoque con clases locales y
                    anónimas, y entonces finaliza con un enfoque eficiente y conciso usando expresiones Lambda. Encuentre los
                    extractos del código descritos en esta sección en el ejemplo
                    <a class="SourceLink" target="_blank" href="examples/AgendaPrueba.java"
                       onclick="showCode('../../displayCode.html', 'examples/AgendaPrueba.java'); return false;">
                        <code>AgendaPrueba</code></a>.
                </p>
                <h3>
                    <a id="approach1">Enfoque 1: Crear Métodos que Busquen Miembros Que Concuerden con una Característica</a>
                </h3>
                <p>
                    Un enfoque simplista es crear varios métodos; cada método busca los miembros que coincidenc con una
                    característica, como el género o la edad. El método siguiente imprime los miembros que son más viejos que una
                    edad especificada:
                </p>
                <pre class="codeblock">
public static void impPersonasMasViejasQue(List&lt;Persona&gt; agenda, int edad) {
    for (Persona p : agenda) {
        if (p.getEdad() &gt;= edad) {
            p.imprimePersona();
        }
    }
}
                </pre>
                <p>
                    <b>Nota</b>: Una
                    <a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">
                        <code>List</code></a> es una
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html"><code>Collection</code></a>
                    ordenada. Una <em>collection</em> es un objeto que agrupa múltiples elementos en una unidad simple. Las
                    colecciones son usadas para almacenar, recuperar, manipular, y comunicar datos agregados. Para más información
                    sobre las colecciones, vea el recorrido
                    <a class="TutorialLink" target="_top" href="../../collections/index.html">Colecciones</a>.
                </p>
                <p>
                    Este enfoque puede potencialmente hacer sus aplicación <em>frágil</em>, lo que es la probabilidad de una
                    aplicación que no funcione proque la introducción de actualizaciones (como nuevos tipos de datos). Suponga que
                    usted actualiza su aplicación y cambia la estructura de la clase <code>Persona</code> de forma que contiene
                    diferentes variables miembro; quizás la clase graba y mide las edades con un tipo diferente de dato o algoritmo.
                    Tendría que reescribir un montón de su IPA para acomodar este cambio. Además, este enfoque es innecesariamente
                    restrictivo; ¿lo que usted quería era imprimir miembros más jovenes que una cierta edad, por ejemplo?
                </p>
                <h3>
                    <a id="approach2">Enfoque 2: Crear Métodos de Búsqueda Más Generalizados</a>
                </h3>
                <p>
                    El siguiente método es más genérico que <code>impPersonasMasViejasQue</code>; imprime miembros que se
                    encuentran en un rango especificado de edades:
                </p>
                <pre class="codeblock">
public static void impPersonasEnElRangoDeEdad(
    List&lt;Persona&gt; agenda, int bajo, int alto) {
    for (Persona p : agenda) {
        if (bajo &lt;= p.getEdad() &amp;&amp; p.getEdad() &lt; alto) {
            p.imprimePersona();
        }
    }
}
                </pre>
                <p>
                    ¿Qué ocurre si usted quiere imprimir los miembros de un sexo especificado, o una combianción de un género 
                    especificado y un rango de edad? ¿Qué ocurre si usted decide cambiar la clase <code>Persona</code> y añadir
                    otros atributos tales como el estado civil o la ubicación geográfica? Aunque este método es más genérico que 
                    <code>impPersonasMasViejasQue</code>, intentar crear un método separado para cada posible consulta de búsqueda
                    puede aún dar lugar a código quebradizo. En su lugar puede separar el código que especifica los criterios en los
                    que desea buscar en una clase diferente.
                </p>
                <h3>
                    <a id="approach3">Enfoque 3: Especificar Código de Criterio de Búsqueda en una Clase Local</a>
                </h3>
                <p>
                    El siguiente método imprime los miembros que coinciden con el criterio de búsqueda que usted especifica:
                </p>
                <pre class="codeblock">
public static void imprimePersonas(
    List&lt;Persona&gt; agenda, CompruebaPersona comprobador) {
    for (Persona p : agenda) {
        if (comprobador.test(p)) {
            p.imprimePersona();
        }
    }
}
                </pre>
                <p>
                    Este método comprueba cada instancia de <code>Persona</code> contenida en el parámetro <code>List</code>
                    <code>agenda</code> si satisface el criterio de búsqueda especificado en el parámetro
                    <code>CompruebaPersona</code> <code>comprobador</code> invocando el método <code>comprobador.test</code>. Si el
                    método <code>comprobador.test</code> devuelve un valor <code>verdadero</code> , entonces el método
                    <code>imprimirPersonas</code> es invocado sobre la instancia <code>Persona</code> .
                </p>
                <p>
                    Para especificar el criterio de búsqueda, usted implementa el interfaz <code>CompruebaPersona</code> :
                </p>
                <pre class="codeblock">
interface CompruebaPersona {
    boolean test(Persona p);
}
                </pre>
                <p>
                    La siguiente clase implementa el interfaz <code>CompruebaPersona</code> especificando una implementación para el
                    método <code>test</code>. Este método filtra los miembros que son elegibles para el Servicio Selectivo en los
                    Estados Unidos: devuelve un valor <code>verdadero</code> si el parámetro <code>Persona</code> es masculino y
                    entre las edades de 18 y 25:
                </p>
                <pre class="codeblock">
class CompruebaPersonaElegibleParaServicioSelectivo implements CompruebaPersona {
    public boolean test(Persona p) {
        return p.genero == Persona.Sexo.MASCULINO &amp;&amp;
            p.getEdad() &gt;= 18 &amp;&amp;
            p.getEdad() &lt;= 25;
    }
}
                </pre>
                <p>
                    Para usar esta clase, usted crea una nueva instancia de ellas e invoca el método <code>imprimirPersonas</code> :
                </p>
                <pre class="codeblock">
imprimePersonas(agenda, new CompruebaPersonaElegibleParaServicioSelectivo());
                </pre>
                <p>
                    Aunque este enfoque es menos frágil &mdash; no tiene que reescribir los métodos si cambia la estrcutura de
                    <code>Persona</code> &mdash; aún tiene código adicional: un nuevo interfaz y una clase local para cada búsqueda
                    que planea ejecutar en su aplicación. Debido a que <code>CompruebaPersonaElegibleParaServicioSelectivo</code>
                    implementa una interfaz, puede usar una clase anónima en vez de una clase local y pasar por alto la necesidad de
                    declarar una nueva clase para cada búsqueda.
                </p>
                <h3>
                    <a id="approach4">Enfoque 4: Especificar Código de Criterio de Búsqueda en una Clase Anónima</a>
                </h3>
                <p>
                    Uno de los argumentos de la siguiente invocación del método <code>imprimePersonas</code> es una clase anónima
                    que filtra los miembros que son elegibles para el Servicio Selectivo en los Estados Unidos: aquellos que son
                    varones y están entre las edades de 18 y 25:
                </p>
                <pre class="codeblock">
imprimePersonas(
    agenda,
    new CompruebaPersona() {
        public boolean test(Persona p) {
            return p.getGenero() == Persona.Sexo.MASCULINO
                &amp;&amp; p.getEdad() &gt;= 18
                &amp;&amp; p.getEdad() &lt;= 25;
        }
    }
);
                </pre>
                <p>
                    Este enfoque reduce la cantidad de código requerido porque no tiene que crear una nueva clase para cada búsqueda
                    que quiera realizar. Sin embargo, la sintaxis de las clases anónimas es abultada considerando que el interfaz
                    <code>CompruebaPersona</code> contiene sólo un método. En este caso, puede usar una expresión lambda en vez de
                    una clase anónima,como se describe en la siguiente sección.
                </p>
                <h3>
                    <a id="approach5">Enfoque 5: Especificar Código de Criterio de Búsqueda con una Expresión Lambda</a>
                </h3>
                <p>
                    El interfaz <code>CompruebaPersona</code> es un <i>interfaz functional</i>. Un interfaz functional es cualquier
                    interfaz que contiene sólo un
                    <a class="TutorialLink" target="_top" href="../../java/IandI/abstract.html">método abstracto</a>. (Un interfaz
                    funcional puede contener uno o más
                    <a class="TutorialLink" target="_top" href="../../java/IandI/defaultmethods.html">métodos por defecto</a> o
                    <a class="TutorialLink" target="_top" href="../../java/IandI/defaultmethods.html#static">métodos estáticos</a>).
                    Debido a que un interfaz functional contiene sólo un método abstracto, puede omitir el nombre de ese
                    método cuando lo implementa. Para hacer esto, en vez de usar una expresión de clase anónima, usted usa una
                    <i>expresión lambda</i>, la cual está destacada en la siguiente invocación al método:
                </p>
                <pre class="codeblock">
imprimePersonas(
    agenda,
    <strong>(Persona p) -&gt; p.getGenero() == Persona.Sexo.MASCULINO
        &amp;&amp; p.getEdad() &gt;= 18
        &amp;&amp; p.getEdad() &lt;= 25</strong>
);
                </pre>
                <p>
                    Vea la <a href="#syntax">Sintaxis de las Expresiones Lambda</a> para informarse sobre cómo definir las
                    expresiones lambda.
                </p>
                <p>
                    Puede usar un interfaz funcional estándar en lugar del interfaz <code>CompruebaPersona</code>, lo cual reduce
                    incluso más la cantidad de código requerida.
                </p>
                <h3>
                    <a id="approach6">Enfoque 6: Usar Interfaces Funcionales Estándar con Expresiones Lambda</a>
                </h3>
                <p>
                    Reconsidere el interfaz <code>CompruebaPersona</code> :
                </p>
                <pre class="codeblock">
interface CompruebaPersona {
    boolean test(Persona p);
}
                </pre>
                <p>
                    Este es un interfaz muy simple. Es un interfaz funcional porque contiene sólo un método abstracto. Este método
                    toma un parámetro y devuelve un valor <code>booleano</code> . El método es tan simple que podría no valer la
                    pena definir uno en su aplicación. Por consiguiente, el KDJ define varios interfaces estándar funcionales, los
                    cuales puede encontrar en el paquete <code>java.util.function</code>.
                </p>
                <p>
                    Por ejemplo, puede suar el interfaz <code>Predicate&lt;T&gt;</code> en vez de <code>CompruebaPersona</code>.
                    Este interfaz contiene el método <code>boolean test(T t)</code>:
                </p>
                <pre class="codeblock">
interface Predicate&lt;T&gt; {
    boolean test(T t);
}
                </pre>
                <p>
                    El interfaz <code>Predicate&lt;T&gt;</code> es un ejemplo de un interfaz genérico. (Para más información sobre
                    los genéricos, vea la lección
                    <a class="TutorialLink" target="_top" href="../../java/generics/index.html">Genéricos (Actualizado)</a>). Los
                    tipos genéricos (como los interfaces genéricos) especifican uno o maś tipos de parámetros con
                    paréntesis angulares (<code>&lt;&gt;</code>). Este interfaz contiene sólo un tipo de parámetro, <code>T</code>.
                    Cuando usted declara o instancia un tipo genérico con los argumentos del tipo actual, usted tiene un tipo 
                    parametrizado. Por ejemplo, el tipo parametrizado <code>Predicate&lt;Persona&gt;</code> es el siguiente:
                </p>
                <pre class="codeblock">
interface Predicate&lt;<code>Persona</code>&gt; {
    boolean test(<code>Persona</code> t);
}
                </pre>
                <p>
                    Este tipo parametriazado contiene un método que tiene el mismo tipo de vuelta y parámetros que
                    <code>CompruebaPersona.boolean test(Person p)</code>. Por consiguiente, puede usar
                    <code>Predicate&lt;T&gt;</code> en lugar de <code>CompruebaPersona</code> como el siguiente método demuestra:
                </p>
                <pre class="codeblock">
public static void imprimePersonasConPredicate(
    List&lt;Persona&gt; agenda, Predicate&lt;Persona&gt; comprobador) {
    for (Persona p : agenda) {
        if (comprobador.test(p)) {
            p.imprimePersona();
        }
    }
}
                </pre>
                <p>
                    Como un resultado, la invoación del siguiente método es la misma como cuando invocó <code>imprimePersonas</code>
                    en
                    <a href="#approach3">Enfoque 3: Especificar Código de Criterio de Búsqueda en una Clase Local</a> para obtener
                    miembros que son elegibles para el Servicio Selectivo:
                </p>
                <pre class="codeblock">
imprimePersonasConPredicate(
    agenda,
    p -&gt; p.getGenero() == Persona.Sexo.MASCULINO
        &amp;&amp; p.getEdad() &gt;= 18
        &amp;&amp; p.getEdad() &lt;= 25
);
                </pre>
                <p>
                    Este no es el único posible lugar en este método para usar una expreisón lambda. El siguiente enfoque sugiere
                    otras formas de usar expresiones lambda.
                </p>
                <h3>
                    <a id="approach7">Enfoque 7: Usar Expresiones Lambda a lo Largo de Su Aplicación</a>
                </h3>
                <p>
                    Reconsidere el método <code>imprimePersonasConPredicate</code> para ver donde más podría usar expresiones
                    lambda:
                </p>
                <pre class="codeblock">
public static void imprimePersonasConPredicate(
    List&lt;Persona&gt; agenda, Predicate&lt;Persona&gt; comprobador) {
    for (Persona p : agenda) {
        if (comprobador.test(p)) {
            p.imprimePersona();
        }
    }
}
                </pre>
                <p>
                    Este método comprueba cada instancia de <code>Persona</code> contenida en el parámetro <code>List</code>
                    <code>agenda</code> si satisface el criterio especificado en el parámetro <code>Predicate</code>
                    <code>comprobador</code>. Si la instancia <code>Persona</code> satisface el criterio especificado por
                    <code>comprobador</code>, el método <code>imprimePersona</code> es invocado sobre la instancia
                    <code>Persona</code> .
                </p>
                <p>
                    En vez de invocar el método <code>imprimePersona</code>, puede especificar una acción diferente a ejecutar en
                    estas instancias <code>Persona</code> que satisfacen el criterio especificado por <code>comprobador</code>.
                    Puede especificar esta acción con una expresión lambda. Suponga que quiere una expresión lambda similar a 
                    <code>imprimePersona</code>, una que toma un argumento (un objeto del tipo <code>Persona</code>) y no devuelve
                    nada. Recuerde, para usar una expresión lambda, necesita implementar una interfaz funcioal. En este caso , 
                    necesitamos un interfaz funcional que contenga un método abstracto que pueda tomar un argumento del tipo 
                    <code>Persona</code> y devuelva void. El interfaz <code>Consumer&lt;T&gt;</code> contiene el método
                    <code>void accept(T t)</code>, el cual tiene estas características. El siguiente método reemplaza la invocación
                    <code>p.imprimePersona()</code> con una instancia de
                    <code>Consumer&lt;Persona&gt;</code> que invoca el método <code>accept</code>:
                </p>
                <pre class="codeblock">
public static void procesaPersona(
    List&lt;Persona&gt; agenda,
    Predicate&lt;Persona&gt; comprobador,
    <strong>Consumer&lt;Persona&gt; bloque</strong>) {
        for (Persona p : agemda) {
            if (comprobador.test(p)) {
                <strong>bloque.accept(p);</strong>
            }
        }
}
                </pre>
                <p>
                    Como resultado, la siguiente invocación al método es la misma que cuando yo invoqué 
                    <code>imprimePersonas</code> en
                    <a href="#approach3">
                        Enfoque 3: Especificar Código de Criterio de Búsqueda en una Clase Local
                    </a> para obtener los miembros que son elegibles para el Servicio Selectivo. La expresión lambda usada  para
                    imprimir los miembros está destacada:
                </p>
                <pre class="codeblock">
procesaPersona(
     agenda,
     p -&gt; p.getGenero() == Persona.Sexo.MASCULINO
         &amp;&amp; p.getEdad() &gt;= 18
         &amp;&amp; p.getEdad() &lt;= 25,
     <strong>p -&gt; p.imprimePersona()</strong>
);
                </pre>
                <p>¿Qué ocurre si quiere hacer más con sus perfiles de miembros que visualizarlos. Suponga que quiere validar los
                    perfiles de los miembros o recuperar su información de contacto? En este caso, necesita un interfaz funcional
                    que contenga un método abstracto y devuelve un valor.
                    El interfaz <code>Function&lt;T,R&gt;</code> contiene el método <code>R apply(T t)</code>. El siguiente método
                    recupera los datos especificados por el parámetor <code>mapeador</code>, y entonces ejecuta una acción
                    sobre ella por el parámetro <code>bloque</code>:
                </p>
                <pre class="codeblock">
public static void procesaPersonasConFuncion(
    List&lt;Persona&gt; agenda,
    Predicate&lt;Persona&gt; comprobador,
    Function&lt;Persona, String&gt; mapeador,
    Consumer&lt;String&gt; bloque) {
    for (Persona p : agenda) {
        if (comprobador.test(p)) {
            String data = mapeador.apply(p);
            bloque.accept(data);
        }
    }
}
                </pre>
                <p>
                    El siguiente método recupera las direcciones de correo para cada miembro contenido en la <code>agenda</code>
                    quienes son elegibles para el Servicio Selectivo y entonces las imprime:
                </p>
                <pre class="codeblock">
procesaPersonasConFuncion(
    agenda,
    p -&gt; p.getGenero() == Persona.Sexo.MASCULINO
        &amp;&amp; p.getEdad() &gt;= 18
        &amp;&amp; p.getEdad() &lt;= 25,
    p -&gt; p.getCorreoElectronico(),
    correoElectronico -&gt; System.out.println(correoElectronico)
);              </pre>
                <h3>
                    <a id="approach8">Enfoque 8: Usar Genéricos Más Extensamente</a>
                </h3>
                <p>
                    Reconsidere el método <code>procesaPersonasConFuncion</code>. La siguiente es una versión genérica de aquello
                    que acepta, como un parámetro, una colección que contiene elemnentos de cuaquier tipo de datos:
                </p>
                <pre class="codeblock">
public static &lt;X, Y&gt; void procesaElementos(
    Iterable&lt;X&gt; fuente,
    Predicate&lt;X&gt; comprobador,
    Function &lt;X, Y&gt; mapeador,
    Consumer&lt;Y&gt; bloque) {
    for (X p : fuente) {
        if (comprobador.test(p)) {
            Y datos = mapeador.apply(p);
            bloque.accept(datos);
        }
    }
}
                </pre>
                <p>
                    Para imprimr la dirección de correo electrónico de los miembros que son elegibles para el Servicio Selectivo, 
                    invoque el método <code>procesaElementos</code> como sigue:
                </p>
                <pre class="codeblock">
procesaElementos(
    agenda,
    p -&gt; p.getGenero() == Persona.Sexo.MASCULINO
        &amp;&amp; p.getEdad() &gt;= 18
        &amp;&amp; p.getEdad() &lt;= 25,
    p -&gt; p.getCorreoElectronico(),
    correoElectronico -&gt; System.out.println(correoElectronico)
);
                </pre>
                <p>
                    Esta invocación al método ejecuta las siguientes acciones:
                </p>
                <ol>
                    <li>
                        Obtiene una fuente de objetos de la colección <code>fuente</code>. En este ejemplo, obtiene una fuente de
                        objetos <code>Persona</code> de la colección <code>agenda</code>. Note que la colección <code>agenda</code>,
                        la cual es una colección de tipo <code>List</code>, es también un objeto de tipo <code>Iterable</code>.
                    </li>
                    <li>
                        Filtra los objetos que coinciden el objeto <code>Predicate</code> <code>comprobador</code>. En este ejemplo,
                        el objeto <code>Predicate</code> es una expresión lambda que especifica que miembros son elegibles para el
                        Servicio Selectivo.
                    </li>
                    <li>
                        Mapea cada objeto filtrado a un valor como es especificado por el objeto <code>Function</code>
                        <code>mapeador</code>. En este ejemplo, el objeto <code>Function</code> es una expresión lambda que devuelve
                        la dirección de correo electrónico de un miembro.
                    </li>
                    <li>
                        Ejecuta una acción sobre cada objeto asignado como es especificado por el objeto <code>Consumer</code>
                        <code>bloque</code>. En este ejemplo, el objeto <code>Consumer</code> es una expresión lambda que imprime
                        una cadena, la cual es la dirección de correo electrónico devuelta por el objeto <code>Function</code> .
                    </li>
                </ol>
                <p>
                    Puede reemplazar cada una de estas acciones con una operación agregada.
                </p>
                <h3>
                    <a id="approach9">Enfoque 9: Usar Operaciones de Agregados que Aceptan Expresiones Lambda como Parámetros</a>
                </h3>
                <p>
                    El siguiente ejemplo usa operaciones agregadas para imprimr las direcciones de correo electrónico de esos
                    miembros contenidos en la colección <code>agenda</code> que son elegibles para el Servicio Selectivo:
                </p>
                <pre class="codeblock">
agenda
    .stream()
    .filter(
        p -&gt; p.getGenero() == Persona.Sexo.MASCULINO
            &amp;&amp; p.getEdad() &gt;= 18
            &amp;&amp; p.getEdad() &lt;= 25)
    .map(p -&gt; p.getCorreoElectronico())
    .forEach(correoElectronico -&gt; System.out.println(correoElectronico));
                </pre>
                <p>
                    La siguiente tabla asigna cada una de las operaciones que el método <code>procesaElementos</code> ejecuta con la
                    correspondiente operación agregada:
                </p>
                <table class="celda">
                    <caption>
                        Asignación de cada una de las acciones que realiza procesaElementos con los elementos con la operación agregada
                        correspondiente
                    </caption>
                    <tr>
                        <th id="h101" class="celda"><code>procesaElementos</code> Acción</th>
                        <th id="h102" class="celda">Operación Agregada</th>
                    </tr>
                    <tr>
                        <td headers="h101" class="celda">Obtener una fuente de objetos</td>
                        <td headers="h102" class="celda"><code>Stream&lt;E&gt; <strong>stream</strong>()</code></td>
                    </tr>
                    <tr>
                        <td headers="h101" class="celda">Filtrar objetos que coinciden con un objeto <code>Predicate</code></td>
                        <td headers="h102" class="celda">
                            <code>Stream&lt;T&gt; <strong>filter</strong>(Predicate&lt;? super T&gt; predicate)</code>
                        </td>
                    </tr>
                    <tr>
                        <td headers="h101" class="celda">
                            Mapea objetos a otro valor como es especificado por el objeto <code>Function</code>
                        </td>
                        <td headers="h102" class="celda">
                            <code>&lt;R&gt; Stream&lt;R&gt; <strong>map</strong>(Function&lt;? super T,? extends R&gt; mapper)</code>
                        </td>
                    </tr>
                    <tr>
                        <td headers="h101" class="celda">
                            Ejecuta una acción como es especificado por el objeto <code>Consumer</code>
                        </td>
                        <td headers="h102" class="celda">
                            <code>void <strong>forEach</strong>(Consumer&lt;? super T&gt; action)</code>
                        </td>
                    </tr>
                </table>
                <p>
                    Las operaciones <code>filter</code>, <code>map</code>, y <code>forEach</code> son <em>operaciones agregadas</em>.
                    Las operaciones agregadas procesan los elementos de un flujo, no directamente de una colección (lo cual es la 
                    razón de porqué el primer método invocado en este ejemplo es <code>stream</code>). Un <em>stream</em>
                    es una secuencia de elementos. A diferencia de una colección, no es una estructura de datos que almacena
                    elementos. En vez de eso, un flujo (stream) lleva los valores de una fuente, como una colección, a través de una
                    tubería. Una <em>tubería</em> es una secuencia de operaciones del flujo, el cual en este ejemplo es
                    <code>filter</code>-  <code>map</code>-<code>forEach</code>. Además, las operaciones agregadas típicamente
                    aceptan expresiones lambda como parámetros, habilitándole a personalizar como se comportan.
                </p>
                <p>
                    Para una descripción más a fonde de las operaciones agregadas, vea la lección
                    <a class="TutorialLink" target="_top" href="../../collections/streams/index.html">
                        Operaciones Agregadas</a>.
                </p>
                <h2>
                    <a id="lambda-expressions-in-gui-applications">Expresiones Lambda en las Aplicaciones IGU (GUI en inglés)</a>
                </h2>
                <p>
                    Para procesar los eventos en una aplicación de interfaz gráfico de Usuario (IGU, GUI en inglés), tales como
                    acciones del teclado, acciones del ratón, y acciones de desplazamiento, usted típicamente crea manejadores de
                    eventos, los cuales usualmente implican implementar una interfaz particular. A menudo, las interfaces de los
                    manejadores de eventos son interfaces funcionales; tienden a tener sólo un método.
                </p>
                <p>En el ejemplo de JavaFX
                    <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm">
                        <code>HelloWorld.java</code></a> (descrito en la sección previa
                    <a class="TutorialLink" target="_top" href="anonymousclasses.html">Clases Anónimas</a>), puede reemplazar las
                    clases anónimas destacadas con una expresión lambda en esta sentencia:
                </p>
                <pre class="codeblock">
        btn.setOnAction(<b>new EventHandler&lt;ActionEvent&gt;() {</b>

            <b>@Override</b>
            <b>public void handle(ActionEvent event) {</b>
                <b>System.out.println("Hello World!");</b>
            <b>}</b>
     <b>}</b>);
                </pre>
                <p>
                    La invoación del método <code>btn.setOnAction</code> especifica lo que ocurre cuando usted selecciona el botón
                    representado por el objeto <code>btn</code>. Este método requiere un objeto del tipo
                    <code>EventHandler&lt;ActionEvent&gt;</code>. El interfaz <code>EventHandler&lt;ActionEvent&gt;</code> contiene
                    sólo un método, <code>void handle(T event)</code>. Esta interfaz es una interfaz funcional, así que podría usar
                    la siguiente destacada expresión lambda para reemplazarla:
                </p>
                <pre class="codeblock">
        btn.setOnAction(
          <b>event -&gt; System.out.println("Hello World!")</b>
        );
                </pre>
                <h2>
                    <a id="syntax">Sintaxis de las Expresiones Lambda</a>
                </h2>
                <p>
                    Una expresión lambda consiste de lo siguiente:
                </p>
                <ul>
                    <li>
                        <p>
                            Una lista separada-por-comas de parámetros formales encerrados en paréntesis. El método 
                            <code>CompruebaPersona.test</code> contiene un parámetro, <code>p</code>, el cual representa una
                            instancia de la clase <code>Persona</code>.
                        </p>
                        <p>
                            <b>Nota</b>: Puede omitir el tipo de dato de los parámetros en una expresión lambda. Además, puede
                            omitir los paréntesis si hay sólo un parámetro. Por ejemplo, la siguiente expresión lambda es también
                            válida:
                        </p>
                        <pre class="codeblock">
p -&gt; p.getGenero() == Persona.Sexo.MASCULINO
    &amp;&amp; p.getEdad() &gt;= 18
    &amp;&amp; p.getEdad() &lt;= 25
                        </pre>
                    </li>
                    <li>
                        <p>
                            El token flecha, <code>-&gt;</code>
                        </p>
                    </li>
                    <li>
                        <p>
                            Un cuerpo, el cual consiste de una expresión única o un bloque de sentencias. Este ejemplo usa la
                            siguiente expresión:
                        </p>
                        <pre class="codeblock">
p.getGenero() == Persona.Sexo.MASCULINO
    &amp;&amp; p.getEdad() &gt;= 18
    &amp;&amp; p.getEdad() &lt;= 25
                        </pre>
                        <p>
                            Si especifica una expresión única, entonces el entorno de ejecucón de Java evalúa la expresión y
                            entonces devuelve su valor. Alternativamente, usted puede usar una sentencia return:
                        </p>
                        <pre class="codeblock">
p -&gt; {
    return p.getGenero() == Persona.SexO.MASCULINO
        &amp;&amp; p.getEdad() &gt;= 18
        &amp;&amp; p.getEdad() &lt;= 25;
}
                        </pre>
                        <p>
                            Una sentencia return no es una expresión; en una expresión lambda, debe encerrar las sentencias entre
                            llaves (<code>{}</code>). Sin embargo, no tiene que encerrar una invocación a un método void entre
                            llaves. Por ejemplo, la siguiente es una expresión lambda válida:
                        </p>
                        <pre class="codeblock">
correoElectronico -&gt; System.out.println(correoElectronico)
                        </pre>
                    </li>
                </ul>
                <p>
                    Note que una expresión lambda se parece un montón a una declaración de método; puede considerar las expresiones
                    lambda como métodos anónimos &mdash; métodos sin un nombre.
                </p>
                <p>
                    El siguiente ejemplo,
                    <a class="SourceLink" target="_blank" href="examples/Calculadora.java"
                       onclick="showCode('../../displayCode.html', 'examples/Calculadora.java'); return false;">
                        <code>Calculadora</code></a>, es un ejemplo de expresiones lambda que toman más de un parámetro formal:
                </p>
                <pre class="codeblock">

public class Calculadora {

    interface MatematicasParaEnteros {
        int operacion(int a, int b);
    }

    public int operacionBinaria(int a, int b, MatematicasParaEnteros op) {
        return op.operacion(a, b);
    }

    public static void main(String... args) {

        Calculadora miApp = new Calculadora();
        MatematicasParaEnteros suma = (a, b) -> a + b;
        MatematicasParaEnteros resta = (a, b) -> a - b;
        System.out.println("40 + 2 = " +
            miApp.operacionBinaria(40, 2, suma));
        System.out.println("20 - 10 = " +
            miApp.operacionBinaria(20, 10, resta));
    }
}

                </pre>
                <p>
                    El método <code>operacionBinaria</code> ejecuta una operación matemática sobre dos operandos enteros. La
                    operación en sí misma es especificada por una instancia de <code>MatematicasParaEnteros</code>. El ejemplo
                    define dos operaciones con expresiones lambda, <code>suma</code> y <code>resta</code>. El ejemplo imprime lo
                    siguiente:
                </p>
                <pre class="codeblock">
40 + 2 = 42
20 - 10 = 10
                </pre>
                <h2>
                    <a id="accessing-local-variables">Acceder a las Variables Locales del Alcance Envolvente</a>
                </h2>
                <p>
                    Como las clases anónimas y locales, las expresiones lambda pueden
                    <a class="TutorialLink" target="_top" href="localclasses.html#accessing-members-of-an-enclosing-class">
                        capturar variables</a>; tienen el mismo acceso a las variables locales del alcance envolvente. Sin embargo, 
                    a diferencia de las clases anónimas y locales, las expresiones lambda no tienen problemas de ocultación
                    (vea <a class="TutorialLink" target="_top" href="../../java/javaOO/nested.html#shadowing">Ocultación</a> para
                    más información). Las expresiones lambda tienen un alcance limitado por el léxico. Esto significa que
                    no heredan ningún nombre de un supertipo o introducen un nuevo nivel de alcance. Las declaraciones en una
                    expresión lambda son interpretadas tal como son en el entorno envolvente. El siguiente ejemplo,
                    <a class="SourceLink" target="_blank" href="examples/PruebaAlcanceLambda.java" 
                       onclick="showCode('../../displayCode.html', 'examples/PruebaAlcanceLambda.java'); return false;">
                        <code>PruebaAlcanceLambda</code></a>, demuestra esto:
                </p>
                <pre class="codeblock">

import java.util.function.Consumer;

public class PruebaAlcanceLambda {

    public int x = 0;

    class PrimerNivel {

        public int x = 1;

        void metodoInPrimerNivel(int x) {

            // La siguiente sentencia causa que el compilador genera el 
            // el error "variables locales referencias desde una expresión lambda 
            // deben ser finales o efectivamente finales" en la sentencia A:
            //
            // x = 99;
            Consumer&lt;Integer&gt; miConsumer = (y)
                    -> {
                System.out.println("x = " + x); // Sentencia A
                System.out.println("y = " + y);
                System.out.println("this.x = " + this.x);
                System.out.println("PruebaAlcanceLambda.this.x = "
                        + PruebaAlcanceLambda.this.x);
            };

            miConsumer.accept(x);

        }
    }

    public static void main(String... args) {
        PruebaAlcanceLambda pal = new PruebaAlcanceLambda();
        PruebaAlcanceLambda.PrimerNivel pn = pal.new PrimerNivel();
        pn.metodoInPrimerNivel(23);
    }
}
                </pre>
                <p>
                    Este ejemplo genera la siguiente salida:              
                </p>
                <pre class="codeblock">
x = 23
y = 23
this.x = 1
PruebaAlcanceLambda.this.x = 0
                </pre>
                <p>
                    Si substituye el parámetro <code>x</code> en lugar de <code>y</code> en la declaración de la expresión lambda
                    <code>miConsumer</code>, entonces el compilador genera un error:
                </p>
                <pre class="codeblock">
Consumer&lt;Integer&gt; miConsumer = (x) -> {
    // ...
}
                </pre>
                <p>
                    El compilador genera el error "la variable x está ya definida en el método metodoPrimerNivel(int)" porque
                    la expresión lambda no introduce un nuevo nivel de alcance. Por consiguiente, usted puede acceder directamente
                    a los campos, métodos, y variables locales del alcance envolvente. Por ejemplo, la expresión lambda accede
                    directamente el parámetro <code>x</code> del método <code>metodoPrimerNivel</code>. Para acceder a las variables
                    en la clase envolvente, use la palabra clave <code>this</code>. En este ejemplo, <code>this.x</code> hace 
                    referemcoa a la variable miembro <code>PrimerNivel.x</code>.
                </p>
                <p>
                    Sin embargo, como con las clases anónimas y locales, una expresión lambda sólo puede acceder a las variables
                    locales y parámetros del bloque envolvente que sean finales o efectivamente finales. Por ejemplo, suponga que
                    usted añade la siguiente sentencia de asignación inmediatamente después de la sentencia de definición de 
                    <code>metodoPrimerNivel</code> :
                </p>
                <pre class="codeblock">
void metodoPrimerNivel(int x) {
    <strong>x = 99;</strong>
    // ...
}
                </pre>
                <p>
                    Debido a esta sentencia de asignación, la variable <code>PrimerNivel.x</code> no es efectivamente final nunca 
                    más. Como resultado, el compilador de Java genera un mensaje de error similar a "las variables locales 
                    referenciadss desde una expresión lambda deben ser finales o efectivamente finales" donde la expresión lambda
                    <code>miConsumer</code> intenta acceder a la variable <code>PrimerNivel.x</code> :
                </p>
                <pre class="codeblock">System.out.println("x = " + x);</pre>
                <h2>
                    <a id="target-typing">Tipos de Destino</a>
                </h2>
                <p>
                    ¿Cómo determina el tipo de una expresión lambda? Recuerde la expresión lambda que seleccionó miembros que eran
                    masculinos y entre las edades de los 18 y 25 años:
                </p>
                <pre class="codeblock">
p -&gt; p.getGenero() == Persona.Sexo.MASCULINO
    &amp;&amp; p.getEdad() &gt;= 18
    &amp;&amp; p.getEdad() &lt;= 25
                </pre>
                <p>
                    Esta expresión lambda fue usada en los siguientes dos métodos:
                </p>
                <ul>
                    <li>
                        <p>
                            <code>
                                public static void imprimePersonas(List&lt;Persona&gt; agenda, CompruebaPersona comprobador)
                            </code> en
                            <a href="#approach3">Enfoque 3: Especificar Código de Criterio de Búsqueda en una Clase Local</a>
                        </p>
                    </li>
                    <li>
                        <p>
                            <code>
                                public void imprimePersonasConPredicado(List&lt;Persona&gt; agenda, Predicate&lt;Persona&gt; comprobador)
                            </code> en
                            <a href="#approach6">Enfoque 6: Usar Interfaces Funcionales Estándar con Expresiones Lambda</a>
                        </p>
                    </li>
                </ul>
                <p>
                    Cuando el entorno de ejecución de Java invoca el método <code>imprimePersonas</code>, está esperando un tipo de
                    datos de <code>CompruebaPersona</code>, así que la expresión lambda es de este tipo. Sin embargo, cuando el 
                    entorno de ejecución Java invoca el método <code>imprimePersonasConPredicado</code>, está esperando un tipo de
                    dato de <code>Predicate&lt;Persona&gt;</code>, así que la expresión lambda es de este tipo. El tipo de dato que
                    estos métodos esperan son llamados los <em>tipos de destino</em>. Para determinar el tipo de una expresión 
                    lambda, el compilador de Java usa el tipo de destino del contexto o situación en la cual la expresión lambda
                    es encontrada. De ello se desprende que pueda Sólo usar expresiones lambda en situaciones en las que el 
                    compilador Java puede determinar un tipo de destino:
                </p>
                <ul>
                    <li>
                        <p>
                            Declaraciones de Variables
                        </p>
                    </li>
                    <li>
                        <p>
                            Asignaciones
                        </p>
                    </li>
                    <li>
                        <p>
                            Sentencias return
                        </p>
                    </li>
                    <li>
                        <p>
                            Inicializadores de matrices
                        </p>
                    </li>
                    <li>
                        <p>
                            Argumentos de método o constructor
                        </p>
                    </li>
                    <li>
                        <p>
                            Cuerpos de expresiones lambda
                        </p>
                    </li>
                    <li>
                        <p>
                            Expresiones condicionales, <code>?:</code>
                        </p>
                    </li>
                    <li>
                        <p>
                            Expresiones de moldeo
                        </p>
                    </li>
                </ul>
                <h3>
                    <a id="target-types-and-method-arguments">Tipos de Destino y Argumentos de Método</a>
                </h3>
                <p>
                    Para los argumentos de método, el compilador de Java determina el tipo destino con otras dos funcionales del 
                    lenguaje: resolución de la sobrecarga e inferencia del tipo del argumento.
                </p>
                <p>
                    Considere las dos siguiente interfaces funcionales (
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">
                        <code>java.lang.Runnable</code>
                    </a> and
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html">
                        <code>java.util.concurrent.Callable&lt;V&gt;</code>
                    </a>):
                </p>
                <pre class="codeblock">
public interface Runnable {
    void run();
}

public interface Callable&lt;V&gt; {
    V call();
}
                </pre>
                <p>
                    El método <code>Runnable.run</code> no devuelve un valor, mientras que <code>Callable&lt;V&gt;.call</code> lo 
                    hace.
                </p>
                <p>
                    Suponga que usted ha sobreescrito el método <code>invocar</code> como sigue (vea
                    <a class="TutorialLink" target="_top" href="methods.html">Definiendo Métodos</a> para más información sobre la
                    sobrecarga de métodos):
                </p>
                <pre class="codeblock">
void invoke(Runnable r) {
    r.run();
}

&lt;T&gt; T invoke(Callable&lt;T&gt; c) {
    return c.call();
}
                </pre>
                <p>
                    ¿Qué metodo será invocado en la siguiente sentencia?
                </p>
                <pre class="codeblock">
String s = invoke(() -&gt; "hecho");
                </pre>
                <p>
                    El método <code>invoke(Callable&lt;T&gt;)</code> serña invocado porque el método devuelve un valor; el método
                    <code>invoke(Runnable)</code> no lo hace. En este caso, el tipo de la expresión lambda 
                    <code>() -&gt; "hecho"</code> es <code>Callable&lt;T&gt;</code>.
                </p>
                <h2>
                    <a id="serialization">Serialización</a>
                </h2>
                <p>
                    Usted puede <a class="TutorialLink" target="_top" href="../../jndi/objects/serial.html">serializar</a> una
                    expresión lambda si su tipo destino y sus argumentos capturados son serializables. Sin embargo, como las
                    <a class="TutorialLink" target="_top" href="nested.html#serialization">clases anidadas</a>, la serialización de
                    las expresiones lambda está severamente desaconsejado.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="anonymousclasses.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="methodreferences.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">
                                Su uso de ésta
                            </a>
                            página y todo el material en las páginas bajo el anuncio &quot;Los Tutoriales de Java&quot; está sujeto
                            a estos
                            <a href="../../information/cpyr.html">
                                avisos legales
                            </a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank"
                               href="../../information/run-examples.html">
                                Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias?
                            <a target="_blank"
                               href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión
                            </a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Clases Anónimas<br />
            <b>Página siguiente:</b> Referencias a Métodos
        </div>
    </body>
</html> 