<!doctype html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Inferencia de Tipos (Los Tutoriales de Java&trade; &gt; Aprendiendo el Lenguaje Java &gt; Genéricos (Actualizado))
        </title>
        <meta name="description" content="Este tutorial para principiantes de Java describle los fundamentos de programación en el
              lenguaje de programación Java" />
        <meta name="keywords" content="java programming, learn java, java sample code, java objects, java classes, java inheritance,
              interfaces, variables, arrays, data types, operators, control flow, number, string" />
        <link rel="stylesheet" href="../../indice.css" type="text/css">
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper  clearfix">       
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div> 
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div> 
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Genéricos (Actualizado)</a></div>
                <div class="linkAHEAD"><a href="why.html">¿Porqué usar Genéricos?</a></div>
                <div class="linkAHEAD"><a href="types.html">Tipos Genéricos</a></div>
                <div class="linkBHEAD"><a href="rawTypes.html">Tipos Crudos</a></div>
                <div class="linkAHEAD"><a href="methods.html">Métodos Genéricos</a></div>
                <div class="linkAHEAD"><a href="bounded.html">Parámetros de Tipos Acotados</a></div>
                <div class="linkBHEAD"><a href="boundedTypeParams.html">Métodos Genéricos y Parámetros de Tipos Acotados</a></div>
                <div class="linkAHEAD"><a href="inheritance.html">Genéricos, Herencia, y Subtipos</a></div>
                <div class="nolinkAHEAD">Inferencia de Tipos</div>
                <div class="linkAHEAD"><a href="wildcards.html">Comodines</a></div>
                <div class="linkBHEAD"><a href="upperBounded.html">Comodines Acotados Superiormente</a></div>
                <div class="linkBHEAD"><a href="unboundedWildcards.html">Comodines no Acotados</a></div>
                <div class="linkBHEAD"><a href="lowerBounded.html">Comodines Acotados Inferiormente</a></div>
                <div class="linkBHEAD"><a href="subtyping.html">Comodines y Subtipado</a></div>
                <div class="linkBHEAD"><a href="capture.html">Captura de Comodines y Métodos de Ayuda</a></div>
                <div class="linkBHEAD"><a href="wildcardGuidelines.html">Directrices para el Uso de Comodines</a></div>
                <div class="linkAHEAD"><a href="erasure.html">Borrado de Tipos</a></div>
                <div class="linkBHEAD"><a href="genTypes.html">Borrado de Tipos Genéricos</a></div>
                <div class="linkBHEAD"><a href="genMethods.html">Borrado de Métodos Genéricos</a></div>
                <div class="linkBHEAD"><a href="bridgeMethods.html">Efectos del Borrado de Tipos y Métodos Puente</a></div>
                <div class="linkBHEAD"><a href="nonReifiableVarargsType.html">Tipos No-Cosificables</a></div>
                <div class="linkAHEAD"><a href="restrictions.html">Restricciones de los Genéricos</a></div>
                <div class="linkQUESTIONS"><a href="QandE/generics-questions.html">Preguntas y Ejercicios</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Aprendiendo el Lenguaje Java<br />
                <b>Lección:</b> Genéricos (Actualizado)
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Aprendiendo el Lenguaje Java</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Genéricos (Actualizado)</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="inheritance.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="wildcards.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Inferencia de Tipos</h1>
            </div>
            <div id="PageContent">
                <p>
                    La <em>inferencia de tipos</em> es una habilidad del compilador de Java para mirar en cada invocación de método
                    y su correspondiente declaración para determinar el tipo de argumento (o argumentos) quue hace la invocación
                    aplicable. El algoritmo de inferencia determina los tipos de los argumentos y, si está disponible, el tipo del
                    resultado está siendo asignado o devuelto. Finalmente, el algoritmo de inferencia intenta encontrar el tipo 
                    <em>más específico</em> que funciona con todos los argumentos.
                </p>
                <p>
                    Para ilustrar este último punto, en el siguiente ejemplo, la inferencia determina que el segundo argumento que
                    se pasa al método <code>pick</code> es de tipo <code>Serializable</code>:
                </p>
                <div class="codeblock">
                    <pre>
static &lt;T&gt; T pick(T a1, T a2) { return a2; }
Serializable s = pick("d", new ArrayList&lt;String&gt;());
                    </pre>
                </div>
                <h2><a id="type-inference-methods">Inferencia de Tipos y Métodos Genéricos</a></h2>
                <p>
                    Los
                    <a class="TutorialLink" target="_top" href="methods.html">Métodos Genéricos</a> le introdujeron a la inferencia
                    de tipos, que le habilita a invocar un método genérico como si fuera un método ordinario, sin especificar un
                    tipo entre los paréntesis angulares. Considere el siguiente ejemplo.
                    <a class="SourceLink" target="_blank" href="examples/DemoBox.java"
                       onclick="showCode('../../displayCode.html', 'examples/DemoBox.java'); return false;">
                        <code>DemoBox</code>
                    </a>, que requiere de la clase
                    <a class="SourceLink" target="_blank" href="examples/Box.java" 
                       onclick="showCode('../../displayCode.html', 'examples/Box.java'); return false;">
                        <code>Box</code>
                    </a> :
                </p>
                <div class="codeblock">
                    <pre>
public class DemoBox {

  public static &lt;U&gt; void añadeBox(U u, java.util.List&lt;Box&lt;U&gt;&gt; boxes) {
    Box&lt;U&gt; box = new Box&lt;&gt;();
    box.set(u);
    boxes.add(box);
  }

  public static &lt;U&gt; void visualizaBoxes(java.util.List&lt;Box&lt;U&gt;&gt; boxes) {
    int counter = 0;
    for (Box&lt;U&gt; box: boxes) {
      U boxContents = box.get();
      System.out.println(
        "Box #" + counter + " contiene [" +
        boxContents.toString() + "]");
      counter++;
    }
  }

  public static void main(String[] args) {
    java.util.ArrayList&lt;Box&lt;Integer&gt;&gt; listOfIntegerBoxes =
      new java.util.ArrayList&lt;&gt;();
    DemoBox.&lt;Integer&gt;añadeBox(Integer.valueOf(10), listOfIntegerBoxes);
    DemoBox.añadeBox(Integer.valueOf(20), listOfIntegerBoxes);
    DemoBox.añadeBox(Integer.valueOf(30), listOfIntegerBoxes);
    DemoBox.visualizaBoxes(listOfIntegerBoxes);
  }
}
                    </pre>
                </div>
                <p>
                    Lo siguiente es la salida de este ejemplo:
                </p>
                <div class="codeblock">
                    <pre>
Box #0 contiene [10]
Box #1 contiene [20]
Box #2 contiene [30]
                    </pre>
                </div>
                <p>
                    El método genérico <code>añadeBox</code> define un tipo de parámetro llamado <code>U</code>. Generalmente, un
                    compilador de Java puede inferir los tipos de parámetros de una llamada a un método genérico. Consecuentemente, 
                    en la mayoría de los casos, no tiene que especificarlos. Por ejemplo, para invocar el método genérico 
                    <code>añadeBox</code>, puede especificar el tipo de parámetro con un <em>tipo testigo</em> como sigue:
                </p>
                <div class="codeblock">
                    <pre>
BoxDemo.<strong>&lt;Integer></strong>añadeBox(Integer.valueOf(10), listOfIntegerBoxes);
                    </pre>
                </div>
                <p>
                    Alternativamente, si omite el tipo testigo, un compilador de Java automáticamente infiere (desde los argumentos
                    del método) que el tipo del parámetro es <code>Integer</code>:
                </p>
                <div class="codeblock">
                    <pre>
BoxDemo.añadeBox(Integer.valueOf(20), listOfIntegerBoxes);
                    </pre>
                </div>
                <h2><a id="type-inference-instantiation">Inferencia de Tipos e Instanciación de Clases Genéricas</a></h2>
                <p>
                    Puede reemplazar los tipos de argumentos requeridos al invocar el constructor de una clase genérica con un 
                    conjunto vacío de tipos de parámetros (<code>&lt;&gt;</code>) mientras el compilador pueda inferir los tipos de
                    argumentos desde el contexto.
                    Este par de paréntesis angulares es informalmente llamado
                    <a class="TutorialLink" target="_top" href="types.html#diamond">el diamante</a>.
                </p>
                <p>
                    Por ejemplo, considere la siguiente declaración de variable:
                </p>
                <div class="codeblock">
                    <pre>
Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;String, List&lt;String&gt;&gt;();
                    </pre>
                </div>
                <p>
                    Puede substituir el tipo parametrizado del constructor con un conjunto vacío de tipos de parámetros
                    (<code>&lt;&gt;</code>):
                </p>
                <div class="codeblock">
                    <pre>
Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;&gt;();
                    </pre>
                </div>
                <p>
                    Note que para tomar ventaja de la inferencia de tipos durante la instanciación de la clase genérica, debe usar
                    el diamante. En el siguiente ejemplo, el compilador genera una advertencia de conversión sin comprobar porque
                    el constructor <code>HashMap()</code> se refiere al tipo crudo <code>HashMap</code>, no al tipo
                    <code>Map&lt;String,List&lt;String&gt;&gt;</code>:
                </p>
                <div class="codeblock">
                    <pre>
Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap(); // advertencia de conversión sin comprobar
                    </pre>
                </div>
                <h2>
                    <a id="type-inference-constructors">
                        Inferencia de Tipos y Constructores Genéricos de Clases Genéricas y No-genéricas
                    </a>
                </h2>
                <p>
                    Note que los constructores pueden ser genéricos (en otras palabras, declaran sus propios tipos de parámetros
                    formales) tanto en clases genéricas como no genéricas. Considere el siguiente ejemplo:
                </p>
                <div class="codeblock">
                    <pre>
class MiClase&lt;X&gt; {
  &lt;T&gt; MyClass(T t) {
    // ...
  }
}
                    </pre>
                </div>
                <p>
                    Considere la siguiente instanciación de la clase <code>MiClase</code>:
                </p>
                <div class="codeblock">
                    <pre>
new MiClase&lt;Integer&gt;("")
                    </pre>
                </div>
                <p>
                    Esta sentencia crea una instancia del tipo parametrizado <code>MiClase&lt;Integer&gt;</code>; la sentencia
                    explícitamente especifica el tipo <code>Integer</code> para el tipo de parámetro formal, <code>X</code>, de la
                    clase genérica <code>MiClase&lt;X&gt;</code>. Note que el constructor para esta clase genérica contiene un tipo
                    de parámetro formal, <code>T</code>. El compilador infiere que el tipo <code>String</code> para el tipo de
                    parámetro formal, <code>T</code>, del constructor de esta clase genérica (porque el parámetro actual de este
                    constructor es un objeto <code>String</code>.
                </p>
                <p>
                    Los compiladores de versiones anteriores a Java SE 7 son capaces de inferir los tipos de parámetros actuales de
                    los constructores genéricos, de forma similar a los métodos genéricos. Sin embargo, los compiladores en Java SE
                    7 y posteriores pueden inferir los tipos de parámetros actuales de la clase genérica que está siendo instanciada
                    si usa el diamante (<code>&lt;&gt;</code>). Considere el siguiente ejemplo:
                </p>
                <div class="codeblock">
                    <pre>
MiClase&lt;Integer&gt; miObjeto = new MiClase&lt;&gt;(&quot;&quot;);
                    </pre>
                </div>
                <p>
                    En este ejemplo, el compilador infiere el tipo <code>Integer</code> para el tipo de parámetro formal,
                    <code>X</code>, de la clase genérica <code>MiClase&lt;X&gt;</code>. Infiere el tipo <code>String</code> para la
                    el tipo de parámetro formal, <code>T</code>, del constructor de esta clase genérica.
                </p>
                <div class="note">
                    <hr />
                    <strong>Nota:</strong>&nbsp;Es importante notar que el algoritmo de inferencia usa solo los argumentos de
                    invocación, los tipos de destino, y posiblemente un obvio tipo de retorno esperado para inferir los tipos. El
                    algoritmo de inferencia no usa los resultados de más tarde en el programa.
                    <hr />
                </div>
                <h2><a id="target_types">Tipos de Destino</a></h2>
                <p>
                    El compilador de Java toma ventaja de los tipos de destino para inferir los tipos de parámetros de una 
                    invocación a un método genérico. El <em>tipo destino</em> de una expresión es el tipo de dato que el compilador
                    de Java espera dependiendo de dónde aparece la expresión. Considere el método <code>Collections.emptyList</code>
                    , el cual está declarados como sigue:
                </p>
                <div class="codeblock">
                    <pre>
static &lt;T&gt; List&lt;T&gt; emptyList();
                    </pre>
                </div>
                <p>
                    Considere la siguiente sentencia de asignación:
                </p>
                <div class="codeblock">
                    <pre>
List&lt;String&gt; listOne = Collections.emptyList();
                    </pre>
                </div>
                <p>
                    Esta sentencia está esperando una instancia de <code>List&lt;String&gt;</code>; este tipo de dato es el tipo
                    de destino. Debido a que el método <code>emptyList</code> devuelve un valor de tipo <code>List&lt;T&gt;</code>,
                    el compilador infiere que el argumento tipo <code>T</code> debe ser el valor <code>String</code>. Esto funciona
                    en Java SE 7 y 8. Alternativamente, podría usar un tipo testigo y especificar el valor de <code>T</code> como
                    sigue:
                </p>
                <div class="codeblock">
                    <pre>
List&lt;String&gt; listOne = Collections.&lt;String&gt;emptyList();
                    </pre>
                </div>
                <p>
                    Sin embargo, esto no es necesario en este contexto. Era necesario en otros contextos. Considere el siguiente
                    método:
                </p>
                <div class="codeblock">
                    <pre>
void procesaListaDeString(List&lt;String&gt; listaDeString) {
    // procesa la listaDeString
}
                    </pre>
                </div>
                <p>
                    Suponga que quiere invocar el método <code>procesaListaDeString</code> con una lista vacía. En Java SE 7, la
                    siguiente sentencia no compila:
                </p>
                <div class="codeblock">
                    <pre>
procesaListaDeString(Collections.emptyList());
                    </pre>
                </div>
                <p>
                    El compilador de Java SE 7 genera un mensaje de error similar al siguiente:
                </p>
                <div class="codeblock">
                    <pre>
List&lt;Object&gt; cannot be converted to List&lt;String&gt;
                    </pre>
                </div>
                <p>
                    El compilador requiere un valor para el tipo de argumento <code>T</code> así que inicia con el valor
                    <code>Object</code>. Consecuentemente, la invocación de <code>Collections.emptyList</code> devuelve un valor del
                    tipo <code>List&lt;Object&gt;</code>, el cual es incompatible con el método <code>procesaListaDeString</code>.
                    Así, en Java SE 7, debe especificar el valor del valor del argumento del tipo como sigue:
                </p>
                <div class="codeblock">
                    <pre>
procesaListaDeString(Collections.&lt;String&gt;emptyList());
                    </pre>
                </div>
                <p>
                    Esto ya no es necesario en Java SE 8. La noción de qué es un tipo destino ha sido expandida para incluir 
                    argumentos de método, tales com el argumento al método <code>procesaListaDeString</code>. En este caso,
                    <code>procesaListaDeString</code> requiere un argumento del tipo <code>List&lt;String&gt;</code>. El método
                    <code>Collections.emptyList</code> devuelve un valor de <code>List&lt;T&gt;</code>, así que usando el tipo de
                    destino de <code>List&lt;String&gt;</code>, el compilador infiere que el argumento del tipo <code>T</code>
                    tiene un valor de <code>String</code>. Así, en Java SE 8, la siguiente sentencia compila:
                </p>
                <div class="codeblock">
                    <pre>
procesaListaDeString(Collections.emptyList());
                    </pre>
                </div>
                <p>
                    Vea
                    <a class="TutorialLink" target="_top"
                       href="../../java/javaOO/lambdaexpressions.html#target-typing">
                        Tipos de destino
                    </a> en
                    <a class="TutorialLink" target="_top" 
                       href="../../java/javaOO/lambdaexpressions.html">
                        Expresiones Lambda
                    </a> para obtener más información.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="inheritance.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="wildcards.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">
                                Su uso de ésta
                            </a>
                            página y todo el material en las páginas bajo el anuncio &quot;Los Tutoriales de Java&quot; está sujeto
                            a estos
                            <a href="../../information/cpyr.html">
                                avisos legales
                            </a>
                            .
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">
                                Compilando y Ejecutando los Ejemplos: PFs
                            </a>
                            .
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias?
                            <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión
                            </a>
                            .
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Genéricos, Herencia, y Subtipos<br />
            <b>Página siguiente:</b> Comodines
        </div>
    </body>
</html>