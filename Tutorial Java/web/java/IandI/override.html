<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Sobreescribiendo y Ocultando Métodos (Los Tutoriales de Java&trade; &gt; Aprendiendo el Lenguaje Java &gt; Interfaces y
            Herencia)
        </title>
        <meta name="description" content="Este tutorial para principiantes de Java describle los fundamentos de programación en el
              lenguaje de programación Java" />
        <meta name="keywords" content="java programming, learn java, java sample code, java objects, java classes, java inheritance,
              interfaces, variables, arrays, data types, operators, control flow, number, string" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper  clearfix">       
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div> 
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div> 
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Interfaces y Herencia</a></div>
                <div class="linkAHEAD"><a href="createinterface.html">Interfaces</a></div>
                <div class="linkBHEAD"><a href="interfaceDef.html">Definiendo una Interfaz</a></div>
                <div class="linkBHEAD"><a href="usinginterface.html">Implementando una Interfaz</a></div>
                <div class="linkBHEAD"><a href="interfaceAsType.html">Usando una Interfaz Como un Tipo</a></div>
                <div class="linkBHEAD"><a href="nogrow.html">Evolucionando Interfaces</a></div>
                <div class="linkBHEAD"><a href="defaultmethods.html">Métodos por Defecto</a></div>
                <div class="linkBHEAD"><a href="summary-interface.html">Sumario de Interfaces</a></div>
                <div class="linkQUESTIONS"><a href="QandE/interfaces-questions.html">Preguntas y Ejercicios</a></div>
                <div class="linkAHEAD"><a href="subclasses.html">Herencia</a></div>
                <div class="linkBHEAD"><a href="multipleinheritance.html">Herencia Múltiple de Estado, Implementación, y Tipo</a></div>
                <div class="nolinkBHEAD">Sobreescribiendo y Ocultando Métodos</div>
                <div class="linkBHEAD"><a href="polymorphism.html">Polimorfismo</a></div>
                <div class="linkBHEAD"><a href="hidevariables.html">Ocultando Campos</a></div>
                <div class="linkBHEAD"><a href="super.html">Usando la Palabra Clave super</a></div>
                <div class="linkBHEAD"><a href="objectclass.html">Object como una Superclase</a></div>
                <div class="linkBHEAD"><a href="final.html">Escribiendo Clases y Métodos Finales</a></div>
                <div class="linkBHEAD"><a href="abstract.html">Métodos y Clases Abstractos</a></div>
                <div class="linkBHEAD"><a href="summaryinherit.html">Sumario de Herencia</a></div>
                <div class="linkQUESTIONS"><a href="QandE/inherit-questions.html">Preguntas y Ejercicios</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Aprendiendo el Lenguaje Java<br />
                <b>Lección:</b> Interfaces y Herencia<br />
                <b>Sección:</b> Herencia
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Aprendiendo el Lenguaje Java</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Interfaces y Herencia</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="multipleinheritance.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="polymorphism.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Sobreescribiendo y Ocultando Métodos</h1>
            </div>
            <div id="PageContent">
                <h2>Métodos de Instancia</h2>
                <p>
                    Un método de instancia en una subclase con la misma firma (nombre, más el número y tipo de sus parámetros) y el
                    tipo de retorno como el del método de instancia en la superclase <i>sobreescribe</i> el método de la superclase.
                </p>
                <p>
                    La habilidad de una subclase para sobreescribir un método permite a una clase heredar de una superclase cuyo
                    comportamiento está &quot;lo bastante cerca&quot; y entonces modificar el comportamiento como se necesite. El
                    método que sobreescribe tiene el mismo nombre, número y tipo de parámetros, y el tipo de retorno que el método
                    que sobreescribe. Un método que sobreescribe puede también devolver un subtipo del tipo retornado por el método
                    sobreescrito. Este subtipo es llamado <i>tipo de vuelta covariante</i>.
                </p>
                <p>
                    Cuando se sobreescribe un método, usted querría usar la anotación <code>@Override</code> que instruye al
                    compilador que su intención es sobreescribir un método en la superclase. Si, por alguna razón, el compilador 
                    detecta que el método no existe en una de las superclases, entonces generará un error. Para más información 
                    sobre<code>@Override</code>, vea
                    <a class="TutorialLink" target="_top" href="../annotations/index.html">
                        <code>Anotaciones</code>
                    </a>.
                </p>
                <h2>Métodos Estáticos</h2>
                <p>
                    Si una subclase define un método estático con la misma firma que un método estático en la superclase, entonces
                    el método en la subclase <i>oculta</i> el de la superclase.
                </p>
                <p>
                    La distinción entre ocultar un método estático y sobreescribir un método de instancia tiene importantes
                    implicaciones:
                </p>
                <ul>
                    <li>
                        La versión del método de instancia sobreescrito que se invoca es el de que está en la subclase.
                    </li>
                    <li>
                        La versión del método estático oculto que es invocado depende de si es invocado desde la superclase o la
                        subclase.
                    </li>
                </ul>
                <p>
                    Considere un ejemplo que contiene dos clases. La primera es <code>Animal</code>, la cual contiene un método de
                    instancia y un método estático:
                </p>
                <div class="codeblock">
                    <pre>
public class Animal {
    public static void pruebaClaseMetodo() {
        System.out.println("El método estático en Animal");
    }
    public void pruebaInstanciaMetodo() {
        System.out.println("El método de instancia en Animal");
    }
}
                    </pre>
                </div>
                <p>
                    La segunda clase, una subclase de <code>Animal</code>, es llamada <code>Gato</code>:
                </p>
                <div class="codeblock">
                    <pre>
public class Gato extends Animal {
    public static void pruebaClaseMetodo() {
        System.out.println("El método estático en Gato");
    }
    public void pruebaInstanciaMetodo() {
        System.out.println("El método de instancia en Gato");
    }

    public static void main(String[] args) {
        Gato miGato = new Gato();
        Animal miAnimal = miGato;
        Animal.pruebaClaseMetodo();
        miAnimal.pruebaInstanciaMetodo();
    }
}
                    </pre>
                </div>
                <p>
                    La clase <code>Gato</code> sobreescribe el método de instancia en <code>Animal</code> y oculta el método
                    estático en <code>Animal</code>. El método <code>main</code> en esta clase crea una instancia de
                    <code>Gato</code> e invoca <code>pruebaClaseMetodo()</code> en la clase y
                    <code>pruebaInstanciaMetodo()</code> en la instancia.
                </p>
                <p>
                    La salida de este programa es como sigue:
                </p>
                <div class="codeblock">
                    <pre>
El método estático en Animal
El método de instancia en Gato
                    </pre>
                </div>
                <p>
                    Como se prometió, la versión del método estático ocultado que es invocado es el de la superclase, y la versión
                    del método de instancia sobreescrito que es invocado es el de la subclase.
                </p>
                <h2>
                    <a id="default">Métodos de Interfaz</a>
                </h2>
                <p>Los 
                    <a class="TutorialLink" target="_top" href="../../java/IandI/defaultmethods.html">
                        Métodos por Defecto
                    </a> y
                    <a class="TutorialLink" target="_top" href="../../java/IandI/abstract.html">
                        métodos abstractos
                    </a> en los interfaces son heredados como los métodos de instancia. Sin embargo, cuando los supertipos de una
                    clase o interfaz ofrecen múltiples métodos por defecto con la misma firma, el compilador de Java sigue reglas de
                    herencia para resolver el conflicto de nombres. Estas reglas están conducidas por los dos siguientes principios:
                </p>
                <ul>
                    <li>
                        <p>
                            Los métodos de instancia son preferidos sobre los métodos por defecto de la interfaz.
                        </p>
                        <p>
                            Considere las siguientes clases e interfaces:
                        </p>
                        <pre class="codeblock">
public class Caballo {
    public String meIdentifico() {
        return "Soy un caballo.";
    }
}
                        </pre>
                        <pre class="codeblock">
public interface Volante {
    default public String meidentifico() {
        return "Soy capaz de volar.";
    }
}
                        </pre>
                        <pre class="codeblock">
public interface Mitico {
    default public String meIdentifico() {
        return "Soy una criatura mítica.";
    }
}
                        </pre>
                        <pre class="codeblock">
public class Pegaso extends Caballo implements Volador, Mitico {
    public static void main(String... args) {
        Pegaso miApli = new Pegaso();
        System.out.println(miApli.meIdentifico());
    }
}
                        </pre>
                        <p>
                            El método <code>Pegaso.meIdentifico</code> devuelve la cadena <code>Soy un caballo.</code>
                        </p>
                    </li>
                    <li>
                        <p>
                            Los métodos que están ya sobreescritos por otros candidatos son ignorados. Esta circunstancia puede
                            surgir cuando los supertipos comparten un ancestro común.
                        </p>
                        <p>
                            Considere los siguiente interfaces y clases:
                        </p>
                        <pre class="codeblock">
public interface Animal {
    default public String meIdentifico() {
        return "Soy un animal.";
    }
}
                        </pre>
                        <pre class="codeblock">
public interface PonedorHuevos extends Animal {
    default public String meIdentifico() {
        return "Soy capaz de poner huevos.";
    }
}
                        </pre>
                        <pre class="codeblock">
public interface RespiraFuego extends Animal { }
                        </pre>
                        <pre class="codeblock">
public class Dragon implements PonedorHuevos, RespiraFuego {
    public static void main (String... args) {
        Dragon miApli = new Dragon();
        System.out.println(miApli.meIdentifico());
    }
}
                        </pre>
                        <p>
                            El método <code>Dragon.meIdentifico</code> devuelve la cadena <code>Soy capaz de poner huevos.</code>
                        </p>
                    </li>
                </ul>
                <p>
                    Si dos o más independientemente definidos métodos por defecto entran en conflicto, o un método por defecto
                    entra en conflicto con un método abstracto, entonces el compilador de Java produce un error de compilación.
                    Debe explícitamente sobreescribir los métodos del supertipo.
                </p>
                <p>
                    Considere el ejemplo sobre coches controlados-por-computadora que pueden ahora volar. Tiene dos interfaces
                    (<code>OperaCoche</code> y <code>VuelaCoche</code>) que establecen implementaciones por defecto para el mismo
                    método ,(<code>arrancarMotor</code>):
                </p>
                <pre class="codeblock">
public interface OperaCoche {
    // ...
    default public int arrancarMotor(LlaveCifrada llave) {
        // Implementación
    }
}
                </pre>
                <pre class="codeblock">
public interface VuelaCoche {
    // ...
    default public int arrancarMotor(LlaveCifrada llave) {
        // Implementación
    }
}
                </pre>
                <p>
                    Una clase que implemente ambos <code>OperaCoche</code> y <code>VuelaCoche</code> debe sobreescribir el
                    método <code>arrancarMotor</code>. Podría invocar cualquiera de las implementaciones por defecto con la palabra
                    clave <code>super</code>.
                </p>
                <pre class="codeblock">
public class CocheVolador implements OperaCoche, VuelaCoche {
    // ...
    public int arrancarMotor(LlaveCifrada llave) {
        VuelaCoche.super.arrancarMotor(key);
        OperaCoche.super.arrancarMotor(key);
    }
}
                </pre>
                <p>
                    El nombre que precede a <code>super</code> (en este ejemplo, <code>VuelaCoche</code> o <code>OperaCoche</code>)
                    debe referirse al superinterfaz directo que define o hereda un método por defecto para el método invocado. Esta
                    forma de invocación de métodos no está restringida a diferenciar entre múltiples interfaces implementados que 
                    contienen métodos por defecto con la misma firma. Puede usar la palabra clave <code>super</code> para invocar
                    un método por defecto en ambas clases e interfaces.
                </p>
                <p>
                    Los métodos de instancia heredados de clases pueden sobreescribir métodos abstractos de interfaz. Considere los
                    siguientes interfaces y clases:
                </p>
                <div class="codeblock">
                    <pre>
public interface Mamifero {
    String meIdentifico();
}
                    </pre>
                </div>
                <div class="codeblock">
                    <pre>
public class Caballo {
    public String meIdentifico() {
        return "Soy un caballo.";
    }
}
                    </pre>
                </div>
                <div class="codeblock">
                    <pre>
public class Mustango extends Caballo implements Mammal {
    public static void main(String... args) {
        Mustango miApli = new Mustango();
        System.out.println(miApli.meIdentifico());
    }
}
                    </pre>
                </div>
                <p>
                    El método <code>Mustango.meIdentifico</code> devolverá la cadena <code>Soy un caballo.</code> La clase
                    <code>Mustango</code> hereda el método <code>meIdentifico</code> de la clase <code>Caballo</code>, la cual
                    sobreescribe el método abstracto del mismo nombre en la interfaz <code>Mammal</code>.
                </p>
                <p>
                    <strong>Nota</strong>: Los métodos estáticos en las interfaces no son nunca heredados.
                </p>
                <h2>Modificadores</h2>
                <p>
                    El especificador de acceso para un método que sobreescribe puede permitir más, pero no menos, acceso que el
                    método sobreescrito. Por ejemplo, un método de instancia protegido en la superclase puede ser hecho público,
                    pero no privado, en la subclase.
                </p>
                <p>
                    Obtendrá un error en tiempo de compilación si intenta cambiar un método de instancia en la superclase a un
                    método estático en la subclase, y viceversa.
                </p>
                <h2>Sumario</h2>
                <p>
                    <span id="table:override-method">La siugiente tabla</span> sumariza lo que ocurre cuando define un método con la
                    misma firma que un método en una superclase.
                </p>
                <table class="celda">
                    <caption style="font-weight: bold" id="override-method">
                        Definir un Método con la Misma Firma que un Metodo de una Superclase
                    </caption>
                    <tr>
                        <th id="h1" class="celda">&nbsp;</th>
                        <th id="h2" class="celda">Método de Instancia de Superclase</th>
                        <th id="h3" class="celda">Método Estático de Superclase</th>
                    </tr>
                    <tr>
                        <th id="h4" class="celda">Método de Instancia de Subclase</th>
                        <td headers="h1" class="celda">Sobreescribe</td>
                        <td headers="h2" class="celda">Genera un error en tiempo de compilación</td>
                    </tr>
                    <tr>
                        <th id="h5" class="celda">Método Estático de Subclase</th>
                        <td headers="h1" class="celda">Genera un error en tiempo de compilación</td>
                        <td headers="h2" class="celda">Oculta</td>
                    </tr>
                </table>
                <div class="note">
                    <hr />
                    <strong>Nota:</strong>&nbsp;En una subclase, puede sobreescribir los métodos heredados de la superclase. Tales
                    métodos sobreescritos no ocultan ni sobreescriben los métodos de instancia de la superclase &mdash; Ellos son
                    nuevos métodos, únicos de la subclase.
                    <hr />
                </div>
            </div>
            <div class="NavBit">
                <a target="_top" href="multipleinheritance.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="polymorphism.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.</p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente <a target="_blank" href="../../information/run-examples.html">
                                Compilando y Ejecutando los Ejemplos: PFs</a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Herencia Múltiple de Estado, Implementación, y Tipo<br />
            <b>Página siguiente:</b> Polimorfismo
        </div>
    </body>
</html> 
