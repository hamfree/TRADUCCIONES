<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Métodos por Defecto (Los Tutoriales de Java&trade; &gt; Aprendiendo el Lenguaje Java &gt; Interfaces y Herencia)
        </title>
        <meta name="description" content="Este tutorial para principiantes de Java describle los fundamentos de programación en el
              lenguaje de programación Java" />
        <meta name="keywords" content="java programming, learn java, java sample code, java objects, java classes, java inheritance,
              interfaces, variables, arrays, data types, operators, control flow, number, string" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper  clearfix">       
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div> 
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div> 
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Interfaces y Herencia</a></div>
                <div class="linkAHEAD"><a href="createinterface.html">Interfaces</a></div>
                <div class="linkBHEAD"><a href="interfaceDef.html">Definiendo una Interfaz</a></div>
                <div class="linkBHEAD"><a href="usinginterface.html">Implementando una Interfaz</a></div>
                <div class="linkBHEAD"><a href="interfaceAsType.html">Usando una Interfaz Como un Tipo</a></div>
                <div class="linkBHEAD"><a href="nogrow.html">Evolucionando interfaces</a></div>
                <div class="nolinkBHEAD">Métodos por Defecto</div>
                <div class="linkBHEAD"><a href="summary-interface.html">Sumario de Interfaces</a></div>
                <div class="linkQUESTIONS"><a href="QandE/interfaces-questions.html">Preguntas y Ejercicios</a></div>
                <div class="linkAHEAD"><a href="subclasses.html">Herencia</a></div>
                <div class="linkBHEAD"><a href="multipleinheritance.html">Herencia Múltiple de Estado, Implementación, y Tipo</a></div>
                <div class="linkBHEAD"><a href="override.html">Sobreescribiendo y Ocultando Métodos</a></div>
                <div class="linkBHEAD"><a href="polymorphism.html">Polimorfismo</a></div>
                <div class="linkBHEAD"><a href="hidevariables.html">Ocultando Campos</a></div>
                <div class="linkBHEAD"><a href="super.html">Usando la Palabra Clave super</a></div>
                <div class="linkBHEAD"><a href="objectclass.html">Object como una Superclase</a></div>
                <div class="linkBHEAD"><a href="final.html">Escribiendo Clases y Métodos Finales</a></div>
                <div class="linkBHEAD"><a href="abstract.html">Métodos y Clases Abstractos</a></div>
                <div class="linkBHEAD"><a href="summaryinherit.html">Sumario de Herencia</a></div>
                <div class="linkQUESTIONS"><a href="QandE/inherit-questions.html">Preguntas y Ejercicios</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Aprendiendo el Lenguaje Java<br />
                <b>Lección:</b> Interfaces y Herencia<br />
                <b>Sección:</b> Interfaces
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Aprendiendo el Lenguaje Java</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Interfaces y Herencia</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="nogrow.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="summary-interface.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Métodos por Defecto</h1>
            </div>
            <div id="PageContent">
                <p>
                    La sección
                    <a class="TutorialLink" target="_top"
                       href="../../java/IandI/createinterface.html">
                        Interfaces
                    </a> describe un ejemplo que implica a manufactureros de coches conotrolados por computadora que publican
                    interfaces estándar de la industria que describen qué métodos pueden ser invocados para operar sus coches. ¿Qué
                    ocurre si esos manufactureros de coches controlados por computadora añaden nueva funcionalidad, como volar, a
                    sus coches? Estos manufactureros necesitarían especificar nuevos métodos par habilitar a otras compañías (como
                    los manufactureros de instrumentos electrónicos de guía) a adaptar su software para los coches voladores. ¿Dónde
                    declarararían estos manufactureros de coches esos nuevos métodos relacionados con el vuelo? Si los añaden a sus
                    interfaces originales, entonces los programadores que han implementado esos interfaces tendrían que reescribir
                    sus implementaciones. Si ellos los añaden como métodos estáticos, entonces los programadores los considerarían
                    como métodos de utilidad, no como métodos básicos esenciales.
                </p>
                <p>
                    Los métodos por defecto le habilitan el añadir nueva funcionalidad a los interfaces de sus librerías y asegurar
                    la compatibilidad binar con el código escrito para versiones más antiguas de esos interfaces.
                </p>
                <p>
                    Consider el siguiente interfaz,
                    <a class="SourceLink" target="_blank" href="examples/ClienteTiempo.java"
                       onclick="showCode('../../displayCode.html', 'examples/ClienteTiempo.java'); return false;">
                        <code>ClienteTiempo</code></a>, como es descrito en
                    <a class="TutorialLink" target="_top"
                       href="../../java/IandI/QandE/interfaces-answers.html">
                        Respuestas a Preguntas y Ejercicios: Interfaces</a>:
                </p>
                <div class="codeblock">
                    <pre>

import java.time.*; 
 
public interface ClienteTiempo {
    void setTiempo(int hora, int minuto, int segundo);
    void setFecha(int dia, int mes, int año);
    void setFechaYTiempo(int dia, int mes, int año,
            int hora, int minuto, int segundo);
    LocalDateTime getTiempoYFechaLocal();
}

                    </pre>
                </div>
                <p>
                    La siguiente clase,
                    <a class="SourceLink" target="_blank"
                       href="examples/defaultmethods/ClienteTiempoSimple.java"
                       onclick="showCode('../../displayCode.html', 'examples/defaultmethods/ClienteTiempoSimple.java'); return false;">
                        <code>ClienteTiempoSimple</code>
                    </a>, implementa <code>ClienteTiempo</code>:
                </p>
                <div class="codeblock">
                    <pre>

package java.IandI.examples.defaultmethods;

import java.time.*;
import java.lang.*;
import java.util.*;

public class ClienteTiempoSimple implements ClienteTiempo {

    private LocalDateTime fechaYTiempo;

    public ClienteTiempoSimple() {
        fechaYTiempo = LocalDateTime.now();
    }

    public void setTiempo(int hora, int minuto, int segundo) {
        LocalDate fechaActual = LocalDate.from(fechaYTiempo);
        LocalTime tiempoAFijar = LocalTime.of(hora, minuto, segundo);
        fechaYTiempo = LocalDateTime.of(fechaActual, tiempoAFijar);
    }

    public void setFecha(int dia, int mes, int año) {
        LocalDate fechaAFijar = LocalDate.of(dia, mes, año);
        LocalTime tiempoActual = LocalTime.from(fechaYTiempo);
        fechaYTiempo = LocalDateTime.of(fechaAFijar, tiempoActual);
    }

    public void setFechaYTiempo(int dia, int mes, int año,
            int hora, int minuto, int segundo) {
        LocalDate fechaAFijar = LocalDate.of(dia, mes, año);
        LocalTime tiempoAFijar = LocalTime.of(hora, minuto, segundo);
        fechaYTiempo = LocalDateTime.of(fechaAFijar, tiempoAFijar);
    }

    public LocalDateTime getFechaYTiempoLocal() {
        return fechaYTiempo;
    }

    public String toString() {
        return fechaYTiempo.toString();
    }

    public static void main(String... args) {
        ClienteTiempo miClienteTiempo = new ClienteTiempoSimple();
        System.out.println(miClienteTiempo.toString());
    }
}
                    </pre>
                </div>
                <p>
                    Suponga que quiere añadir nueva funcionalidad al interfaz <code>ClienteTiempo</code>, tal como la habilidad para
                    especificar una zona de tiempo a través del objeto
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html">
                        <code>ZonedDateTime</code>
                    </a> (el cual es como un objeto
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html">
                        <code>LocalDateTime</code></a> excepto que alamcena información de la zona de tiempo):
                </p>
                <div class="codeblock">
                    <pre>
public interface ClienteTiempo {
    void setTiempo(int hora, int minuto, int segundo);
    void setFecha(int dia, int mes, int año);
    void setFechaYTiempo(int dia, int mes, int año,
            int hora, int minuto, int segundo);
    LocalDateTime getTiempoYFechaLocal();
    <strong>ZonedDateTime getTiempoYFechaZona(String zonaString);</strong>
}
                    </pre>
                </div>
                <p>
                    Siguiendo esta modificación a la interfaz <code>ClientTiempo</code>, usted tendría que modificar la clase
                    <code>ClienteTiempoSimple</code> e implementar el método <code>getTiempoYFechaZona</code>. Sin embargo, en vez
                    de dejar <code>getTiempoYFechaZona</code> como <code>abstract</code> (como en el ejemplo previo), usted puede
                    definir una <em>implementación por defecto</em>. (Recuerde que un
                    <a class="TutorialLink" target="_top" href="../../java/IandI/abstract.html">
                        método abstracto
                    </a> es un método declarado sin una implementación).
                </p>
                <div class="codeblock">
                    <pre>

package defaultmethods;
 
import java.time.*;

public interface ClienteTiempo {
    void setTiempo(int hora, int minuto, int segundo);
    void setFecha(int dia, int mes, int año);
    void setTiempoYFecha(int dia, int mes, int año,
                               int hora, int minuto, int segundo);
    LocalDateTime getFechaYTiempoLocal();
    
    static ZoneId getZoneId (String zonaCadena) {
        try {
            return ZoneId.of(zonaCadena);
        } catch (DateTimeException e) {
            System.err.println(&quot;Zona de tiempo no válida: &quot; + zonaCadena +
                &quot;; usando la zona de tiempo por defecto en su lugar.&quot;);
            return ZoneId.systemDefault();
        }
    }
        
    default ZonedDateTime getTiempoYFechaZona(String zonaCadena) {
        return ZonedDateTime.of(getLocalDateTime(), getZoneId(zonaCadena));
    }
}
                    </pre>
                </div>

                <p>
                    Usted especifica que una definición de método en una interfaz es un método por defecto con la palabra clave
                    <code>default</code> al principio de la firma del método. Todas las declaraciones de método en una interfaz,
                    incluyendo los métodos por defecto, son implícitamente <code>públicas</code>, asi que puede omitir el
                    modificador <code>public</code>.
                </p>
                <p>
                    Con este interfaz, no tiene que modificar la clase <code>ClienteSimpleTiempo</code>, y esta clase (y cualquier
                    clase que implemente el interfaz <code>ClienteTiempo</code>), tendrá el método <code>getTiempoYFechaZona</code>
                    también definido. El siguiente ejemplo,
                    <a class="SourceLink" target="_blank"
                       href="examples/defaultmethods/PruebaClienteSimpleTiempo.java"
                       onclick="showCode('../../displayCode.html', 'examples/defaultmethods/PruebaClienteSimpleTiempo.java'); return false;">
                        <code>PruebaClienteSimpleTiempo</code>
                    </a>, invoca el método <code>getTiempoYFechaZona</code> desde una instancia de <code>ClienteSimpleTiempo</code>:
                </p>
                <div class="codeblock">
                    <pre>

package java.IandI.examples.defaultmethods;

import java.time.*;
import java.lang.*;
import java.util.*;

// Fuente original: TestSimpleTimeClient.java
public class PruebaClienteTiempoSimple {

    public static void main(String... args) {
        ClienteTiempoSimple miClienteTiempo = new ClienteTiempoSimple();
        System.out.println(&quot;Tiempo actual: &quot; + miClienteTiempo.toString());
        System.out.println(&quot;Tiempo en California: &quot;
                + miClienteTiempo.getTiempoYFechaZona(&quot;Blah blah&quot;).toString());
    }
}
                    </pre>
                </div>
                <h2><a id="extending">Extendiendo Interfaces Que Contiene Métodos por Defecto</a></h2>
                <p>
                    Cuando extiende un interfaz que contiene un método por defecto, puede hacer lo siguiente:
                </p>
                <ul>
                    <li>
                        No mencionar el método por defecto en absoluto, lo que le permite extender el interfaz heredando el método
                        por defecto.
                    </li>
                    <li>
                        Redeclarar el método por defecto, lo que lo hace <code>abstracto</code>.
                    </li>
                    <li>
                        Redefinir el método por defecto, lo que lo sobreescribe.
                    </li>
                </ul>
                <p>
                    Suponga que extiend elinterfaz <code>ClienteTiempo</code> como sigue:
                </p>
                <div class="codeblock">
                    <pre>
public interface OtroClienteTiempo extends ClienteTiempo { }
                    </pre>
                </div>
                <p>
                    Cualquier clase que implemente el interfaz <code>OtroClienteTiempo</code> tendrá la implementación especificada
                    por el método por defecto <code>ClienteTiempo.getTiempoYFechaZona</code>.
                </p>
                <p>
                    Suponga que extiende el interfaz <code>ClienteTiempo</code> como sigue:
                </p>
                <div class="codeblock">
                    <pre>
public interface ClienteTiempoZonaAbstracto extends ClienteTiempo {
    public ZonedDateTime getTiempoYFechaZona(String zonaCadena);
}
                    </pre>
                </div>

                <p>
                    Cualquier clases que implemente el interfaz <code>ClienteTiempoZonaAbstracto</code> tendrá que implementar el
                    método <code>getTiempoYFechaZona</code>; este método es un método <code>abstracto</code> como todos los otros
                    no por defecto (y no estáticos) métodos en un interfaz.
                </p>
                <p>
                    Suponga que extiende el interfaz <code>ClienteTiempo</code> como sigue:
                </p>
                <div class="codeblock">
                    <pre>
public interface ClienteTiempoZonaManejaInvalido extends ClienteTiempo {
    default public ZonedDateTime getTiempoYFechaZona(String zonaCadena) {
        try {
            return ZonedDateTime.of(getLocalDateTime(),ZoneId.of(zonaCadena));
        } catch (DateTimeException e) {
            System.err.println("ID de zona no válido: &quot; + zonaCadena +
                &quot; usando la zona de tiempo por defecto en su lugar.&quot;);
            return ZonedDateTime.of(getLocalDateTime(),ZoneId.systemDefault());
        }
    }
}
                    </pre>
                </div>
                <p>
                    Cualquier clase que implemente el interfaz <code>ClienteTiempoZonaManejaInvalido</code> usará la implementación
                    de <code>getTiempoYFechaZona</code> especificado por esta interfaz en vez de la especificada en la interfaz
                    <code>ClienteTiempo</code>.
                </p>
                <h2><a id="static">Métodos Estáticos</a></h2>
                <p>
                    Además de los métodos por defecto, puede definir
                    <a class="TutorialLink" target="_top" href="../../java/javaOO/classvars.html">
                        métodos estáticos
                    </a> en los interfaces. (Un método estático es un método que està asociado con la clase en la cual está definido
                    en vez de con cualquier objeto. Cada instancia de la clase comparte sus métodos estáticos). Esto hace más fácil
                    para usted organizra métodos de apoyo en sus librerías; puede mantener los métodos estáticos específicos de un
                    interfaz en el mismo interfaz en vez de en una clase separada. El siguiente ejemplo define un método estático
                    que recupera un objeto
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html">
                        <code>ZoneId</code>
                    </a> que corresponde a un identificador de zona de tiempo; usa la zona de tiempo del sistema por defecto si no
                    hay objeto <code>ZoneId</code> que corresponda al identificador dado. (Como resultado, puede simplificar el
                    método <code>getTiempoYFechaZona</code>):
                </p>
                <div class="codeblock">
                    <pre>
public interface ClienteTiempo {
    // ...
    static public ZoneId getZoneId (String zonaCadena) {
        try {
            return ZoneId.of(zonaCadena);
        } catch (DateTimeException e) {
            System.err.println("Zona de tiempo no válida: &quot; + zonaCadena +
                &quot;; usando la zona de tiempo por defecto en su lugar.&quot;);
            return ZoneId.systemDefault();
        }
    }

    default public ZonedDateTime getTiempoYFechaZona(String zonaCadena) {
        return ZonedDateTime.of(getLocalDateTime(), getZoneId(zonaCadena));
    }    
}
                    </pre>
                </div>
                <p>
                    Como los métodos estáticos en las clases, usted especifica que una definición de método en una interfaz es un
                    método estático con la palabra clave <code>static</code> al principio de la firma del método. Todas las
                    declaraciones de métodos en una interfaz, incluyendo los métodos estáticos, son implícitamente 
                    <code>públicos</code>, de forma que puede omitir el modificador <code>public</code>.
                </p>
                <h2><a id="existing_libraries">Integrando Métodos por Defecto en Librerías Existentes</a></h2>
                <p>
                    Los métodos por defecto le habilitan añadir nueva funcionalidad a los interfaces existentes y asegurar la
                    compatibilidad binaria con el código escrito para versiones más viejas de esos interfaces. En particular, los
                    métodos por defecto le habilitan para añadir métodos que aceptan expresiones lambda como parámetros en los
                    interfaces existentes. Esta sección demuestra cómo la interfaz
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html">
                        <code>Comparator</code></a> ha sido mejorada con métodos estáticos y por defecto.
                </p>
                <p>
                    Considere las clases <code>Carta</code> y <code>Baraja</code> como están descritas en
                    <a class="TutorialLink" target="_top" 
                       href="../../java/javaOO/QandE/creating-questions.html">
                        Preguntas y Ejercicios: Clases</a>. Este ejemplo reescribe las clases e interfaces
                    <a class="SourceLink" target="_blank" href="examples/defaultmethods/Carta.java"
                       onclick="showCode('../../displayCode.html', 'examples/defaultmethods/Carta.java'); return false;">
                        <code>Carta</code></a> y
                    <a class="SourceLink" target="_blank" href="examples/defaultmethods/Baraja.java"
                       onclick="showCode('../../displayCode.html', 'examples/defaultmethods/Baraja.java'); return false;">
                        <code>Baraja</code>
                    </a>. El interfaz <code>Carta</code> contiene dos tipos <code>enumeración</code>
                    (<code>Palo</code> y <code>Rango</code>) y dos métodos abstractos (<code>getPalo</code> and
                    <code>getRango</code>):
                </p>
                <div class="codeblock">
                    <pre>

package defaultmethods;

public interface Carta extends Comparable&lt;Carta&gt; {

    public enum Palo {
        DIAMANTES (1, &quot;Diamantes&quot;),
        TREBOLES  (2, &quot;Tréboles&quot; ),
        CORAZONES (3, &quot;Corazones&quot;),
        PICAS     (4, &quot;Picas&quot;    );

        private final int valor;
        private final String texto;

        Palo(int valor, String texto) {
            this.valor = valor;
            this.texto = texto;
        }

        public int value() {
            return valor;
        }

        public String text() {
            return texto;
        }
    }

    public enum Rango {
        DOS    (2,  &quot;Dos&quot;   ),
        TRES   (3,  &quot;Tres&quot;  ),
        CUATRO (4,  &quot;Cuatro&quot;),
        CINCO  (5,  &quot;Cinco&quot; ),
        SEIS   (6,  &quot;Seis&quot;  ),
        SIETE  (7,  &quot;Siete&quot; ),
        OCHO   (8,  &quot;Ocho&quot;  ),
        NUEVE  (9,  &quot;Nueve&quot; ),
        DIEZ   (10, &quot;Diez&quot;  ),
        SOTA   (11, &quot;Sota&quot;  ),
        REINA  (12, &quot;Reina&quot; ),
        REY    (13, &quot;Rey&quot;   ),
        AS     (14, &quot;As&quot;    );
        private final int valor;
        private final String texto;

        Rango(int valor, String texto) {
            this.valor = valor;
            this.texto = texto;
        }

        public int valor() {
            return valor;
        }

        public String texto() {
            return texto;
        }
    }

    public Carta.Palo getPalo();

    public Carta.Rango getRango();
}
                    </pre>
                </div>
                <p>
                    La interfaz <code>Baraja</code> contiene varios métodos que manipulan cartas en una baraja:
                </p>
                <div class="codeblock">
                    <pre>

package defaultmethods; 
 
import java.util.*;
import java.util.stream.*;
import java.lang.*;
 
public interface Baraja {

    List&lt;Carta&gt; getCartas();

    Baraja barajaFactoria();

    int tamaño();

    void añadeCarta(Carta carta);

    void añadeCartas(List&lt;Carta&gt; cartas);

    void añadeBaraja(Baraja baraja);

    void barajar();

    void ordenar();

    void ordenar(Comparator&lt;Carta&gt; c);

    String barajaToString();

    Map&lt;Integer, Baraja&gt; repartir(int jugadores, int numeroDeCartas)
            throws IllegalArgumentException;

}
                    </pre>
                </div>
                <p>La clase
                    <a class="SourceLink" target="_blank" href="examples/defaultmethods/JugandoCarta.java"
                       onclick="showCode('../../displayCode.html', 'examples/defaultmethods/JugandoCarta.java'); return false;">
                        <code>JugandoCarta</code>
                    </a> implementa el interfaz <code>Carta</code>, y la clase
                    <a class="SourceLink" target="_blank" href="examples/defaultmethods/BarajaEstandar.java"
                       onclick="showCode('../../displayCode.html', 'examples/defaultmethods/BarajaEstandar.java'); return false;">
                        <code>BarajaEstandar</code>
                    </a> implementa el interfaz <code>Baraja</code>.
                </p>
                <p>
                    La clase <code>BarajaEstandar</code> implementa el método abstracto <code>Baraja.ordenar</code> como sigue:
                </p>
                <div class="codeblock">
                    <pre>
public class BarajaEstandar implements Baraja {
    
    private List&lt;Card&gt; barajaEntera;
    
    // ...
    
    public void ordenar() {
        Collections.sort(barajaEntera);
    }
    
    // ...
}
                    </pre>
                </div>
                <p>
                    El método <code>Collections.sort</code> ordena una instancia de <code>List</code> cuyo tipo de elemento
                    implementa la interfaz
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">
                        <code>Comparable</code>
                    </a>. El miembro <code>barajaEntera</code> es una instancia de <code>List</code> cuyos elementos osn del tipo
                    <code>Carta</code>, la cual extiende <code>Comparable</code>. La clase <code>JugandoCarta</code> implementa el
                    método
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-">
                        <code>Comparable.compareTo</code>
                    </a> como sigue:
                </p>
                <div class="codeblock">
                    <pre>
 public int hashCode() {
        return ((palo.valor() - 1) * 13) + rango.valor();
 }

 public int compareTo(Carta o) {
        return this.hashCode() - o.hashCode();
 }
                    </pre>
                </div>
                <p>
                    El método <code>compareTo</code> hace que el método estándar <code>Deck.sort()</code> para ordenar la baraja de
                    cartas por primera vez por el juego, y luego por rango.
                </p>
                <p>
                    ¿Qué pasa si desea ordenar la baraja por primera vez por el rango, a continuación, por palo? Necesitaría
                    implementar el interfaz
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html">
                        <code>Comparator</code>
                    </a> para especificar el nuevo criterio de ordenación, y usar el método
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-java.util.Comparator-">
                        <code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>
                    </a> (la versión del método <code>sort</code> que incluye un parámetro <code>Comparator</code>). Usted puede
                    definir el siguiente método en la clase <code>BarajaEstandar</code>:
                </p>
                <div class="codeblock">
                    <pre>
public void ordenar(Comparator&lt;Carta&gt; c) {
    Collections.sort(barajaEntera, c);
}  
                    </pre>
                </div>
                <p>
                    Con este método, puede especificar cómo el método <code>Collections.sort</code> ordena instancias de la clase
                    <code>Carta</code>. Una forma de hacer esto es implementar la interfaz <code>Comparator</code> para especificar
                    cómo quiere las cartas ordenads. El ejemplo
                    <a class="SourceLink" target="_blank" href="examples/defaultmethods/OrdenarPorRangoEntoncesPorPalo.java"
                       onclick="showCode('../../displayCode.html', 'examples/defaultmethods/OrdenarPorRangoEntoncesPorPalo.java'); return false;">
                        <code>OrdenarPorRangoEntoncesPorPalo</code>
                    </a> hace esto:
                </p>
                <div class="codeblock">
                    <pre>

package java.IandI.examples.defaultmethods;

import java.util.*;
import java.util.stream.*;
import java.lang.*;

public class OrdenarPorRangoEntoncesPorPalo implements Comparator&lt;Carta&gt; {

    public int compare(Carta firstCard, Carta secondCard) {
        int compVal
                = firstCard.getRango().valor() - secondCard.getRango().valor();
        if (compVal != 0) {
            return compVal;
        } else {
            return firstCard.getPalo().valor() - secondCard.getPalo().valor();
        }
    }
}
                    </pre>
                </div>
                <p>
                    Las siguiente invocación ordena la baraja de cartas primero por rango, luego por palo:
                </p>
                <div class="codeblock">
                    <pre>
BarajaEstandar miBaraja = new BarajaEstandar();
miBaraja.barajar();
miBaraja.ordenar(new OrdenarPorRangoEntoncesPorPalo());
                    </pre>
                </div>
                <p>
                    Sin embarog, este enfoque es demasiado detallado; sería mejor si pudiera especificar <em>que</em> quiere
                    ordenar, no <em>cómo</em> quiere ordenar. Suponga que usted es el desarrollador que escribió la interfaz
                    <code>Comparator</code>. ¿Qué métodos por defecto o estáticos podría añadir al interfaz <code>Comparator</code>
                    para habilitar que a otros desarrolladores les sea más fácil especificar criterios de ordenación?
                </p>
                <p>
                    Para empezar, suponga que quiere ordenar la baraja de cartas por rango, independientemente de su palo. Puede
                    invocar el método <code>BarajaEstandar.ordenar</code> como sigue:
                </p>
                <div class="codeblock">
                    <pre>
BarajaEstandar miBaraja = new BarajaEstandar();
miBaraja.barajar();
miBaraja.ordenar(
    (primeraCarta, segundaCarta) -&gt;
        primeraCarta.getRango().vaor() - segundaCarta.getRango().valor()
); 
                    </pre>
                </div>
                <p>
                    Porque el interfaz <code>Comparator</code> es un
                    <a class="TutorialLink" target="_top"
                       href="../../java/javaOO/lambdaexpressions.html#approach6">
                        interfaz funcional
                    </a>, puede usar una expresión lambda como un argumento para el método <code>ordenar</code>. En este ejemplo, la
                    expresión lambda compara dos valores enteros.
                </p>
                <p>
                    Sería más simple para sus desarrolladores si ellos pudieran crear una instancia <code>Comparator</code>
                    invocando el método <code>Carta.getRango</code> sólo. En particular, sería de mucha ayuda si sus desarrolladores
                    pudieran crear una instancia <code>Comparator</code> que compare cualquier objeto que pueda devolver un valor
                    numérico desde un método tal como <code>getValor</code> o <code>hashCode</code>. El interfaz
                    <code>Comparator</code> ha sido mejorado con esta habilidad con el método estático
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparing-java.util.function.Function-java.util.Comparator-">
                        <code>comparing</code></a>:
                </p>
                <div class="codeblock">
                    <pre>
miBaraja.sort(Comparator.comparing((carta) -> carta.getRango()));
                    </pre>
                </div>
                <p>
                    En este ejemplo, puede usar una
                    <a class="TutorialLink" target="_top"
                       href="../../java/javaOO/methodreferences.html">
                        referencia a método</a> en su lugar:
                </p>
                <div class="codeblock">
                    <pre>
miBaraja.sort(Comparator.comparing(Carta::getRango));
                    </pre>
                </div>
                <p>
                    Esta invocación demuestra mejor <em>qué</em> ordenar en vez de <em>cómo</em> hacerlo.
                </p>
                <p>
                    El interfaz <code>Comparator</code> ha sido mejorado con otras versiones del método estático
                    <code>comparing</code> tales como
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparingDouble-java.util.function.ToDoubleFunction-java.util.Comparator-">
                        <code>comparingDouble</code>
                    </a> y
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparingLong-java.util.function.ToLongFunction-">
                        <code>comparingLong</code>
                    </a> que le habilitan a crear instancias de <code>Comparator</code> que comparan otros tipos de datos.
                </p>
                <p>
                    Suponga que sus desarrolladores les gustaría crear una instancia <code>Comparator</code> que pudiera comparar
                    objetos con más de un criterio. Por ejemplo, ¿cómo ordenaría usted la baraja de carats primero por rango, y
                    entonces por palo? Como antes, podría usar una expresión lambda para especificar estos criterios de ordenación:
                </p>
                <div class="codeblock">
                    <pre>
BarajaEstandar miBaraja = new BarajaEstandar();
miBaraja.barajar();
miBaraja.ordenar(
    (primeraCarta, segundaCarta) -> {
        int compara =
            primeraCarta.getRango().valor() - segundaCarta.getRango().valor();
        if (compara != 0)
            return compara;
        else
            return primeraCarta.getPalo().valor() - segundaCarta.getPalo().valor();
    }      
); 
                    </pre>
                </div>
                <p>
                    Sería mas simple para sus desarrolladores si ellos pudieran construir una instancia <code>Comparator</code>
                    desde unas series de instancias <code>Comparator</code>. La interfaz <code>Comparator</code> ha sido mejorada
                    con esta habilidad con el método por defecto
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparing-java.util.Comparator-">
                        <code>thenComparing</code>
                    </a>:
                </p>
                <div class="codeblock">
                    <pre>
miBaraja.ordenar(
    Comparator
        .comparing(Carta::getRango)
        .thenComparing(Comparator.comparing(Carta::getPalo)));
                    </pre>
                </div>
                <p>
                    La interfaz <code>Comparator</code> ha sido mejorada con otras versiones del método por defecto
                    <code>thenComparing</code> (tal como
                    <a class="APILink" target="_blank"
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparingDouble-java.util.function.ToDoubleFunction-">
                        <code>thenComparingDouble</code>
                    </a> and
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparingLong-java.util.function.ToLongFunction-">
                        <code>thenComparingLong</code>
                    </a>) que le habilitan a construir instancias <code>Comparator</code> que comparan otros tipos de datos.
                </p>
                <p>
                    Suponga que a sus desarrolladores les gustaría crear una instancia <code>Comparator</code> que les permita
                    ordenar una colección de objetos en orden inverso. Por ejemplo, ¿cómo ordenaría la baraja de cartas primero
                    por orden descendente de rango, de As a Dos (en vez de Dos a As)? Como antes, podría especificar otra
                    expresión lambda. Sin embargo, sería más simple para sus desarrolladores si pudieran invertir un
                    <code>Comparator</code> existente invocando un método. La interfaz <code>Comparator</code> ha sido mejorada
                    con este habilidad con el método por defecto
                    <a class="APILink" target="_blank" 
                       href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#reversed--">
                        <code>reversed</code>
                    </a>:
                </p>
                <div class="codeblock">
                    <pre>
miBaraja.ordenar(
    Comparator.comparing(Carta::getRango)
        .reversed()
        .thenComparing(Comparator.comparing(Carta::getPalo)));
                    </pre>
                </div>
                <p>
                    Este ejemplo demuestra cómo el interfaz <code>Comparator</code> ha sido mejorado con métodos por defecto,
                    métodos estáticos, expresiones lambda, y referencias a métodos para crear métodos de libreria más expresivos
                    cuya funcionalidad los programadores pueden rápidamente deducir mirando cómo son invocados. Use estas
                    construcciones para mejora las interfaces en sus librerías.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="nogrow.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="summary-interface.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html"> avisos
                                legales </a> .
                        </p>
                        <p class="footertext">Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.</p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente <a target="_blank" href="../../information/run-examples.html">
                                Compilando y Ejecutando los Ejemplos: PFs</a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Evolucionando Interfaces<br />
            <b>Página siguiente:</b> Sumario de Interfaces
        </div>
    </body>
</html>