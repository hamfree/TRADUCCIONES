<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Cuando Usar DOM (Los Tutoriales de Java&trade; &gt; IPA de Java para Procesado de XML (JAXP) &gt; 
            Modelo de Objetos del Documento)
        </title>
        <meta name="description" content="Este tutorial de Java JAXP describe la IPA de Java para el procesado de XML (jaxp), XSLT, 
              SAX, y tópicos de XML relacionados" />
        <meta name="keywords" content="java programming, learn java, java sample code, jaxp, xml, xslt, sax" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Modelo de Objetos del Documento</a></div>
                <div class="nolinkAHEAD">Cuando Usar DOM</div>
                <div class="linkAHEAD"><a href="readingXML.html">Leyendo Datos XML en un DOM</a></div>
                <div class="linkAHEAD"><a href="validating.html">Validando con Schema XML</a></div>
                <div class="linkAHEAD"><a href="info.html">Información Adicional</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> IPA de Java para Procesado de XML (JAXP)<br />
                <b>Lección:</b> Modelo de Objetos del Documento
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">IPA de Java para Procesado de XML (JAXP)</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Modelo de Objetos del Documento</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="index.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="readingXML.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle"><h1>Cuando Usar DOM</h1></div>
            <div id="PageContent">
                <p>
                    El estándar de Modelo de Objetos del Documento está, sobre todo, diseñado para documentos (por ejemplo, 
                    artículos y libros). Además, la implementación de JAXP 1.42. admite el Esquema XML, algo que puede ser una 
                    consideración importante para cualquier aplicación dada.
                </p>
                <p>
                    Por otra parte, si está tratando con estructuras simples de datos y si el Esquema XML no es una gran parte de 
                    sus planes, entonces puede encontrar que uno de los estándares más orientados a objetos, como JDOM o dom4j, 
                    se ajusta mejor a su propósito.
                </p>
                <p>
                    Desde el inicio, se pretendía que DOM fuera un idioma neutro. Ya que fue diseñado para usar con lenguajes como 
                    C y Perl, DOM no se aprovecha de las características orientadas a objetos de Java. Ese hecho, además de la 
                    distinción entre documentos y datos, también ayuda a explicar las formas en que el procesamiento de un DOM 
                    difiere del procesamiento de una estructura JDOM o dom4j.
                </p>
                <p>
                    En esta sección, examinaremos las diferencias entre los modelos subyacentes a esos estándares para ayudarle a 
                    elegir el que sea más apropiado para su aplicación.
                </p>
                <p>
                    <a id="gchlq"></a>
                </p>
                <h2>
                    Documento Contra Datos
                </h2>
                <p>
                    El principal punto de partida entre el modelo de documento usado en DOM y el modelo de datos utilizado en JDOM o 
                    dom4j radica en:
                </p>
                <ul>
                    <li>
                        La clase de nodo que existe en la jerarquía.
                    </li>
                    <li>
                        La capacidad de contenido mixto.

                    </li>
                </ul>
                <p>
                    Esta la diferencia en lo que constituye un &quot;nodo&quot; en la jerarquía de datos lo que explica 
                    principalmente las diferencias en la programación con estos dos modelos. Sin embargo, la capacidad para 
                    contenido mixto, más que cualquier otra cosa, explica la diferencia en cómo los estándares definen un nodo. 
                    Entonces, comenzamos examinando el modelo de contenido mixto de DOM.
                </p>
                <p>
                    <a id="gchkp"></a>
                </p>
                <h2>
                    Modelo de Contenido Mixto
                </h2>
                <p>
                    El texto y los elementos se pueden mezclar libremente en una jerarquía DOM. Esa clase de estructura se llama 
                    contenido mixto en el modelo DOM.
                </p>
                <p>
                    El contenido mixto ocurre frecuentemente en los documentos. Por ejemplo, suponga que quería representar esta 
                    estructura:
                </p>
                <p>
                    <code>&lt;sentence&gt;This is an &lt;bold&gt;important&lt;/bold&gt; idea.&lt;/sentence&gt;</code>
                </p>
                <p>
                    La jerarquía de los nodos DOM parecerían algo como esto, donde cada línea representa un nodo:
                </p>
                <div class="codeblock">
                    <pre>
ELEMENT: sentence
   + TEXT: This is an
   + ELEMENT: bold
     + TEXT: important
   + TEXT: idea.
                    </pre>
                </div>
                <p>
                    Dese cuenta de que cada elemento de sentencia contiene texto, seguido por un subelemento, seguido por texto 
                    adicional. Es la mezcla de texto y elementos lo que define el modelo de contenido mixto.
                </p>
                <p>
                    <a id="gchla"></a>
                </p>
                <h2>
                    Tipos de Nodos
                </h2>
                <p>
                    Para proporcionar la capacidad de contenido mixto, los nodos de DOM son intrínsicamente muy simples. En el 
                    ejemplo anterior, el &quot;contenido&quot; del primer elemento (su valor) simplemente identifica la clase de 
                    nodo que es.
                </p>
                <p>
                    Este hecho suele desconcertar a los usuarios nuevos de un DOM. Después de navegar al nodo 
                    <code>&lt;sentence&gt;</code>, ellos piden el &quot;contenido&quot; del nodo, y esperan obtener algo útil. En 
                    vez de eso, todo lo que ellos encuentran es el nombre del elemento, <code>sentence</code>.
                </p>
                <hr />
                <p>
                    <b>Nota &mdash;</b> La IPA del Nodo DOM define los métodos <code>nodeValue()</code>, <code>nodeType()</code>, y 
                    <code>nodeName()</code>. Para el primer nodo de elemento, <code>nodeName()</code> devuelve 
                    <code>sentence</code>, mientras que <code>nodeValue()</code> devuelve nulo. Para el primer nodo de texto 
                    <code>nodeName()</code> devuelve <code>#text</code>, y <code>nodeValue()</code> devuelve 
                    &ldquo;<code>This is an</code> &rdquo;. El punto importante es que el <b>valor</b> de un elemento no es el 
                    mismo  que su <b>contenido</b>.
                </p>
                <hr />
                <p>
                    En el ejemplo de arriba, ¿qué significa pedir el &quot;texto&quot; de la sentencia? Cualquiera de los 
                    siguientes podría ser razonable, según su aplicación:
                </p>
                <ul>
                    <li>
                        This is an
                    </li>
                    <li>
                        This is an idea.
                    </li>
                    <li>
                        This is an important idea.
                    </li>
                    <li>
                        This is an &lt;bold&gt;important&lt;/bold&gt; idea.
                    </li>
                </ul>
                <p>
                    <a id="gchkz"></a>
                </p>
                <h2>
                    Un Modelo Más Simple
                </h2>
                <p>
                    Con DOM, es libre de crear las semánticas que necesite. Sin embargo, también se le requiere hacer el procesado 
                    necesario para implementar esas semánticas. Los estándares como JDOM y dom4j, por otro lado, facilitan hacer 
                    cosas simples, porque cada nodo en la jerarquía es un objeto.
                </p>
                <p>
                    Aunque JDOM y dom4j permiten elementos con contenido mixto, no están diseñados principalmente para tales 
                    situaciones. En cambio, están destinados a aplicaciones en las que la estructura XML contiene datos.
                </p>
                <p>
                    Los elementos en una estructura de datos habitualmente contienen o texto u otros elementos, pero no ambos. Por 
                    ejemplo, aquí tiene un XML que representa una simple libreta de direcciones:
                </p>
                <div class="codeblock">
                    <pre>
&lt;addressbook>
    &lt;entry>
        &lt;name>Fred&lt;/name>
        &lt;email>fred@home&lt;/email>
    &lt;/entry>
      ...
&lt;/addressbook>
                    </pre>
                </div>
                <hr />
                <p>
                    <b>Nota &mdash;</b> Para estructuras de datos XML muy simples como esta, podría también usar el paquete de 
                    expresiones regulares (<code>java.util.regex</code>) construido dentro de la plataforma Java en la versión 1.4.
                </p>
                <hr />
                <p>
                    En JDOM y dom4j, después de que navega a un elemento que contiene texto, invoca a un método como 
                    <code>text()</code> para obtener su contenido. Cuando procesa un DOM, sin embargo, debe inspeccionar la lista 
                    de subelementos para &quot;juntar&quot; el texto del nodo, como vió anteriormente, incluso si esa lista 
                    contiene solo un elemento (un nodo TEXT).
                </p>
                <p>
                    Así para estructuras de datos simples tales como una libreta de direcciones, puede ahorrarse un poco de trabajo 
                    usando JDOM o dom4j. Tiene sentido usar uno de esos modelos incluso cuando los datos están técnicamente 
                    &quot;mezclados&quot; pero hay siempre un (y sólo un) segmento de txto para un nodo dado.
                </p>
                <p>
                    Aquí tiene un ejemplo de esa clase de estructura, la cual sería también fácilmente procesada en JDOM o dom4j:
                </p>
                <div class="codeblock">
                    <pre>
&lt;addressbook>
    &lt;entry>Fred
        &lt;email>fred@home&lt;/email>
    &lt;/entry>
      ...
&lt;/addressbook>
                    </pre>
                </div>
                <p>
                    Aquí, cada entrada tiene un poco de texto identificativo, seguido de otros elementos. Con esta estructura, el 
                    programa podría navegar a una entrada, invocar <code>text()</code> para averiguar a quién pertenece y procesar 
                    el subelemento <code>&lt;email&gt;</code> si está en el nodo correcto.
                </p>
                <p>
                    <a id="gchls"></a>
                </p>
                <h2>
                    Incrementar la Complejidad
                </h2>
                <p>
                    Pero para que tenga un entendimiento pleno de la clase de procesado que necesita hacer cuando busca o manipula 
                    un DOM, es importante conocer las clases de nodos que un DOM puede contener.
                </p>
                <p>
                    Aquí tiene un ejemplo que ilustra este punto. Es una representación de estos datos:
                </p>
                <div class="codeblock">
                    <pre>
&lt;sentence>
    The &amp;projectName; &lt;![CDATA[&lt;i>project&lt;/i>]]&gt; is
    &lt;?editor: red>&lt;bold>important&lt;/bold>&lt;?editor: normal>.
&lt;/sentence>
                    </pre>
                </div>
                <p>
                    Esta sentencia contiene una <b>referencia de entidad</b> &mdash; un puntero a una entidad que está definida en 
                    otra parte. En este caso, la entidad contiene el nombre del proyecto. El ejemplo también contiene una sección 
                    CDATA (datos no interpretados, como los datos dentro de <code>&lt;pre&gt;</code> en HTML) como también 
                    <b>instrucciones de procesamiento</b> (<code>&lt;?...?&gt;</code>), las cuales en este caso le indican al 
                    editor qué color usar cuando represente el texto.
                </p>
                <p>
                    Aquí está la estructura DOM para esos datos. Es representativo del tipo de estructura que una aplicación 
                    robusta debe estar preparada para manejar:
                </p>
                <div class="codeblock">
                    <pre>
+ ELEMENT: sentence
       + TEXT: The
       + ENTITY REF: projectName
        + COMMENT: 
        The latest name we are using
        + TEXT: Eagle
       + CDATA: &lt;i>project&lt;/i>
       + TEXT: is
       + PI: editor: red
       + ELEMENT: bold
          + TEXT: important
       + PI: editor: normal
                    </pre>
                </div>
                <p>
                    Este ejemplo describe los tipos de nodos que pueden ocurrir en un DOM. Aunque su aplicación pueda ser capaz de 
                    ignorar la mayoría de ellos la mayoría del tiempo, una implementación realmente robusta debe reconocer y 
                    tratar con cada uno de ellos.
                </p>
                <p>
                    Del mismo modo, el proceso de navegar a un nodo incluye el procesado de los subelementos, ignorando los que no 
                    le interesan e inspeccionar los que sí, hasta encontrar el nodo que le interesa.                    
                </p>
                <p>
                    Un programa que trabaja con datos fijos generados internamente puede permitirse hacer suposiciones 
                    simplificadoras: que las instrucciones de procesado, comentarios, nodos CDAT, y referencias de entidades no 
                    existirán en la estructura de datos. Pero las aplicaciones realmente sólidas que funcionan con una variedad 
                    de datos &mdash; especialmente datos que vienen del mundo exterior &mdash; deben estar preparadas para tratar 
                    con todas las entidades XML posibles.
                </p>
                <p>
                    ( Una aplicación &quot;simple&quot; funcionará sólo siempre que los datos de entrada contengan las estructuras 
                    simplificadas de XML que espera. Pero no hay mecanismos de validación para asegurar que estructuras más 
                    complejas no existirán. Después de todo, el XML fue diseñado específicamente para permitirlas).
                </p>
                <p>
                    Para ser más sólida, una aplicación DOM debe hacer estas cosas:
                </p>
                <ol>
                    <li>
                        Cuando busca un elemento:
                        <ol type="a">
                            <li>
                                Ignorar comentarios, atributos, e instrucciones de procesado.
                            </li>
                            <li>
                                Permitir la posibilidad de que los subelementos no ocurran en el orden esperado.
                            </li>
                            <li>
                                Saltar sobre los nodos TEXT que contengan espacio en blanco para ignorar, si no se está validando.
                            </li>
                        </ol>
                    </li>
                    <li>
                        Cuando extraiga texto de un nodo:
                        <ol type="a">
                            <li>
                                Extraer texto de nodos CDA y de los nodos de texto.
                            </li>
                            <li>
                                Ignorar comentarios, atributos, e instrucciones de procesado cuando al recopilar el texto.
                            </li>
                            <li>
                                Si se encuentra un nodo de entidad de referencia u otro nodo de elemento, recurse (es decir, aplique 
                                el procedimiento de extracción de texto a todos los subnodos).
                            </li>
                        </ol>
                    </li>
                </ol>
                <p>
                    Por supuesto, muchas aplicaciones no tendrán que preocuparse sobre estas cosas, pero la clase de datos que ven 
                    será estrictamente controlada. Pero si lo datos pueden venir de una variedad de fuentes externas, entonces la 
                    aplicación probablemente necesitará tener en cuenta esas posibilidades.
                </p>
                <p>
                    El código que necesita para llevar a cabo estas funciones se proporciona cerca del final de esta lección en 
                    <a class="TutorialLink" target="_top" href="readingXML.html#ggdwa">Buscar Nodos</a> y 
                    <a class="TutorialLink" target="_top" href="readingXML.html#ggdxv">Obtener el Contenido de un Nodo</a>. En este 
                    momento, el objetivo es simplemente determinar si DOM es adecuado para su aplicación.
                </p>
                <p>
                    <a id="gchln"></a>
                </p>
                <h2>
                    Elegir Su Modelo
                </h2>
                <p>
                    Como puede ver, cuando usa DOM, incluso una operación simple como obtener el texto de un nodo puede tomar un 
                    poco de programación. Así que sus programas gestionan estructuras de datos simples, entonces JDOM, dom4j, o 
                    incluso el paquete de expresiones regulares (<code>java.util.regex</code>) puede ser más apropiado para sus 
                    necesidades.
                </p>
                <p>
                    Para documentos completos y aplicaciones complejas, por otro lado, DOM le brinda mucha flexibilidad. Y si 
                    necesita usar Esquema XML, entonces de nuevo DOM es el camino a seguir &mdash; al menos por ahora.
                </p>
                <p>
                    Si usted procesa tanto documentos ocmo datos en las aplicaciones que desarrolla, entonces DOM puede ser aún su 
                    mejor elección. Después de todo, después de que ha escrito el código para examinar y procesar una estructura 
                    DOM, es bastante fácil personalizarlo para un propósito específico. Entonces, elegir hacer todo en DOM 
                    significa que solo tendrá que lidiar con un conjunto de IPAs, en lugar de dos.
                </p>
                <p>
                    Además, el estándar DOM es un estándar codificado para un modelo de documento en memoria. Es potente y robusto, 
                    y tiene muchas implementaciones. Ese es un factor de toma de decisiones significativo para muchas instalaciones 
                    grandes, particularmente para aplicaciones a gran escala que necesitan minimizar los costos resultante de los 
                    cambios de IPA.
                </p>
                <p>
                    Finalmente, incluso aunque el texto en la libreta de direcciones no permite negrita, cursiva, colores, y tamaños 
                    de fuente hoy, un día podría querer manejas estas cosas. Ya que DOM gestionará virtualmente cualquier cosas que 
                    le arroje, elegir DOM facilita la preparación de su aplicación para el futuro.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="index.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="readingXML.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Modelo de Objetos del Documento<br />
            <b>Página siguiente:</b> Leyendo Datos XML en un DOM
        </div>
    </body>
</html> 
