<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Introducción a los Interfaces de los Proveedores de Servicio (Los Tutoriales de Java&trade; &gt; Sonido)
        </title>
        <meta name="description" content="" />
        <meta name="keywords" content="java programming, learn java, java sample code, " />
        <link rel="stylesheet" href="../indice.css" type="text/css"/>
        <script src="../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkAHEAD"><a href="sampled-overview.html">Descripción del Paquete Sampled</a></div>
                <div class="linkAHEAD"><a href="accessing.html">Accediendo a los Recursos del Sistema de Audio</a></div>
                <div class="linkAHEAD"><a href="playing.html">Reproducción de Audio</a></div>
                <div class="linkAHEAD"><a href="capturing.html">Grabando Audio</a></div>
                <div class="linkAHEAD"><a href="controls.html">Procesando Audio con Controles</a></div>
                <div class="linkAHEAD"><a href="converters.html">Usando Ficheros y Convertidores de Formato</a></div>
                <div class="linkAHEAD"><a href="overview-MIDI.html">Descripción del Paquete MIDI</a></div>
                <div class="linkAHEAD"><a href="accessing-MIDI.html">Accediendo a los Recursos del Sistema MIDI</a></div>
                <div class="linkAHEAD"><a href="MIDI-messages.html">Transmitiendo y Recibiendo Mensajes MIDI</a></div>
                <div class="linkAHEAD"><a href="MIDI-seq-intro.html">Introducción a los Secuenciadores</a></div>
                <div class="linkAHEAD"><a href="MIDI-seq-methods.html">Utilizando Métodos del Secuenciador</a></div>
                <div class="linkAHEAD"><a href="MIDI-seq-adv.html">Usando Características Avanzadas del Secuenciador</a></div>
                <div class="linkAHEAD"><a href="MIDI-synth.html">Sintetizando Sonido</a></div>
                <div class="nolinkAHEAD">Introducción a los Interfaces de los Proveedores de Servicio</div>
                <div class="linkAHEAD"><a href="SPI-providing-sampled.html">Proporcionando Servicios de Audio Sampleado</a></div>
                <div class="linkAHEAD"><a href="SPI-providing-MIDI.html">Proporcionando Servicios MIDI</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Sonido
            </div>
            <div id="BreadCrumbs">
                <a href="../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="./index.html" target="_top">Sonido</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="MIDI-synth.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="./TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="SPI-providing-sampled.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Introducción a los Interfaces de los Proveedores de Servicio</h1>
            </div>
            <div id="PageContent">
                <h2>
                    <a id="what"></a>¿Qué Son los Servicios?
                </h2>
                <p>
                    Los servicios son unidades de funcionalidad de manejo de sonido que están disponibles automáticamente cuando un 
                    programa de aplicación hace uso de una implmentación de la IPA de Sonido de Java. Consisten de objetos que 
                    hacen el trabajo de leer, escribir, mezclar, procesar, y convertir audio y datos MIDI. Una implementación de la 
                    IPA de Sonido de Java generalmente suple un conjunto básico de servicios, pero los mecanismos están también 
                    incluídos en la IPA para admitir el desarrollo de nuevos servicios por desarrolladores de terceras partes (o 
                    por el fabricante de la misma implementación). Estos nuevos servicios se pueden "conectar" a una implementación 
                    instalada existente para expandir su funcionalidad sin requerir una nueva versión. En la arquitectura de la IPA 
                    de Sonido de Java, los servicios de terceras partes se integran en el sistema de tal forma que la interfaz de 
                    un programa de aplicación con ellos es la misma que la interfaz a servicios "integrados". En algunos casos, los 
                    desarrolladores de aplicaciones que usan los paquetes <code>javax.sound.sampled</code> y 
                    <code>javax.sound.midi</code> es posible que ni siquiera sepan que están empleando servicios de terceros.
                </p>
                <p>
                    Algunos ejemplos de posibles servicios de audio muestreado de terceros incluyen:
                </p>
                <ul>
                    <li>Lectores y escritores de archivos de sonido</li>
                    <li>Convertidores que traducen entre diferentes formatos de datos de audio</li>
                    <li>
                        Nuevos mezcladores de audio y dispositivos de entrada/salida, ya estén implementados puramente por 
                        software, o en hardware con una interfaz de software
                    </li>
                </ul>
                <p>
                    Los servicios MIDI de terceros pueden consistir en:
                </p>
                <ul>
                    <li>Lectores y escritores de archivos MIDI</li>
                    <li>
                        Lectores para varios tipos de archivos de banco de sonidos (que son a menudo específicos de sintetizadores 
                        particulares)
                    </li>
                    <li>
                        Sintetizadores de sonido controlados por MIDI, secuenciadores, y puertos de E/S, ya estén implementandos 
                        puramente por software, o en hardware con una interfaz de software.
                    </li>
                </ul>
                <h2>
                    <a id="how"></a>Cómo Funcionan los Servicios
                </h2>
                <p>
                    Los paquetes <code>javax.sound.sampled</code> y <code>javax.sound.midi</code> proporcionan funcionalidad a los 
                    desarrolladores de aplicaciones que desean incluir servicios de sonido en sus programas de aplicación. Estos 
                    paquete son para los <em>consumidores</em> de servicios de sonido, proporcionando interfaces para obtener 
                    información, controlar, y acceder a los servicios de audio y MIDI. Además, la IPA de Sonido de Java también 
                    suministra dos paquetes que definen clases abstractas que son utilizadas por los <em>proveedores</em> de los 
                    servicios de sonido: los paquetes <code>javax.sound.sampled.spi</code> y <code>javax.sound.midi.spi</code>.
                </p>
                <p> 
                    Los desarrolladores de nuevos servicios de sonido implementan subclases concreto de las clases apropiadas en 
                    los paquetes SPI. Estas subclases, junto con las clases adicionales necesarias para admitir el nuevo servicio, 
                    se colocan en un archivo de archivo Java Archive (JAR) con una descripción del servicio o servicios incluídos. 
                    Cuando este archivo JAR se instala en el <code>CLASSPATH</code> del usuario, el sistema de tiempo de ejecución 
                    automáticamente hace el nuevo servicio disponible, extendiendo la funcionalidad del tiempo de ejecución del 
                    sitema de la plataforma Java.
                </p>
                <p>
                    Una vez se instala el nuevo servicio, puede ser accedido simplemente como cualquier servicio instalado 
                    previamente. Los consumidores de los servicios pueden obtener información sobre el nuevo servicio, u obtener 
                    instancias de la propia nueva clase de servicio, para invocar métodos de las clases <code>AudioSystem</code> y 
                    <code>MidiSystem</code>  (en los paquetes <code>javax.sound.sampled</code> y <code>javax.sound.midi</code>, 
                    respectivamente) para devolver información sobre los nuevos servicios, o para devolver instancias de las 
                    nuevas o existentes clases se servicio propias. Los programas de aplicación no necesitan &mdash; y no deben 
                    &mdash; hacer referencia a las clases en los paquetes SPI (y sus subclases) directamente para hacer uso de los 
                    servicios instalados.
                </p>
                <p>
                    Por ejemplo, suponga que un proveedor de servicios hipotetico llamado Acme Software, Inc. se interesa en 
                    suplir un paquete que permite los programas de aplicación para leer un nuevo formato de archivo de sonido (pero 
                    uno cuyos datos de audio están en un formato de datos estándar). La clase SPI <code>AudioFileReader</code> 
                    puede subclasificarse en una clase llamada, digamos, <code>AcmeAudioFileReader</code>. En la nueva subclase, 
                    Acme proporcionaría implementaciones de todos los métodos definidos en <code>AudioFileReader</code>; en este 
                    caso hay solo dos métodos (con variantes de argumentos), <code>getAudioFileFormat</code> y 
                    <code>getAudioInputStream</code>. Después cuando un programa de aplicación intenta leer un archivo de sonido 
                    que estaba en el formato de archivo de Acme, invocaba métodos de la clase <code>AudioSystem</code> en 
                    <code>javax.sound.sampled</code> para acceder el archivo e información sobre ella. Los métodos 
                    <code>AudioSystem.getAudioInputStream</code> y <code>AudioSystem.getAudioFileFormat</code> proporciona una IPA 
                    estándar para leer flujos de audio; con la clases instalada <code>AcmeAudioFileReader</code>, esta interfaz 
                    se extiende para admitir el nuevo tipo de archivo transparentemente. Los desarrolladores de aplicación no 
                    necesitan acceso directo a las nuevas clases SPI registradas: los métodos del objeto <code>AudioSystem</code> 
                    pasan la consulta sobre la clase <code>AcmeAudioFileReader</code> instalada.
                </p>
                <p>
                    ¿Cuál es el punto de tener estas clases de "fábrica"? ¿Por qué no permitir que el desarrollador de la 
                    aplicación acceda directamente a los servicios recién proporcionados? Ese es un enfoque posible, pero el hecho 
                    de que toda la gestión y la instanciación de servicios pase a través de los objetos del sistema de control de 
                    acceso protege al desarrollador de la aplicación de tener que saber algo sobre la identidad de los servicios 
                    instalados. Los desarrolladores de la aplicación simplemente usan servicios de de valor para ellos, quizás sin 
                    siquiera darse cuenta. Al mismo tiempo esta arquitectura permite a los proveedores de servicio a gestionar 
                    efectivamente los recursos disponibles en sus paquetes.
                </p>
                <p>
                    A menudo el uso de nuevos servicios de sonido es transparente al programa de aplicación. Por ejemplo imagine 
                    una situación donde un desarrollador de aplicación quiere leer en un flujo de audio desde un archivo. Asumiendo 
                    que <code>thePathName</code> identifica un archivo de entrada de audio, identifica un archivo de entrada de 
                    audio, el programa hace esto:
                </p>
                <div class="codeblock">
                    <pre>
    File theInFile = new File(thePathName);
    AudioInputStream theInStream = AudioSystem.getAudioInputStream(theInFile); 
                    </pre>
                </div>
                <p>
                    Entre bastiadores, el <code>AudioSystem</code> determina qué los servicios instalado pueden leer el archivo y 
                    pedirle que suministre los datos de audio como un objeto <code>AudioInputStream</code>. El desarrollador podría 
                    no saber o ni siquiera le importe que el archivo de audio de entrada esté en algún formato de archivo nuevo 
                    (como el de Acme), compatible con servicios de terceros instalados. EL primer contacto del programa con el 
                    flujo es a través del objeto <code>AudioSystem</code>, y todos su acceso posterior al flujo y sus propiedades 
                    son a través de los métodos de <code>AudioInputStream</code>. Ambos son objetos estándar en la IPA 
                    <code>javax.sound.sampled</code>; el manejo especial que puede requerir el nuevo formato de archivo está 
                    completamente oculto.
                </p>
                <h2>
                    <a id="how_providers"></a>Cómo los Proveedores Preparan Nuevos Servicios
                </h2>
                <p>
                    Los proveedores de servicio suminisgran sus nuevos servicios en archivos JAR formateados especialmente, que van 
                    a ser instalados en un directorio sobre el sistema de usuarios donde el tiempo de ejecución de Java los 
                    encontrará. Los archivos JAR son archivos de almacenamiento, cada uno de los cuales contiene conjuntos de 
                    archivos que pueden estar organizados en estructuras de directorios jeraárquicas dentro del archivo. Los 
                    detalles sobre la preparación de los archivos de clases que van dentro de estos archivos se describen en la las 
                    siguientes pocas páginas, que describen los detalles de los paquetes SPI de audio y MIDI; aquí solo daremos una 
                    descripción general del proceso de creación de archivos JAR.
                </p>
                <p>
                    El archivo JAR para un servicio nuevo o servicios debe contener un archivo de clase por cada servicio admitido 
                    en el archivo JAR. Siguiendo la convención de la plataforma Java, cada archivo class tiene el nombre de la 
                    nueva clases definida, que es una subclase concreta de una de las clases abstractas del proveedor de servicio. 
                    El archivo JAR también debe incluir cualquier clase de soporte requerida para la implementación del nuevo 
                    servicio. Para que el nuevo servicio o servicios puedan ser ubicados por el mecanismo del proveedor de servicios 
                    del sistema en tiempo de ejecución, el archivo JAR también debe contener archivos especiales (descritos a 
                    continuación) que mapeen los nombres de las clases SPI a las nuevas subclases que se están definiendo.
                </p>
                <p>
                    Para continuar con nuestro ejemplo anterior, digamos que Acme Software, Inc. está distribuyendo un paquete de 
                    nuevos servicios de audio muestreado. Supongamos que este paquete consta de dos nuevos servicios:
                </p>
                <ul>
                    <li>
                        La clase <code>AcmeAudioFileReader</code>, que fue mencionada antes, y que es una subclase de 
                        <code>AudioFileReader</code>
                    </li>
                    <li>
                        Una subclase de <code>AudioFileWriter</code> llamada <code>AcmeAudioFileWriter</code>, que escribirá 
                        archivos de sonido en el nuevo formato de Acme
                    </li>
                </ul>
                <p>
                    Partiendo de un directorio arbitrario &mdash; llamémoslo <code>/devel</code> &mdash; donde queremos hacer la 
                    compilación, creamos subdirectorios y colocamos los nuevos archivos de clase en ellos, organizados de tal manera 
                    que proporcione el nombre de ruta deseado por el cual se hará referencia a las nuevas clases:
                </p>
                <div class="codeblock">
                    <pre>
    com/acme/AcmeAudioFileReader.class
    com/acme/AcmeAudioFileWriter.class
                    </pre>
                </div>
                <p>
                    Además, para cada nueva clase SPI que se subclasifica, creamos un archivo de mapeo en un directorio con un 
                    nombre especial <code>META-INF/services</code>. El nombre del archivo es el nombre de la clase SPI que se 
                    subclasifica y el archivo contiene los nombres de las nuevas subclases de esa clase abstracta SPI.
                </p>
                <p>Creamos el archivo</p>
                <div class="codeblock">
                    <pre>
  META-INF/services/javax.sound.sampled.spi.AudioFileReader
                    </pre>
                </div>
                <p>
                    que consiste de 
                </p>
                <div class="codeblock">
                    <pre>
    # Proveedores de servicios de lectura de archivo de sonido 
    # (una línea de comaentario empieza con un signo de libra)
    com.acme.AcmeAudioFileReader
                    </pre>
                </div>
                <p>
                    y también el archivo
                </p>
                <div class="codeblock">
                    <pre>
  META-INF/services/javax.sound.sampled.spi.AudioFileWriter
                    </pre>
                </div>
                <p>
                    que consiste de 
                </p>
                <div class="codeblock">
                    <pre>
    # Proveedores de servicios de escritura de archivo de sonido 
    com.acme.AcmeAudioFileWriter
                    </pre>
                </div>
                <p>
                    Ahora ejecutamos <code>jar</code> desde cualquier directorio con la línea de comando:
                </p>
                <div class="codeblock">
                    <pre>
jar cvf acme.jar -C /devel .
                    </pre>
                </div>
                <p>
                    La opción <code>-C</code> causa que <code>jar</code> para cambiar al directorio <code>/devel</code>, en vez de 
                    usasr el directorio en el cual el comando se ejecuta. El argumento del punto final instruye a <code>jar</code> 
                    a archivar todo los contenidos de ese directorio (es decir, <code>/devel</code>), poero el directorio en sí 
                    mismo.
                </p>
                <p>
                    Esta ejecución creará el archivo <code>acme.jar</code> con los contenidos:
                </p>
                <div class="codeblock">
                    <pre>
com/acme/AcmeAudioFileReader.class
com/acme/AcmeAudioFileWriter.class
META-INF/services/javax.sound.sampled.spi.AudioFileReader
META-INF/services/javax.sound.sampled.spi.AudioFileWriter
META-INF/Manifest.mf
                    </pre>
                </div>
                <p>
                    El archivo <code>Manifest.mf,</code> que se genera por la propia utilidad <code>jar</code>, es una lista de 
                    todos los archivos contenidos en el archivo.
                </p>
                <h2>
                    <a id="how_users"></a>Cómo los Usuarios Instalan Nuevos Servicios
                </h2>
                <p>
                    Para los usuarios finales (o administradores del sistema) que desean obtener acceso a un nuevo servicio a 
                    través de sus programas de aplicación, la instalación es simple. Colocan el archivo JAR proporcionado en un 
                    directorio en su <code>CLASSPATH.</code> Tras la ejecución, el tiempo de ejecución de Java encontrará las clases 
                    referenciadas cuando sea necesario.
                </p>
                <p>
                    No es un error instalar más de un proveedor para el mismo servicio. Por ejemplo, dos proveedores de servicio 
                    diferentes pueden suministrar soporte para leer el mismo tipo de archivo de sonido. En tal caso, el sistema 
                    arbitrariamente elije uno de los proveedores. Los usuarios que se preocupan por el proveedor elegido deben 
                    instalar solo el deseado.
                </p>
                <p>&nbsp;</p>
            </div>
            <div class="NavBit">
                <a target="_top" href="MIDI-synth.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="./TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="SPI-providing-sampled.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            "Los Tutoriales de Java" está sujeto a estos <a href="../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Sintetizando Sonido<br />
            <b>Página siguiente:</b> Proporcionando Servicios de Audio Sampleado
        </div>
    </body>
</html> 
