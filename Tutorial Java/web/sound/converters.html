<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Usando Ficheros y Convertidores de Formato (Los Tutoriales de Java&trade; &gt; Sonido)
        </title>
        <meta name="description" content="" />
        <meta name="keywords" content="java programming, learn java, java sample code, " />
        <link rel="stylesheet" href="../indice.css" type="text/css"/>
        <script src="../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkAHEAD"><a href="sampled-overview.html">Descripción del Paquete Sampled</a></div>
                <div class="linkAHEAD"><a href="accessing.html">Accediendo a los Recursos del Sistema de Audio</a></div>
                <div class="linkAHEAD"><a href="playing.html">Reproducción de Audio</a></div>
                <div class="linkAHEAD"><a href="capturing.html">Grabando Audio</a></div>
                <div class="linkAHEAD"><a href="controls.html">Procesando Audio con Controles</a></div>
                <div class="nolinkAHEAD">Usando Ficheros y Convertidores de Formato</div>
                <div class="linkAHEAD"><a href="overview-MIDI.html">Descripción del Paquete MIDI</a></div>
                <div class="linkAHEAD"><a href="accessing-MIDI.html">Accediendo a los Recursos del Sistema MIDI</a></div>
                <div class="linkAHEAD"><a href="MIDI-messages.html">Transmitiendo y Recibiendo Mensajes MIDI</a></div>
                <div class="linkAHEAD"><a href="MIDI-seq-intro.html">Introducción a los Secuenciadores</a></div>
                <div class="linkAHEAD"><a href="MIDI-seq-methods.html">Utilizando Métodos del Secuenciador</a></div>
                <div class="linkAHEAD"><a href="MIDI-seq-adv.html">Usando Características Avanzadas del Secuenciador</a></div>
                <div class="linkAHEAD"><a href="MIDI-synth.html">Sintetizando Sonido</a></div>
                <div class="linkAHEAD"><a href="SPI-intro.html">Introducción a los Interfaces de los Proveedores de Servicio</a></div>
                <div class="linkAHEAD"><a href="SPI-providing-sampled.html">Proporcionando Servicios de Audio Sampleado</a></div>
                <div class="linkAHEAD"><a href="SPI-providing-MIDI.html">Proporcionando Servicios MIDI</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Sonido
            </div>
            <div id="BreadCrumbs">
                <a href="../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="./index.html" target="_top">Sonido</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="controls.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="./TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="overview-MIDI.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Usando Ficheros y Convertidores de Formato</h1>
            </div>
            <div id="PageContent">
                <p>
                    La mayoría de los programas de aplicación que tratan con sonido necesitan leer los archivos de sonido o flujos 
                    de audio. Esta es una funcionalidad común, independientemente de lo que el programa pueda hacer posteriormente 
                    con los datos que lee (como reproducirlos, mezclarlos o procesarlos). De forma similar, muchos programas 
                    necesitan escribir archivos de sonido (o flujos). En algunos casos, los datos que han sido léidos (o que serán 
                    escritos) necesitan ser convertidos a un formato diferente.
                </p>
                <p>
                    Como fue mencionado brevemente en 
                    <a class="TutorialLink" target="_top" href="accessing.html">Accediendo a los Recursos del Sistema de Audio</a>, 
                    la IPA de Sonido de Java proporciona a los desarrolladores de aplicación con varias facilidades para la 
                    entrada/salida de archivos y traducciones de formato. Los programas de aplicación pueden leer, escribir, y 
                    traducir entre una variedad de formatos de archivos de sonido y formatos de datos de audio.
                </p>
                <p>
                    <a class="TutorialLink" target="_top" href="sampled-overview.html">Descripción del Paquete Sampled</a> 
                    introdujo las clases principales relacionadas con los archivos de sonido y formatos de datos de audio. Como 
                    reseña:
                </p>
                <ul>
                    <li>
                        Un flujo de datos de audio, como podría ser leído o escrito a un archivo, se representa por un objeto 
                        <code>AudioInputStream</code>. (<code>AudioInputStream</code> hereda de <code>java.io.InputStream</code>.)
                    </li>
                    <li>
                        El formato de estos datos de audio se representa por un objeto <code>AudioFormat</code>.
                        <p>
                            Este formato especifica como se organizan los mismos muestreos de audio, pero no la estructura de un 
                            archivo en el que podrían almacenarse. En otras palabras, un <code>AudioFormat</code> describe los 
                            datos de audio &quot;sin procesar&quot;, como el sistema podría entregar a su programa después de 
                            capturarlo desde una entrada de micrófono o después de analizarlo desde un archivo de sonido. Un 
                            <code>AudioFormat</code> incluye tal información como la codificación, el orden de los bytes, el número 
                            de canales, la frecuencia de muestreo, y el número de bytes por muestreo.
                        </p>
                    </li>
                    <li>
                        Hay varios formatos estándar bien conocidos para los archivos de sonido, tales como WAV, AIFF, o AU. Los 
                        diferentes tipos de archivos de sonido tienen diferentes estructuras para almacenar los datos de audio como 
                        también para almacenar información descriptiva sobre los datos de audio. Un formato de archivo de sonido 
                        se representa en la IPA de Sonido de Java por un objeto <code>AudioFileFormat</code>. El objeto 
                        <code>AudioFileFormat</code> incluye un objeto <code>AudioFormat</code> para describir el formato de los 
                        datos de audio almacenados en el archivo, y también incluye información sobre el tipo de archivo y la 
                        longitud de los datos en el archivo.
                    </li>
                    <li>
                        La clase <code>AudioSystem</code> proporciona métodos para (1) almacenar un flujo de datos de audio desde 
                        un <code>AudioInputStream</code> en un archivo de audio de un tipo particular (en otras palabras, escribir 
                        un archivo), (2) extraer un flujo de bytes de audio (un <code>AudioInputStream</code>) de un archivo de 
                        audio (en otras palabras, leer un archivo), y (3) convertir datos de audio de un formato de datos a otro. 
                        Esta página, la cual se divide en tres secciones, explica estas tres clases de actividad.
                    </li>
                </ul>
                <p></p>
                <div class="note">
                    <hr />
                    <strong>Nota:</strong>&nbsp;
                    <p>
                        una implementación de una IPA de Sonido de Java no necesariamente proporciona instalaciones completas para 
                        leer, escribir, y convertir audio en diferentes datos y formatos de archivo. Podría soportar solo los datos 
                        y formatos de archivos comunes. Sin embargo, los proveedores de servicio pueden desarrollar y distribuir 
                        servicios de conversión que extienden este conjunto, como verá más tarde en 
                        <a href="SPI-providing-sampled.html">Proporcionando Servicios de Audio Sampleado</a>. La clase 
                        <code>AudioSystem</code> suministra métodos que permiten a los programas de aplicación a aprender qué 
                        conversiones están disponibles, como se describe más tarde bajo 
                        <a href="#114640">Convertir Archivos y Formatos de Datos</a>.
                    </p>
                    <hr />
                </div>
                <h2>
                    Leer Ficheros de Sonido
                </h2>
                <p>
                    La clase <code>AudioSystem</code> proporciona dos tipos de servicios de lectura de archivos:
                </p>
                <ul>
                    <li>Información sobre el formato de los datos de audio almacenados en el archivo de sonido</li>
                    <li>Un flujo de datos de audio formateados que pueden ser leídos de un archivo de sonido</li>
                </ul>
                <p>
                    El primero de estos es dado por tres variantes del método <code>getAudioFileFormat</code>:
                </p>
                <div class="codeblock">
                    <pre>
    static AudioFileFormat getAudioFileFormat (java.io.File file)
    static AudioFileFormat getAudioFileFormat(java.io.InputStream stream)
    static AudioFileFormat getAudioFileFormat (java.net.URL url)
                    </pre>
                </div>
                <p>
                    Como se mención arriba, el objeto <code>AudioFileFormat</code> devuelto le indica el tipo de archivo, la 
                    longitud de los datos en el archivo, la codificación, el orden de bytes, el número de canales, la frecuencia de 
                    muestreo, y el número de bits por muestra.
                </p>
                <p>
                    El segundo tipo de funcionalidad de lectura de archivos es ofrecido por esto métodos <code>AudioSystem</code>
                </p>
                <div class="codeblock">
                    <pre>
    static AudioInputStream getAudioInputStream (java.io.File file)
    static AudioInputStream getAudioInputStream (java.net.URL url)
    static AudioInputStream getAudioInputStream (java.io.InputStream stream)
                    </pre>
                </div>
                <p>
                    Estos métodos le dan un objeto (un <code>AudioInputStream</code>) que le permite leer los datos de audio del 
                    archivo, usando uno de los métodos read de <code>AudioInputStream</code>. Veremos un ejemplo momentáneamente.
                </p>
                <p>
                    Suponga que está escribiendo una aplicación de edición de sonido que permite al usuario cargar datos de sonido 
                    de un archivo, visualizar la forma de onda o espectrograma correspondiente, editar el sonido, reproducir los 
                    datos editados, y salvar el resultado en un nuevo archivo. O quizás su programa leerá los datos almacenados 
                    en un archivo, aplica alguna clases de procesado de señal (como un algoritmo que relentiza el sonido sin 
                    cambiar su tono), y después reproduce el audio procesado. En cualquier caso, necesita obtener acceso a los 
                    datos contenidos en el archivo de audio. Asumiendo que su programa proporciona algunas forma de que el usuario 
                    seleccione o especifique un archivo de sonido de entrada, leer esos datos de audio del archivo implica tres 
                    pasos:
                </p>
                <ol>
                    <li>Obtener un objeto <code>AudioInputStream</code> del archivo.</li>
                    <li>Crear una matriz de byts en la cual almacenará sucesivos fragmentos de datos del archivo.</li>
                    <li>
                        Repetidamente lee bytes del flujo de audio de entrada a la matriz. En cada iteracción, hace algo útil con 
                        los bytes en la matriz (por ejemplo, puede reproducirlos, filtrarlos, analizarlos, visualizarls, o 
                        escribirlos a otro archivo).
                    </li>
                </ol>
                <p>
                    El siguiente trozo de código describe estos pasos:
                </p>
                <div class="codeblock">
                    <pre>
int totalFramesRead = 0;
File fileIn = new File(somePathName);
// somePathName es una cadena ya existente cuyo valor fue 
// basada en una selección del usuario.
try {
  AudioInputStream audioInputStream = 
    AudioSystem.getAudioInputStream(fileIn);
  int bytesPerFrame = 
    audioInputStream.getFormat().getFrameSize();
    if (bytesPerFrame == AudioSystem.NOT_SPECIFIED) {
    // algunos formatos de audio pueden tener un tamaño de cuadro no especificado
    // en ese caso podemos leer cualquier cantidad de bytes
    bytesPerFrame = 1;
  } 
  // Establece un búfer arbitrario de 1024 cuadros.
  int numBytes = 1024 * bytesPerFrame; 
  byte[] audioBytes = new byte[numBytes];
  try {
    int numBytesRead = 0;
    int numFramesRead = 0;
    // Intenta leer numBytes bytes del archivo.
    while ((numBytesRead = 
      audioInputStream.read(audioBytes)) != -1) {
      // Calcula el número de cuadros realmente léidos.
      numFramesRead = numBytesRead / bytesPerFrame;
      totalFramesRead += numFramesRead;
      // Aquí, hacemos algo útil con los datos de audio que están 
      // ahora en la matriz audioBytes...
    }
  } catch (Exception ex) { 
    // Maneja el error...
  }
} catch (Exception e) {
  // Maneja el error...
}
                    </pre>
                </div>
                <p>
                    Echemos un vistazo a qué está ocurriendo en el ejemplo de código de arriba. Primero, la cláusula externa try 
                    instancia un objeto <code>AudioInputStream</code> a través de la llamada al método 
                    <code>AudioSystem.getAudioInputStream(File)</code>. Este método transparentemente realiza todas las pruebas 
                    requeridad para determinar si el archivo especificado es en realidad un archivo de sonido de un tipo que es 
                    admitido por la IPA de Sonido de Java. Si el archivo que está siendo inspeccionando (<code>fileIn</code> en este 
                    ejemplo) no es un archivo de sonido, o es un archivo de sonido de algún tipo no soportado, se lanza una 
                    excepción <code>UnsupportedAudioFileException</code>. Este comportamiento es conveniente, ya que el programador 
                    de la aplicación no necesita preocuparse con la comprobación de los atributos del archivo, ni adherirse a 
                    ninguna de las convenciones de nomenclatura de archivos. En su lugar, el método <code>getAudioInputStream</code>
                    se cuida de todo el análisis y verificación de bajo nivel que se requiere para validar el fichero de entrada.
                    La cláusula <code>try</code> más externa después crea una matriz de bytes, <code>audioBytes</code>,  de una 
                    longitud fija arbitraria. Nos aseguramos de que su longitud en bytes es igual a un número integral de cuadros, 
                    de forma que no terminaremos leyendo solo parte de un cuadro o, incluso pero, solo parte de un muestreo. Esta 
                    matriz de bytes servirá como un búfer para mantener temporalmente un trozo de datos d eaudio como se leen desde 
                    el flujo. Si supiéramos que no estaríamos leyendo más que archivos de sonido muy breves, podríamos hacer esta 
                    matriz de la misma longitud que los datos en el archivo, derivando la longitud en bytes de la longitud en 
                    cuadros, como se devuelve por el método <code>getFrameLength</code> de <code>AudioInputStream</code>. (En 
                    realidad, probablemente simplemente usaríamos un objeto <code>Clip</code> en su lugar). Pero para evitar 
                    quedarse sin memoria en el caso general, en su lugar leemos el archivo en fragmentos, un búfer a la vez.
                </p>
                <p>
                    La cláusula <code>try</code> más interna contiene un bucle <code>while</code>, en el cual leemos los datos 
                    de audio desde el <code>AudioInputStream</code> a la matriz de bytes. Debe agregar código en este bucle para 
                    manejar los datos de audio en esta matriz en cualquier forma que sea apropiada para las necesidades de su 
                    programa. Si está aplicando alguna clase de procesado de señal a los datos, probablemente necesitará consultar 
                    más adelante <code>AudioFormat</code> del <code>AudioInputStream</code>, para aprender el número de bits por 
                    muestreo y así.
                </p>
                <p>
                    Tenga en cuenta que el método <code>AudioInputStream.read(byte[])</code> devuelve el número de <em>bytes</em> 
                    leídos &mdash; no el número de muestreos o cuadros. Este método devuelve -1 donde no hay más datos para leer. 
                    Después de detectar esta condición, salimos del bucle <code>while</code>.
                </p>
                <p></p>
                <h2>
                    Escribir Ficheros de Sonido
                </h2>
                <p>
                    La sección previa describió los conceptos básicos de la lectura de un archivo de sonido, usando métodos 
                    específicos de las clases <code>AudioSystem</code> y <code>AudioInputStream</code>. Esta sección describe 
                    cómo escribir datos de audio a un nuevo archivo.
                </p>
                <p>
                    El método siguiente de <code>AudioSystem</code> crea un archivo de disco del tipo de archivo especificado. El 
                    archivo contendrá los datos de audio que están en el <code>AudioInputStream</code> especificado:
                </p>
                <div class="codeblock">
                    <pre>
static int write(AudioInputStream in, 
  AudioFileFormat.Type fileType, File out)
                    </pre>
                </div>
                <p>
                    Tenga en cuenta que el argumento segundo debe ser uno de los tipos de archivos admitidos por el sistema (por 
                    ejemplo, AU, AIFF, o WAV), de otra forma el método <code>write</code> lanzará una 
                    <code>IllegalArgumentException</code>. Para evitar esto, puede comprobar si puede ser escrito o no un 
                    <code>AudioInputStream</code> particular a un tipo particular de archivo, invocando este método 
                    <code>AudioSystem</code>:
                </p>
                <div class="codeblock">
                    <pre>
static boolean isFileTypeSupported
  (AudioFileFormat.Type fileType, AudioInputStream stream)
                    </pre>
                </div>
                <p>
                    el cual devolverá <code>true</code> solo si la combinación particular se soporta.
                </p>
                <p>
                    Más generalmente, puede aprender qué tipos de archivo el sistema puede escribir invocando uno de estos 
                    métodos <code>AudioSystem</code>:
                </p>
                <div class="codeblock">
                    <pre>
static AudioFileFormat.Type[] getAudioFileTypes() 
static AudioFileFormat.Type[] getAudioFileTypes(AudioInputStream stream) 
                    </pre>
                </div>
                <p>
                    El primero de estos devuelven todos los tipos de archivo que el sistema puede escribir, y el segundo devuelve 
                    solo aquellos que el sistema puede escribir desde el flujo de entrada de audio dado.
                </p>
                <p>
                    El siguiente extracto demuestra una técnica para crear un archivo de salida a partir de un 
                    <code>AudioInputStream</code> usando el método <code>write</code> mencionado anteriormente.
                </p>
                <div class="codeblock">
                    <pre>
File fileOut = new File(someNewPathName);
AudioFileFormat.Type fileType = fileFormat.getType();
if (AudioSystem.isFileTypeSupported(fileType, 
    audioInputStream)) {
  AudioSystem.write(audioInputStream, fileType, fileOut);
}
                    </pre>
                </div>
                <p>
                    La primera sentencia de arriba, crea un objeto nuevo <code>File</code>, <code>fileOut</code>, con un usuario - 
                    o una ruta especificada por programa. La sentencia segunda obtiene un tipo de archivo desde un objeto 
                    preexistente <code>AudioFileFormat</code> llamado <code>fileFormat</code>, el cual podría haber sido obtenido 
                    desde otro archivo de sonido, tal como el que fue leído en <a href="#114527">Leer Archivos de Sonido</a> arriba. 
                    (Podría en su lugar, proporcionar cualquier tipo de archivo compatible que desee, en vez de obtener el tipo de 
                    archivo de cualquier otra parte. Por ejemplo, podría eliminar la sentencia segunda y reemplazar las otras 
                    dos ocurrencias de <code>fileType</code> en el código de arriba con <code>AudioFileFormat.Type.WAVE</code>).
                </p>
                <p>
                    La sentencia tercera comprueba si un archivo del tipo designado pudo ser descrito desde un deseado 
                    <code>AudioInputStream</code>. Como el formato de archivo, este flujo podría haver sido derivdo desde el 
                    archivo de sonido previamente leído. (Si es así, presumiblemente ha procesado o alterado sus datos de alguna 
                    forma, porque de lo contrario hay formas más fáciles de simplemente copiar un archivo). O quizás el flujo 
                    contiene bytes que han sido capturados recientemente desde la entrada del micrófono.
                </p>
                <p>
                    Finalmente, el flujo, el tipo de archivo, y el archivo de salida se pasó al método 
                    <code>AudioSystem</code>.<code>write</code>, para cumplir el objetivo de escribir el archivo.
                </p>
                <p></p>
                <h2>
                    Convertir Formatos de Ficheros y Datos
                </h2>
                <p>
                    Recuerde de 
                    <a class="TutorialLink" target="_top" href="sampled-overview.html#formatted">¿Qué son los datos de audio 
                        formateados?</a>, que la IPA de Sonido de Java distingue entre los formatos de <em>archivo</em> de audio y 
                    los formatos de <em>datos</em> de audio. Los dos son más o menos independientes. En términos generales, el 
                    formato de datos se refiere a la forma en que la computadora representa cada punto de datos sin procesar 
                    (muestra), mientras que el formato de archivo se refiere a la organización de un archivo de sonido de como 
                    se almacenó en un disco. Cada formato de archivo de sonido tiene una estructura particular que define, por 
                    ejemplo, la información almacenada en la cabecera del archivo. En algunos casos, el formato de archivo 
                    también incluye estructuras que contienen alguna forma de metadatos, además de las muestras de audio 
                    &quot;sin procesar&quot; reales. El resto de esta página examina los métodos de la IPA de Sonido de Java 
                    que permiten una variedad de conversiones de formato de archivo y formato de datos.
                </p>
                <p></p>
                <h2>
                    Convertir de Un Formato de Fichero a Otro
                </h2>
                <p>
                    Esta sección cubre los fundamentos de la conversión de tipos de archivos de audio en la IPA de Sonido de Java. 
                    Una vez más planteamos un programa hipotético cuyo propósito, esta vez, es leer los datos de aduio desde un 
                    archivo de entrada arbitrario y los escribe en un archivo cuyo tipo es AIFF. Por supuesto, el archivo de entrada 
                    debe ser de un tipo que el sistema sea capaz de leer, y el archivo de salida debe ser de un tipo que el sistema 
                    es capaz de escribir. (En este ejemplo, asumimos que el sistema es capa de escribir archivos AIFF). El programa 
                    de ejemplo no hace ninguna conversión del formato de los datos. Si el formato de los datos del archivo de 
                    entrada no pueden ser representados como un archivo AIFF, el programa simplemente notifica al usuario del 
                    problema. Por el otro lado, si el archivo de sonido de entrada es ya un archivo AIFF, el programa notifica al 
                    usuario que no hay necesidad de convertirlo.
                </p>
                <p>
                    La función siguiente implementa la lógica que se acaba de describir:
                </p>
                <div class="codeblock">
                    <pre>
public void ConvertFileToAIFF(String inputPath, 
  String outputPath) {
  AudioFileFormat inFileFormat;
  File inFile;
  File outFile;
  try {
    inFile = new File(inputPath);
    outFile = new File(outputPath);     
  } catch (NullPointerException ex) {
    System.out.println("Error: ¡uno de los 
      ConvertFileToAIFF" +" parámetros son nulos!");
    return;
  }
  try {
    // consulta el tipo de archivo
    inFileFormat = AudioSystem.getAudioFileFormat(inFile);
    if (inFileFormat.getType() != AudioFileFormat.Type.AIFF) 
    {
      // inFile no es AIFF, así que intentamos convertirlo.
      AudioInputStream inFileAIS = 
        AudioSystem.getAudioInputStream(inFile);
      inFileAIS.reset(); // rebobina
      if (AudioSystem.isFileTypeSupported(
             AudioFileFormat.Type.AIFF, inFileAIS)) {
         // inFileAIS puede ser convertido a AIFF. 
         // así que escribe el AudioInputStream al 
         // archivo de salida.
         AudioSystem.write(inFileAIS,
           AudioFileFormat.Type.AIFF, outFile);
         System.out.println("Archivo AIFF creado con éxito, "
           + outFile.getPath() + ", desde el archivo "
           + inFileFormat.getType() + ", "
           inFile.getPath() + ".");
         inFileAIS.close();
         return; // Todo hecho ahora
       } else
         System.out.println("Aviso: La conversión de AIFF " 
           + inFile.getPath()
           + " actualmente no es compatible con AudioSystem.");
    } else
      System.out.println("Input file " + inFile.getPath() +
          " is AIFF." + " La conversión no es necesaria.");
  } catch (UnsupportedAudioFileException e) {
    System.out.println("Error: ¡" + inFile.getPath()
        + " no es un tipo de archivo soportado!");
    return;
  } catch (IOException e) {
    System.out.println("Error: ¡fallo al intentar leer " 
      + inFile.getPath() + "!");
    return;
  }
}
                    </pre>
                </div>
                <p>
                    Como se mencionó, el propósito de esta función de ejemplo, <code>ConvertFileToAIFF</code>, es preguntar un 
                    archivo de entrada para determinar si es un archivo de sonido AIFF, y si no lo es, tratar de convertirlo en 
                    uno, produciendo una nueva copia cuya ruta se especifica por el segundo argumento. (Como un ejercicio, podría 
                    intentar hacer esta función más general, de forma que en lugar de convertir siempre a AIFF, la función 
                    convierta al tipo de archivo especificado por un nuevo argumento de función). Tenga en cuenta que el formato 
                    de los datos del audio de la copia &mdash; es decir, el nuevo archivo imita el formato de datos de audio del 
                    archivo de entrada original.
                </p>
                <p>
                    La mayor parte de esta función se explica por sí misma y no es específica de la IPA de Sonido Java. Hay, sin 
                    embargo, unos pocos métoso de la IPA de Sonido de Java usados por la rutina que son cruciales para las 
                    conversiones de tipo de archivo de sonido. Estas invocaciones de métodos se encuentran todos en la segunda 
                    cláusula <code>try</code>, arriba, e incluye lo siguiente:
                </p>
                <ul>
                    <li>
                        <code>AudioSystem.getAudioFileFormat</code>: usado aquí para determinar si el archivo de entrada es ya un 
                        tipo AIFF. Si es así, la función rápidamente retorna; de lo contrario, prosigue el intento de conversión.
                    </li>
                    <li>
                        <code>AudioSystem.isFileTypeSupported</code>: Indica si el sistema puede escribir un archivo del tipo 
                        especificado que contiene datos de audio desde el <code>AudioInputStream</code> especificado. En nuestro 
                        ejemplo, este método devuelve <code>true</code> si el archivo de audio de entrada puede ser convertido a un 
                        archivo de audio de formato AIFF. Si <code>AudioFileFormat.Type.AIFF</code> no se admite, 
                        <code>ConvertFileToAIFF</code> emite una advertencia de que el archivo de entrada no puede ser convertido, 
                        después retorna.
                    </li>
                    <li>
                        <code>AudioSystem.write</code>: usado aquí para escribr los datos de audio desde el AudioInputStream 
                        <code>inFileAIS</code> al archivo de salida <code>outFile</code>.
                    </li>
                </ul>
                <p>
                    El segundo de estos métodos, <code>isFileTypeSupported</code>, ayuda a determinar, antes de la escritura, si un 
                    archivo de sonido de entrada particular puede ser convertido a un tipo de archivo de sonido de salida 
                    particular. En la siguiente sección veremos cómo, con unas pocas modificaciones a esta rutina de ejemplo 
                    <code>ConvertFileToAIFF</code>, podemos convertir el formato de datos de audio, como también el tipo de archivo 
                    de sonido.
                </p>
                <p></p>
                <h2>
                    Convertir Audio entre Diferentes Formatos de Datos
                </h2>
                <p>
                    La sección previa mostrada como ussar la IPA de Sonido de Java para convertir un archivo desde un formato de 
                    <em>archivo</em> (es decir, un tipo de archivo de sonido) a otra. Esta sección explora alguno de los métodos 
                    que habilitan las conversiones del formato de <em>datos</em> de audio.
                </p>
                <p>
                    En la sección previa, leemos los datos desde un archivo de un tipo arbitrario, y lo salvamos en un archivo AIFF.
                    Tenga en cuenta que aunque cambiamos el tipo de archivo usado para almacenar los datos, no cambiamos el formato 
                    de los datos de audio en sí mismos. (La mayoría de los tipos de archivos de audio, incluyendo AIFF, pueden 
                    contener datos de audio de varios formatos). Así que si el archivo original contenía datos de audio de calidad 
                    CD (tamaño de muestra de 16 bits, frecuencia de muestreo 44.1-KHz, y dos canales), también lo haría nuestro 
                    archivo AIFF de salida.
                </p>
                <p>
                    Ahora suponga que queremos especificar el formato de los <em>datos</em> del archivo de salida, como también el 
                    tipo de archivo. Por ejemplo, quizás estamos salvando muchos archivos largoos para usar en Internet, y estamos
                    preocupados sobre la cantidad de espacio en disco y tiempo de descarga requerido para nuestros archivos. 
                    Podríamos elegir crear archivos AIFF más pequeños que contengan datos de menor resolución, por ejemplo, datos 
                    que tengan un tamaño de muestra de 8 bits, una frecuencia de muestreo de 8-kHz, y un único canal.
                </p>
                <p>
                    Sin entrar en tantos detalles de codificación como antes, exploremos algunos de estos métodos utilizados para 
                    la conversión del formato de datos, y considerar las modificaciones que necesitaríamos hacer a la función 
                    <code>ConvertFileToAIFF</code> para cumplir el nuevo objetivo.
                </p>
                <p>
                    El método principal para la conversión de datos de audio, una vez más, se encuentra en la clase 
                    <code>AudioSystem</code>. Este método es una variante de <code>getAudioInputStream</code>:
                </p>
                <div class="codeblock">
                    <pre>
AudioInputStream getAudioInputStream(AudioFormat
    format, AudioInputStream stream)
                    </pre>
                </div>
                <p>
                    Esta función devuelve un <code>AudioInputStream</code> que es el resultado de convertir el 
                    <code>AudioInputStream</code>, <code>stream</code>, usando el <code>AudioFormat</code>, <code>format</code>. Si 
                    la conversión no es admitida por <code>AudioSystem</code>, esta función lanza una 
                    <code>IllegalArgumentException</code>.
                </p>
                <p>
                    Para evitar esto, podemos primero comprobar si el sistema puede realizar la conversión requerida invocando este 
                    método de <code>AudioSystem</code>:
                </p>
                <div class="codeblock">
                    <pre>
boolean isConversionSupported(AudioFormat targetFormat,
    AudioFormat sourceFormat)
                    </pre>
                </div>
                <p>
                    En este caso, pasaríamos <code>stream.getFormat()</code> como el segundo argumento.
                </p>
                <p>
                    Para crear un objeto <code>AudioFormat</code> específico, usamos uno de los dos constructores de 
                    <code>AudioFormat</code> mostrados abajo:
                </p>
                <div class="codeblock">
                    <pre>
AudioFormat(float sampleRate, int sampleSizeInBits,
    int channels, boolean signed, boolean bigEndian)
                    </pre>
                </div>
                <p>
                    que construye un <code>AudioFormat</code> con una codificación lineal PCM encoding y los parámetros dados, o:
                </p>
                <div class="codeblock">
                    <pre>
AudioFormat(AudioFormat.Encoding encoding, 
    float sampleRate, int sampleSizeInBits, int channels,
    int frameSize, float frameRate, boolean bigEndian) 
                    </pre>
                </div>
                <p>
                    que también construye un <code>AudioFormat</code>, pero le permite especificar la codificación, el tamaño del 
                    cuadro, y la velocidad del cuadro, además de los otros parámetros.
                </p>
                <p>
                    Ahora, armados con los métodos de arriba, veamos cómo podríamos extender nuestra función 
                    <code>ConvertFileToAIFF</code> para realizar la conversión de formato deseada de &quot;baja resolución&quot; 
                    de audio. Primero, construiríamos un objeto <code>AudioFormat</code> describiendo la salida deseada de los 
                    formatos de datos de audio. La siguiente declaración sería suficiente y podría insertarse cerca de la parte 
                    superior de la función:
                </p>
                <div class="codeblock">
                    <pre>
AudioFormat outDataFormat = new AudioFormat((float) 8000.0,
(int) 8, (int) 1, true, false);
                    </pre>
                </div>
                <p>
                    Ya que el constructor de <code>AudioFormat</code> de arriba está describiendo un formato con muestras de 8 bits, 
                    el último parámetro al constructor, que especifica si las muestras son big o little endian, es irrelevante. 
                    (Big versus little endian solo es un problema si el tamaño de la muestra es mayor que un solo byte).
                </p>
                <p>
                    El ejemplo siguiente muestra como usaríamos este nuevo <code>AudioFormat</code> para convertir el 
                    <code>AudioInputStream</code>, <code>inFileAIS</code>, que creamos desde el archivo de entrada:
                </p>
                <div class="codeblock">
                    <pre>
AudioInputStream lowResAIS;         
  if (AudioSystem.isConversionSupported(outDataFormat,   
    inFileAIS.getFormat())) {
    lowResAIS = AudioSystem.getAudioInputStream
      (outDataFormat, inFileAIS);
  }
                    </pre>
                </div>
                <p>
                    No importaría demasiado dónde insertamos este código, siempre que fuera después de la construcción de 
                    <code>inFileAIS</code>. Sin la prueba de <code>isConversionSupported</code>, la llamada fallaría y lanzaría una 
                    <code>IllegalArgumentException</code> si la particular conversión que se ha solicitado no fuera admitida. (En 
                    este caso, el control se transferiría a la cláusula apropiada <code>catch</code> en nuestra función).
                </p>
                <p>
                    Entonces, en este punto del proceso, habríamos producido un nuevo <code>AudioInputStream</code>, resultante de 
                    la conversión del archivo de entrada original (en su forma <code>AudioInputStream</code>) al formato de datos 
                    deseado de baja resolución como se definió en <code>outDataFormat</code>.
                </p>
                <p>
                    El paso final para producir el archivo de sonido AIFF deseado de baja resolución, sería reemplazar el parámetro 
                    <code>AudioInputStream</code> en la llamada a <code>AudioSystem.write</code> (es decir, el primer parámetro) 
                    con nuestro flujo convertido, <code>lowResAIS</code>, como sigue:
                </p>
                <div class="codeblock">
                    <pre>
AudioSystem.write(lowResAIS, AudioFileFormat.Type.AIFF, 
  outFile);
                    </pre>
                </div>
                <p>
                    Estas pocas modificaciones para nuestra función anterior produce algo que convierte tantos los datos de audio 
                    y el formato de archivo de cualquier archivo de entrada, asumiendo por supuesto que el sistema soporta la 
                    conversión.
                </p>
                <h2>
                    Aprender Qué Conversiones Están Disponibles
                </h2>
                <p>
                    Varios métodos <code>AudioSystem</code> comprueban sus parámetros para determinar si el sistema admite una 
                    conversión de formato de datos en particular o una operación de escritura de archivos. (Típicamente, cada 
                    metodo se empareja con otro que realiza la conversión de datos o escribe el archivo). Uno de estos métodos de 
                    consulta, <code>AudioSystem.isFileTypeSupported</code>, fue usado en nuestra función de ejemplo, 
                    <code>ConvertFileToAIFF</code>, para determinar si el sistema fue capaz de escribir los datos de audio a un 
                    archivo AIFF. Un método <code>AudioSystem</code> relacionado, <code>getAudioFileTypes(AudioInputStream)</code>, 
                    devuelve la lista completa de tipos de archivos admitidos para el flujo dado, como una matriz de instancias 
                    <code>AudioFileFormat.Type</code>. El método: 
                    BEGINCODE boolean isConversionSupported(AudioFormat.Encoding encoding,<br />
                    AudioFormat format) se usa para determinar si un flujo de entrada de audio de la codificación especificada 
                    puede ser obtenida desde un flujo de entrada de audio que tiene el formato de audio especificado. De forma 
                    similar, el método:
                </p>
                <div class="codeblock">
                    <pre>
boolean isConversionSupported(AudioFormat newFormat,
                              AudioFormat oldFormat) 
                    </pre>
                </div>
                <p>
                    nos dice si un <code>AudioInputStream</code> con el formato de audio especificado, <code>newFormat</code>, puede 
                    ser obtenido a través de la conversión de un <code>AudioInputStream</code> que tiene el formato de audio 
                    <code>oldFormat</code>. (Este método fue invocado en extracto de código de la sección anterior que creó un 
                    flujo de entrada de audio de baja resolución, <code>lowResAIS</code>).
                </p>
                <p>
                    Estas consultas relacionadas con el formato ayudan a prevenir errores cuando se intenta realizar conversiones 
                    con la IPA de Sonido de Java.
                </p>
            </div>
            <div class="NavBit">
                <a target="_top" href="controls.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="./TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="overview-MIDI.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Procesando Audio con Controles<br />
            <b>Página siguiente:</b> Descripción del Paquete MIDI
        </div>
    </body>
</html> 
