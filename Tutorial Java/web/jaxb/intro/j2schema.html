<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Ejemplos Java-a-Schema (Los Tutoriales de Java&trade; &gt; Arquitectura Java para Vinculación XML (JAXB) &gt;
            Introducción a JAXB)
        </title>
        <meta name="description" content="Este tutorial de JAXB describe la Arquitectura de Java para el Enlazado XML, y tópicos 
              de XML relacionados" />
        <meta name="keywords" content="java programming, learn java, java sample code, jaxb, xml" />
        <link rel="stylesheet" href="../../indice.css" type="text/css"/>
        <script src="../../navegacion.js"></script>
    </head>
    <body onload="load()">
        <noscript>Se requiere un navegador con JavaScript habilitado para que esta página opere apropiadamente.</noscript>
        <div class="header-container">
            <div class="bookwrapper clearfix">
                <div id="brandProdName">
                    <div id="logocover"></div>
                    <div id="productName">Documentación</div>
                </div>
                <br class="clearfloat" />
            </div>
        </div>
        <div id="TopBar">
            <div id="TopBar_tr">
                <div id="TopBar_tl">
                    <div id="TopBar_br">
                        <div id="TopBar_bl">
                            <div id="TopBar_left">Los Tutoriales de Java&trade;</div>
                            <div id="TopBar_right">
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/java-se-7-tutorial-2012-02-28-1536013.html">
                                    Descargar Libros Electrónicos</a><br />
                                <a target="_blank" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                                    Descargar KDJ</a><br />
                                <a href="javascript:toggleLeft()" id="ToggleLeft">
                                    Ocultar TdC</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="LeftBar" class="LeftBar_shown">
            <div id="Contents">
                <div class="linkLESSON"><a href="index.html">Introducción a JAXB</a></div>
                <div class="linkAHEAD"><a href="arch.html">Arquitectura JAXB</a></div>
                <div class="linkAHEAD"><a href="repcon.html">Representando Contenido XML</a></div>
                <div class="linkAHEAD"><a href="bind.html">Vinculando Esquemas XML</a></div>
                <div class="linkAHEAD"><a href="customize.html">Personalizando Clases Generadas y Elementos del Programa Java</a></div>
                <div class="linkAHEAD"><a href="examples.html">Ejemplos de JAXB</a></div>
                <div class="linkAHEAD"><a href="basic.html">Ejemplos Básicos</a></div>
                <div class="linkAHEAD"><a href="custom.html">Personalizando las Vinculaciones JAXB</a></div>
                <div class="nolinkAHEAD">Ejemplos Java-a-Schema</div>
                <div class="linkAHEAD"><a href="info.html">Para Más Información</a></div>
            </div>
        </div>
        <div id="MainFlow" class="MainFlow_indented">
            <div class="PrintHeaders">
                <b>Recorrido:</b> Arquitectura Java para Vinculación XML (JAXB)<br />
                <b>Lección:</b> Introducción a JAXB
            </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">Página de Inicio</a>&nbsp;&gt;&nbsp;
                <a href="../index.html" target="_top">Arquitectura Java para Vinculación XML (JAXB)</a>&nbsp;&gt;&nbsp;
                <a href="index.html" target="_top">Introducción a JAXB</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="custom.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="info.html">Siguiente&nbsp;&raquo;</a>
            </div>
            <div id="PageTitle">
                <h1>Ejemplos Java-a-Schema</h1>
            </div>
            <div id="PageContent">
                <p>
                    Los ejemplos Java a Esquema muestran cómo usar anotaciones para asignar clases Java al esquema XML.
                </p>
                <h2>
                    <a id="bnbcw"></a>Ejemplo j2s-create-marshal
                </h2>
                <p>
                    El ejemplo j2s-create-marshal ilustra la vinculación de datos Java a esquema. Demuestra al agrupación y 
                    separación de clases JAXB anotadas y también muestra cómo habilitar la validación de JAXP 1.3 en tiempo de 
                    separación usando un fichero de esquema que fue generado desde las clases asignadas de JAXB.
                </p>
                <p>
                    El fichero de esquema, <code>bc.xsd</code>, fue generado con los siguientes comandos:
                </p>
                <div class="codeblock">
                    <pre>
<code>schemagen src/cardfile/*.java</code>
<code>cp schema1.xsd bc.xsd</code>
                    </pre>
                </div>
                <p>
                    Tenga en cuenta que <code>schema1.xsd</code> fue copiado a <code>bc.xsd</code>;<code>schemagen</code> no le 
                    permite especificar un nombre de esquema de su elección.
                </p>
                <h3>
                    <a id="bnbcy"></a>Construyendo y Ejecutando el Ejemplo j2s-create-marshal Usando Ant
                </h3>
                <p>
                    
                    Para compilar y ejecutar el ejemplo j2s-create-marshal usando Ant, en una ventana de terminal, vaya al 
                    directorio <i>jaxb-ri-install</i><code>/samples/j2s-create-marshal/</code> y teclee lo siguiente:
                </p>
                <div class="codeblock">
                    <pre>
ant 
                    </pre>
                </div>
                <h2>
                    <a id="bnbcz"></a>Ejemplo j2s-xmlAccessorOrder
                </h2>
                <p>
                    El ejemplo j2s-xmlAccessorOrder muestra cómo usar las anotaciones <code>@XmlAccessorOrder</code> y
                    <code>@XmlType.propOrder</code> para dictar el orden en el cual el contenido XML es agrupado y separado por 
                    un tipo Java.
                </p>
                <p>
                    Con la asignación de Java a esquema, unas propiedades y campos del JavaBean son asignadas a un tipo del Esquema 
                    XML. Los elementos de la clase son asignados a un tipo complejo del Esquema XML o a un tipo simple del Esquema 
                    XML. El orden de elementos predeterminado para un tipo de esquema generado no está actualmente especificado 
                    porque la reflexión de Java no impone un orden de retorno. La falta de un orden de elementos confiable afecta 
                    negativamente la portabilidad de la aplicación. Puede usar dos anotaciones, <code>@XmlAccessorOrder</code> y 
                    <code>@XmlType.propOrder</code>, para definir la ordenación de los elementos del esquema para aplicaciones que 
                    deben ser portables entre Proveedores JAXB.
                </p>
                <h3>
                    <a id="bnbda"></a>Usar la Anotación <code>@XmlAccessorOrder</code> para Definir el Orden de Elementos del 
                    Esquema
                </h3>
                <p>
                    La anotación <code>@XmlAccessorOrder</code> impone uno de los dos algoritmos de ordenación de elementos, 
                    <code>AccessorOrder.UNDEFINED</code> o <code>AccessorOrder.ALPHABETICAL</code>. 
                    <code>AccessorOrder.UNDEFINED</code> es la configuración predeterminada. El orden es dependiente de la 
                    implementación de reflexión del sistema. el algoritmo <code>AccessorOrder.ALPHABETICAL</code> ordena los 
                    elementos en orden lexicográfico como determina <code>java.lang.String.CompareTo(String anotherString)</code>.
                </p>
                <p>
                    Puede definir la anotación <code>@XmlAccessorOrder</code> para el tipo de anotación 
                    <code>ElementType.PACKAGE</code> sobre un objeto clase. Cuando la anotación <code>@XmlAccessorOrder</code> se 
                    define sobre un paquete, el alcance de la regla de formato se activa para cada clase en el paquete. Cuando se 
                    define en una clase, la regla se activa en los contenidos de esa clase.
                </p>
                <p>
                    Pueden haber varias anotaciones <code>@XmlAccessorOrder</code> dentro de un paquete. La anotación más interna 
                    (clase) tiene prioridad sobre la anotación externa. Por ejemplo, si se define 
                    <code>@XmlAccessorOrder(AccessorOrder.ALPHABETICAL)</code> en un paquete y 
                    <code>@XmlAccessorOrder(AccessorOrder.UNDEFINED)</code> se define en una clase en ese paquete, los contenidos 
                    del tipo de esquema generado para la clase estarían en un orden no especificado y los contenidos del tipo de 
                    esquema generado para todas las demás clases en el paquete estaría en orden alfabético.
                </p>
                <h3>
                    <a id="bnbdb"></a>Usar la Anotación <code>@XmlType</code> para Definir el Orden de Elementos del Esquema
                </h3>
                <p>
                    La anotación <code>@XmlType</code> puede ser definida para una clase. El elemento de anotación 
                    <code>propOrder()</code> en la anotación <code>@XmlType</code> le permite especificar el orden del contenido en 
                    el tipo de esquema generado. Cuando usa la anotación <code>@XmlType.propOrder</code> sobre una clase para 
                    especificar el orden del contenido, todas las propiedades públicas y campos públicos en la clase deben ser 
                    especificados en la lista de parámetros. Cualquier propiedad o campo público que quiera mantener fuera de la 
                    lista de parámetros debe ser anotada con la anotación <code>@XmlAttribute</code> o <code>@XmlTransient</code>.
                </p>
                <p>
                    El orden de contenido predeterminado para <code>@XmlType.propOrder</code> es <code>{}</code> o 
                    <code>{&quot;&quot;}</code>, no activo. En tales casos, la anotación activa <code>@XmlAccessorOrder</code> 
                    tiene prioridad. Cuando el orden del contenido de la clase se especifica por la anotación 
                    <code>@XmlType.propOrder</code>, tiene prioridad sobre cualquier anotación <code>@XmlAccessorOrder</code> 
                    activa sobre la clase o el paquete. Si las anotaciones <code>@XmlAccessorOrder</code> y 
                    <code>@XmlType.propOrder(A, B, ...)</code> se especifican sobre una clase, la <code>propOrder</code> siempre 
                    tiene prioridad independientemente del orden de las sentencias de anotación. Por ejemplo, en el siguiente 
                    segmento de código, la anotación <code>@XmlAccessorOrder</code> precede a la anotación 
                    <code>@XmlType.propOrder</code>.
                </p>
                <div class="codeblock">
                    <pre>
@XmlAccessorOrder(AccessorOrder.ALPHABETICAL)
@XmlType(propOrder={&quot;name&quot;, &quot;city&quot;})

public class USAddress {
    // ...
    public String getCity() {return city;}
    public void setCity(String city) {this.city = city;}
    public String getName() {return name;}
    public void setName(String name) {this.name = name;}
    // ...
}
                    </pre>
                </div>
                <p>
                    En el siguiente segmento de código, la anotación <code>@XmlType.propOrder</code> precede a la anotación 
                    <code>@XmlAccessorOrder</code>.
                </p>
                <div class="codeblock">
                    <pre>
@XmlType(propOrder={&quot;name&quot;, &quot;city&quot;})
@XmlAccessorOrder(AccessorOrder.ALPHABETICAL)
public class USAddress {
    // ...
    public String getCity() {return city;}
    public void setCity(String city) {this.city = city;}
    public String getName() {return name;}
    public void setName(String name) {this.name = name;}
    // ...
}
                    </pre>
                </div>
                <p>
                    En ambos escenarios, <code>propOrder</code> tiene prioridad y se genera el siguiente contenido de esquema 
                    idéntico:
                </p>
                <div class="codeblock">
                    <pre>
&lt;xs:complexType name=&quot;usAddress&quot;&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element 
            name=&quot;name&quot; 
            type=&quot;xs:string&quot; 
            minOccurs=&quot;0&quot;/&gt;
        &lt;xs:element 
            name=&quot;city&quot; 
            type=&quot;xs:string&quot; 
            minOccurs=&quot;0&quot;/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
                    </pre>
                </div>
                <h3>
                    <a id="bnbdc"></a>Orden del Contenido del Esquema en el Ejemplo
                </h3>
                <p>
                    El ejemplo de la orden de compra demuestra los efectos de la ordenación del contenido del esquema utilizando la 
                    anotación <code>@XmlAccessorOrder</code> a nivel de paquete y clase, y la anotación 
                    <code>@XmlType.propOrder</code> en una clase.
                </p>
                <p>
                    La clase <code>package-info.java</code> define <code>@XmlAccessorOrder</code> para ser 
                    <code>ALPHABETICAL</code> para el paquete. Los campos públicos <code>shipTo</code> y <code>billTo</code> en la 
                    clase <code>PurchaseOrderType</code> se ven afectados en el orden de contenido del esquema generado por esta 
                    regla. La clase <code>USAddress</code> define la anotación <code>@XmlType.propOrder</code> en la clase que 
                    demuestra el orden de propiedad definido por el usuario que reemplaza el orden <code>ALPHABETICAL</code> en el 
                    esquema generado.
                </p>
                <p>
                    El fichero de esquema generado se puede encontrar en el directorio 
                    <i>jaxb-ri-install</i><code>/samples/j2s-xmlAccessorOrder/build/schemas/</code>.
                </p>
                <h3>
                    <a id="bnbde"></a>Construyendo y Ejecutando el Ejemplo j2s-xmlAccessorOrder Usando Ant
                </h3>
                <p>
                    Para compilar y ejecutar el ejemplo j2s-xmlAccessorOrder usando Ant, en una ventana de terminal, vaya al 
                    directorio <i>jaxb-ri-install</i><code>/samples/j2s-xmlAccessorOrder/</code> y teclee lo siguiente:
                </p>
                <div class="codeblock">
                    <pre>
ant 
                    </pre>
                </div>
                <h2>
                    <a id="bnbdf"></a>Ejemplo j2s-xmlAdapter
                </h2>
                <p>
                    El ejemplo j2s-xmlAdapter demuestra como usar la interfaz <code>XmlAdapter</code> y la anotación 
                    <code>@XmlJavaTypeAdapter</code> para proporcionar una asignación personalizada del contenido XML dentro y 
                    fuera de un <code>HashMap</code> (campo) que usa un <code>int</code> como la clave y una <code>String</code> 
                    como el valor.
                </p>
                <p>
                    La interfaz <code>XmlAdapter</code> y la anotación <code>@XmlJavaTypeAdapter</code> se usan para el procesado 
                    especial de tipos de datos durante la separación (unmarshalling) y la agrupación (marshalling). Hay una 
                    variedad de tipos de datos XML para los cuales la representación no asigna fácilmente en Java (por ejemplo, 
                    <code>xs:DateTime</code> y <code>xs:Duration</code>), y los tipos Java que no asignan apropiadamente en 
                    representaciones XML. Por ejemplo, implementaciones de <code>java.util.Collection</code> (tales como 
                    <code>List</code>) y <code>java.util.Map</code> (tal como <code>HashMap</code>) o para clases que no son 
                    JavaBean.
                </p>
                <p>
                    La interfaz <code>XmlAdapter</code> y la anotación <code>@XmlJavaTypeAdapter</code> se proporcionan para casos 
                    como estos. Esta combinación proporciona un mecanismo portable para leer y escribir contenido XMl dentro y 
                    fuera de las aplicaciones Java.
                </p>
                <p>
                    La interfaz <code>XmlAdapter</code> define los métodos para la lectura y escritura de los datos.
                </p>
                <div class="codeblock">
                    <pre>
/*
 *  ValueType - Java class that provides an 
 *  XML representation of the data. 
 *  It is the object that is used for marshalling and 
 *  unmarshalling.
 *
 *  BoundType - Java class that is used to 
 *  process XML content.
 */
 
public abstract class XmlAdapter&lt;ValueType,BoundType&gt; {

    // Do-nothing constructor for the derived classes.
    protected XmlAdapter() {}
    
    // Convert a value type to a bound type.
    public abstract BoundType unmarshal(ValueType v);
    
    // Convert a bound type to a value type.
    public abstract ValueType marshal(BoundType v);
}
                    </pre>
                </div>
                <p>
                    Puede usar la anotación <code>@XmlJavaTypeAdapter</code> para asociar una implementación particular de 
                    <code>XmlAdapter</code> con un tipo <code>Target</code>, <code>PACKAGE</code>, <code>FIELD</code>, 
                    <code>METHOD</code>, <code>TYPE</code>, o <code>PARAMETER</code>.
                </p>
                <p>
                    El ejemplo j2s-xmlAdapter muestra cómo usar un <code>XmlAdapter</code> para asignar contenido XML dentro y fuera 
                    de un <code>HashMap</code> (personalizado). El objeto <code>HashMap</code>, <code>basket</code>, en la clase 
                    <code>KitchenWorldBasket</code>, usa una clave de tipo <code>int</code> y un valor del tipo <code>String</code>. 
                    Estos tipos de datos deben ser reflejados en el contenido XML que se lee y se escribe, de forma que el 
                    contenido XML tiene el aspecto como en el siguiente ejemplo:
                </p>
                <div class="codeblock">
                    <pre>
&lt;basket&gt;
    &lt;entry key=&quot;9027&quot;&gt;glasstop stove in black&lt;/entry&gt;
    &lt;entry key=&quot;288&quot;&gt;wooden spoon&lt;/entry&gt;
&lt;/basket&gt;
                    </pre>
                </div>
                <p>
                    El esquema generado predeterminado para el tipo Java <code>HashMap</code> no refleja el formato deseado.
                </p>
                <div class="codeblock">
                    <pre>
&lt;xs:element name=&quot;basket&quot;&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element 
                name=&quot;entry&quot; 
                minOccurs=&quot;0&quot; 
                maxOccurs=&quot;unbounded&quot;&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:sequence&gt;
                        &lt;xs:element 
                            name=&quot;key&quot; 
                            minOccurs=&quot;0&quot;
                            type=&quot;xs:anyType&quot;/&gt;
                        &lt;xs:element 
                            name=&quot;value&quot; 
                            minOccurs=&quot;0&quot; 
                            type=&quot;xs:anyType&quot;/&gt;
                    &lt;/xs:sequence&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
                    </pre>
                </div>
                <p>
                    En el esquema predeterminado de <code>HashMap</code>, la clave y el valor son ambos elementos y son de un tipo 
                    de datos <code>anyType</code>. El contenido XML tiene el siguiente aspecto:
                </p>
                <div class="codeblock">
                    <pre>
&lt;basket&gt;
    &lt;entry&gt;
        &lt;key&gt;9027&lt;/key&gt;
        &lt;value&gt;glasstop stove in black&lt;/value&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
        &lt;key&gt;288&lt;/key&gt;
        &lt;value&gt;wooden spoon&lt;/value&gt;
    &lt;/entry&gt;
&lt;/basket&gt;
                    </pre>
                </div>
                <p>
                    Para resolver este problema, el ejemplo usa dos clases Java, <code>PurchaseList</code> y <code>PartEntry</code>,
                    que reflejan el formato de esquema necesitado para separar y agrupar el contenido. El esquema XML generado 
                    para estas clases es el siguiente:
                </p>
                <div class="codeblock">
                    <pre>
&lt;xs:complexType name=&quot;PurchaseListType&quot;&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element 
            name=&quot;entry&quot; 
            type=&quot;partEntry&quot;
            nillable=&quot;true&quot; 
            maxOccurs=&quot;unbounded&quot;
            minOccurs=&quot;0&quot;/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name=&quot;partEntry&quot;&gt;
    &lt;xs:simpleContent&gt;
        &lt;xs:extension base=&quot;xs:string&quot;&gt;
            &lt;xs:attribute
                name=&quot;key&quot; 
                type=&quot;xs:int&quot;
                use=&quot;required&quot;/&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
                    </pre>
                </div>
                <p>
                    La clase <code>AdapterPurchaseListToHashMap</code> implementa la interfaz <code>XmlAdapter</code>. En la clase 
                    <code>KitchenWorldBasket</code>, la anotación <code>@XmlJavaTypeAdapter</code> se usa para emparejar 
                    <code>AdapterPurchaseListToHashMap</code> con el campo <code>basket</code> de tipo <code>HashMap</code>. Este 
                    emparejado causa que el método marshal o unmarshal de <code>AdapterPurchaseListToHashMap</code> sea llamado para 
                    cualquier acción correspondiente de agrupar (marshal) o separar (unmarshal) sobre 
                    <code>KitchenWorldBasket</code>.
                </p>
                <h3>
                    <a id="bnbdh"></a>Construyendo y Ejecutando el Ejemplo j2s-xmlAdapter Usando Ant
                </h3>
                <p>
                    Para compilar y ejecutar el ejemplo j2s-xmlAdapter usando Ant, en una ventana de terminal, vaya al directorio 
                    <i>jaxb-ri-install</i><code>/samples/j2s-xmlAdapter/</code> y teclee lo siguiente:
                </p>
                <div class="codeblock">
                    <pre>
ant
                    </pre>
                </div>
                <h2>
                    <a id="bnbdi"></a>Ejemplo j2s-xmlAttribute
                </h2>
                <p>
                    El ejemplo j2s-xmlAttribute muestra cómo usar la anotación <code>@XmlAttribute</code> para definir una 
                    propiedad o campo para que sea tratado como un atributo XML.
                </p>
                <p>
                    La anotación <code>@XmlAttribute</code> asigna un campo o propiedad de JavaBean a un atributo XML. Se imponen 
                    las siguientes reglas:
                </p>
                <ul>
                    <li>
                        Un campo final estático se asigna a un atributo XML fijo.
                    </li>
                    <li>
                        Cuando el campo o la propiedad es un tipo de colección, los elementos del tipo colección deben asignarse a 
                        un tipo simple del esquema.
                    </li>
                    <li>
                        Cuando el campo o la propiedad es distinto de un tipo colección, el tipo debe asignar a un tipo simple del 
                        esquema.
                    </li>
                </ul>
                <p>
                    Al seguir el paradigma de programación JavaBean, una propiedad se define por un prefijo <code>get</code> y 
                    <code>set</code> en el nombre del campo.
                </p>
                <div class="codeblock">
                    <pre>
int zip;
public int getZip(){return zip;}
public void setZip(int z){zip=z;}
                    </pre>
                </div>
                <p>
                    Con una clase bean, tiene la elección de establecer la anotación <code>@XmlAttribute</code> sobre uno de los 
                    tres componentes: el campo, el método setter (establecedor), o el método getter (adquiridor). Si establece la 
                    anotación <code>@XmlAttribute</code>  sobre el campo, el método setter debe ser renombrado o habrá un conflicto 
                    de nombrado en tiempo de compilación. Si establece la anotación <code>@XmlAttribute</code> en uno de los 
                    métodos, debe ser establecido en el método setter o getter, pero no en ambos.
                </p>
                <p>
                    El ejemplo XmlAttribute muestra cómo usar la anotación <code>@XmlAttribute</code> sobre un campo estático final, 
                    sobre un campo en lugar de en uno de los métodos de bean correspondientes, en una propiedad (método) del bean y 
                    en un campo que no es un tipo de colección. En la clase <code>USAddress</code>, fields, country, y zip se 
                    etiquetan como atributos. El método <code>setZip</code> fue deshabilitado para evitar el error de compilación. 
                    La propiedad state fue etiquetada como un atributo en el método setter. En su lugar, podría haber usado el 
                    método getter. En la clase <code>PurchaseOrderType</code>, el campo <code>cCardVendor</code> no es un tipo de 
                    colección. Cumple con el requisito de ser un tipo simple; es un tipo <code>enum</code>.
                </p>
                <h3>
                    <a id="bnbdk"></a>Construyendo y Ejecutando el Ejemplo j2s-xmlAttribute Usando Ant
                </h3>
                <p>
                    Para compilar y ejecutar el ejemplo j2s-xmlAttribute usando Ant, en una ventana de terminal, vaya al directorio 
                    <i>jaxb-ri-install</i><code>/samples/j2s-xmlAttribute/</code> y teclee lo siguiente:
                </p>
                <div class="codeblock">
                    <pre>
ant
                    </pre>
                </div>
                <h2>
                    <a id="bnbdl"></a>Ejemplo j2s-xmlRootElement
                </h2>
                <p>
                    El ejemplo j2s-xmlRootElement demuestra el uso de la anotación <code>@XmlRootElement</code> para definir un 
                    nombre de elemento XML para el tipo de esquema XML de la clase correspondiente.
                </p>
                <p>
                    La anotación <code>@XmlRootElement</code> asigna una clase o un tipo <code>enum</code> a un elemento XML. Al 
                    menos se necesita una definición de elemento para cada tipo Java de nivel superior usado para separar y 
                    agrupar. Si no hay definición de elemento, no hay una ubicación de inicio para el procesamiento del contenido 
                    XML.
                </p>
                <p>
                    La anotación <code>@XmlRootElement</code> usa el nombre de la clase como el nombre del elemento predeterminado. 
                    Puede cambiar el nombre predeterminado usando el atributo de anotación <code>name</code>. Si lo hace, el 
                    nombre especificado se usa como el nombre del elemento y el nombre del tipo. Es una práctica común de esquema 
                    que los nombres de elemento y tipo sean diferentes. Puede usar la anotación <code>@XmlType</code> para 
                    establecer el nombre del tipo del elemento.
                </p>
                <p>
                    El atributo namespace de la anotación <code>@XmlRootElement</code> se usa para definir un espacio de nombres 
                    para el elemento.
                </p>
                <h3>
                    <a id="bnbdn"></a>Construyendo y Ejecutando el Ejemplo j2s-xmlRootElement Usando Ant
                </h3>
                <p>
                    Para compilar y ejecutar el ejemplo j2s-xmlRootElement usando Ant, en una ventana de terminal, vaya al 
                    directorio <i>jaxb-ri-install</i><code>/samples/j2s-xmlRootElement/</code> y teclee lo siguiente:
                </p>
                <div class="codeblock">
                    <pre>
ant
                    </pre>
                </div>
                <h2>
                    <a id="bnbdo"></a>Ejemplo j2s-xmlSchemaType
                </h2>
                <p>
                    El ejemplo j2s-xmlSchemaType demuestra el uso de la anotación <code>@XmlSchemaType</code> para personalizar la 
                    asignación de una propiedad o campo a un tipo integrado de XML.
                </p>
                <p>
                    La anotación <code>@XmlSchemaType</code> se puede usar para asignar un tipo Jva a uno de los tipos integrados en 
                    XML. Esta anotación es más útil en la asignación de un tipo Java a uno de los nueve tipos de datos primitivos de 
                    fecha/hora.
                </p>
                <p>
                    Cuando la anotación <code>@XmlSchemaType</code> se define en el nivel de paquete, la identificación requiere 
                    tanto el nombre del tipo XML integrado como la clase del tipo Java correspondiente. Una definición 
                    <code>@XmlSchemaType</code>  sobre un campo o propiedad tiene prioridad sobre una definición de paquete.
                </p>
                <p>
                    El ejemplo de la Clase XmlSchemaType  muestra cómo usar la anotación <code>@XmlSchemaType</code> en el nivel de 
                    paquete, sobre un campo, y sobre una propiedad. El fichero <code>TrackingOrder</code> tiene dos campos, 
                    <code>orderDate</code> y <code>deliveryDate</code>, que son definidos para ser del tipo 
                    <code>XMLGregorianCalendar</code>. El esquema generado definirá estos elementos para ser del tipo integrado de 
                    XML <code>gMonthDay</code>. Esta relación fue definida en el paquete en el fichero 
                    <code>package-info.java</code>. El campo <code>shipDate</code> en el fichero <code>TrackingOrder</code> también 
                    se define para que sea del tipo <code>XMLGregorianCalendar</code>, pero las declaraciones de anotación 
                    <code>@XmlSchemaType</code> anulan la definición del paquete y especifican que el campo sea del tipo 
                    <code>date</code>. El método de propiedad <code>getTrackingDuration</code> define que elemento de esquema que 
                    se definirá como un tipo primitivo <code>duration</code> y no el tipo Java <code>String</code>.
                </p>
                <h3>
                    <a id="bnbdq"></a>Construyendo y Ejecutando el Ejemplo j2s-xmlSchemaType Usando Ant
                </h3>
                <p>
                    Para compilar y ejecutar el ejemplo j2s-xmlSchemaType usando Ant, en una ventana de terminal, vaya al directorio
                    <i>jaxb-ri-install</i><code>/samples/j2s-xmlSchemaType/</code> y teclee lo siguiente:
                </p>
                <div class="codeblock">
                    <pre>
ant 
                    </pre>
                </div>
                <h2>
                    <a id="bnbdr"></a>Ejemplo j2s-xmlType
                </h2>
                <p>
                    El ejemplo j2s-xmlType demuestra el uso de la anotación <code>@XmlType</code>. La anotación 
                    <code>@XmlType</code> asigna una clase o un tipo <code>enum</code> a un tipo Esquema XML.
                </p>
                <p>
                    Una clase debe tener un constructor público sin argumentos o método de factoría estática sin argumentos para 
                    poder ser asignada por esta anotación. Uno de estos métodos se usa durante la separación para crear una 
                    instancia de la clase. El método de factoría puede ser ubicado dentro de una clase de factoría o en la clase 
                    existente.
                    
                </p>
                <p>
                    Hay un orden de precedencia en cuanto a qué método se utiliza para separar:
                </p>
                <ul>
                    <li>
                        Si se identifica una clase factoría en la anotación, también se debe identificar un método de factoría 
                        correspondiente en esa clase, y ese método se utilizará.
                    </li>
                    <li>
                        Si un método de factoría se identifica en la anotación pero no se identifica una clase factoría, el método 
                        de factoría debe estar ubicado en la clase actual. El método de factoría se usa incluso si hay un 
                        constructor público sin argumentos presente.
                    </li>
                    <li>
                        Si no se identifica un método factoría en la anotación, la clase debe contener un constructor público sin 
                        argumentos.
                    </li>
                </ul>
                <p>
                    En este ejemplo, una clase factoría proporciona métodos factoría sin argumentos para varias clases. La 
                    anotación <code>@XmlType</code> sobre la clase <code>OrderContext</code> referencia a la clase factoría. El 
                    separador usa el método de factoría identificado en esta clase.
                </p>
                <div class="codeblock">
                    <pre>
public class OrderFormsFactory {

    public OrderContext newOrderInstance() {
        return new OrderContext()
    }

    public PurchaseOrderType {
        newPurchaseOrderType() {
            return new newPurchaseOrderType();
        }
    }
    
    @XmlType(name=&quot;oContext&quot;,
        factoryClass=&quot;OrderFormsFactory&quot;,
        factoryMethod=&quot;newOrderInstance&quot;)
    public class OrderContext {
        public OrderContext() {
            // ...
        }
    }
}
                    </pre>
                </div>
                <p>
                    En este ejemplo, un método de factoría se define en una clase, que también contiene una construcción de clase 
                    estándar. Ya que el valor de <code>factoryMethod</code> se define y no se define una <code>factoryClass</code>, 
                    el método de factoría <code>newOrderInstance</code> se usa durante la separación.
                </p>
                <div class="codeblock">
                    <pre>
@XmlType(name=&quot;oContext&quot;, 
    factoryMethod=&quot;newOrderInstance&quot;)
public class OrderContext {

    public OrderContext() {
        // ...
    }

    public OrderContext newOrderInstance() {
        return new OrderContext();
    }
}
                    </pre>
                </div>
                <h3>
                    <a id="bnbdt"></a>Construyendo y Ejecutando el Ejemplo j2s-xmlType Usando Ant
                </h3>
                <p>
                    Para compilar y ejecutar el ejemplo j2s-xmlType usando Ant, en una ventana de terminal, vaya al directorio 
                    <i>jaxb-ri-install</i><code>/samples/j2s-xmlType/</code> y teclee lo siguiente:
                </p>
                <div class="codeblock">
                    <pre>
ant
                    </pre>
                </div>
            </div>
            <div class="NavBit">
                <a target="_top" href="custom.html">&laquo;&nbsp;Anterior</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="../TOC.html">TdC</a>&nbsp;&bull;&nbsp;
                <a target="_top" href="info.html">Siguiente&nbsp;&raquo;</a>
            </div>
        </div>
        <hr class="clearfloat"/>
        <div id="Footer">
            <table style="width: 100%;padding: 5px">
                <tr>
                    <td>
                        <p class="footertext">
                            <a id="license_info">Su uso de ésta</a> página y todo el material en las páginas bajo el anuncio
                            &quot;Los Tutoriales de Java&quot; está sujeto a estos <a href="../../information/cpyr.html">avisos
                                legales</a>.
                        </p>
                        <p class="footertext">
                            Copyright &copy; 1995, 2015 Oracle y/o sus afiliados. Todos los derechos reservados.
                        </p>
                    </td>
                    <td style="text-align: right">
                        <p class="footertext">
                            ¿Problemas con estos ejemplos? Intente
                            <a target="_blank" href="../../information/run-examples.html">Compilando y Ejecutando los Ejemplos: PFs
                            </a>.
                        </p>
                        <p class="footertext">
                            ¿Quejas? ¿Elogios? ¿Sugerencias? <a target="_blank" href="https://docs.oracle.com/javase/feedback.html">
                                Denos su opinión</a>.
                        </p>
                    </td>
                </tr>
            </table>
        </div>
        <div class="PrintHeaders">
            <b>Página anterior:</b> Personalizando las Vinculaciones JAXB<br />
            <b>Página siguiente:</b> Para Más Información
        </div>
    </body>
</html> 
