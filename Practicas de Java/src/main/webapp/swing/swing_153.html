<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas Java-&gt;Hilos de Swing</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Búsqueda" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">
      Hilos de Swing
    </div>
    <br />
    <b>Hilo de Envío de Eventos</b>
    <p>
      En una aplicación Swing, la mayoría del proceso tiene lugar, en un subproceso único, especial llamado 
      <a href="http://docs.oracle.com/javase/tutorial/uiswing/concurrency/dispatch.html">hilo de envío de eventos</a> (EDT, en 
      inglés).
    </p>
    <p>
      Este subproceso se vuelve activo después de que un componente se <i>realiza</i>: ya sea <code>pack</code>, <code>show</code>, 
      o <code>setVisible(true)</code> ha sido llamado. Cuando se realiza una ventana de nivel superior, también se realizan todos 
      sus componentes. Swing es principalmente de un solo subproceso:
      <span class="highlight">
        casi todas las llamadas a componentes realizados deben ejecutarse en el subproceso de envío de eventos</span>. Las 
        excepciones seguras para subprocesos son:
    </p>
    <ul>
      <li>algunos métodos de 
        <code><a href="https://docs.oracle.com/javase/10/docs/api/javax/swing/JComponent.html">JComponent</a></code>: 
        <code>repaint</code>, <code>revalidate</code>, <code>invalidate</code>
      </li>
      <li>
        todos los métodos <code>addXXXListener</code> y <code>removeXXXListener</code>
      </li>
      <li>todos los métodos documentados explícitamente como seguros para subprocesos</li>
    </ul>
    <b>Los subprocesos de trabajo mantienen las interfaces gráficas de usuario responsivas</b>
    <p>
      Si una tarea necesita un tiempo relativamente largo para completarse, entonces realizar esa tarea en el subproceso de despacho 
      de eventos hará que la interfaz de usuario deje de responder mientras dure la tarea: la GUI se "bloquea". Dado que esto no es 
      deseable, estas tareas generalmente se realizan fuera del subproceso de despacho de eventos, en lo que comúnmente se conoce 
      como un <i>subproceso de trabajo</i>.
    </p>
    <p>
      Cuando un subproceso de trabajo completa su tarea, necesita un mecanismo especial para actualizar los componentes GUI 
      realizados, ya que, como se indicó anteriormente, los componentes realizados casi siempre necesitan actualizarse solo desde el 
      subproceso de despacho de eventos.
    </p>
    <p>
      Con los KDJ modernos, la forma más común de hacer esto es la clase 
      <code><a href="https://docs.oracle.com/javase/10/docs/api/javax/swing/SwingWorker.html">SwingWorker</a></code>, 
      presentada en JSE 6. Debe usarse si está disponible.
    </p>
    <p>
      Para usar temporizadores, consulte este <a href="../swing/swing_160.html">tema</a>.
    </p>
    <p>
      <b>Ejemplo 1</b>
    </p>
    <p>
      La 
      <a href="http://www.javapractices.com/apps/stocksmonitor/javadoc/src-html/hirondelle/stocks/quotes/FetchQuotesAction.html">
        <code>FetchQuotesAction</code></a> obtiene información sobre el precio de las acciones. Esto es un buen ejemplo de una 
        operación que debe estar en un subproceso separado. Ya que no se sabe cuanto tiempo va a durar, o incluso si una buena 
        conexión web está presente. Es una operación que podría bloquear el IGU muy fácilmente.
    </p>
    <p>
      A continuación se muestran las partes pertinentes de su código. Tenga en cuenta cómo <code>SwingWorker</code> se divide en 
      dos partes: <code>doInBackground</code> hace el trabajo principal y devuelve cualquier dato necesitado, y <code>done</code> 
      primero llama a <code>get</code> para acceder a los datos y luego actualiza la interfaz de usuario.<br />
    </p>
    <pre>
<span class="comment">/**
* Obtener datos de cotización actuales para el {@link CurrentPortfolio} de una fuente de 
* datos en la web.
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> FetchQuotesAction <span
            class="keyword">extends</span> AbstractAction <span
            class="keyword">implements</span> Observer {

  <span class="comment">//omitido...
</span>
  <span class="comment">/** 
   Obtenga cotizaciones de la web para &lt;tt&gt;CurrentPortfolio&lt;/tt&gt;.
   Esto se llama de forma explícita o periódica mediante un temporizador.
  */</span>
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
            class="keyword">void</span> actionPerformed(ActionEvent e) {
    fLogger.info(<span class="literal">"Obteniendo cotizaciones de la web."</span>);
    fSummaryView.showStatusMessage(<span class="literal">"Obteniendo cotizaciones..."</span>);
    SwingWorker&lt;List&lt;Quote&gt;, Void&gt; hardWorker = <span
            class="keyword">new</span> HardWorker();
    hardWorker.execute();
  }
  
  <span class="comment">/**
  * El conjunto de objetos {@link Stock} en los cuales el usuario 
  * está actualmente interesado.
  */</span>
  <span class="keyword">private</span> CurrentPortfolio fCurrentPortfolio;

  <span class="comment">/**
  * elemento del IGU que se actualiza cuando se obtiene un nuevo conjunto de cotizaciones.
  */</span>
  <span class="keyword">private</span> SummaryView fSummaryView;

  <span class="comment">//omitido...
</span>  
  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">class</span> HardWorker <span
            class="keyword">extends</span> SwingWorker&lt;java.util.List&lt;Quote&gt;, Void&gt; {
    <span class="keyword">@Override</span>  <span class="keyword">protected</span> List&lt;Quote&gt; doInBackground() <span
            class="keyword">throws</span> Exception {
      List&lt;Quote&gt; result = <span class="keyword">null</span>;
      <span class="keyword">try</span> {
        result = fCurrentPortfolio.getPortfolio().getQuotes();
      }
      <span class="keyword">catch</span>(DataAccessException ex){
        ex.printStackTrace();
      }
      <span class="keyword">return</span> result;
    }
    <span class="keyword">@Override</span> <span class="keyword">protected</span> <span
            class="keyword">void</span> done() {
      <span class="keyword">try</span> {
        <span class="comment">//obtener los datos obtenidos anteriormente, en doInBackground()
</span>        List&lt;Quote&gt; quotes = get();
        <span class="keyword">if</span> (quotes != <span class="keyword">null</span>){
          showUpdated(quotes);
        }
        <span class="keyword">else</span> {
          fSummaryView.showStatusMessage(<span class="literal">"Error: conéctese a la web."</span>);
        }
      }
      <span class="keyword">catch</span> (Exception ex) {
        ex.printStackTrace();
      }
    }
  }
}
 
    </pre>
    <p></p>
    <p>
      <b>KDJ &lt; 6</b>
    </p>
    <p>
      Otras técnicas se necesitan cuando se usan versiones más antiguas del KDJ. Dos métodos de la clase 
      <code><a href="https://docs.oracle.com/javase/10/docs/api/java/awt/EventQueue.html">EventQueue</a></code>, 
      <code>invokeLater</code> y <code>invokeAndWait</code>, se proporcionan para este propósito 
      (<code><a href="https://docs.oracle.com/javase/10/docs/api/javax/swing/SwingUtilities.html">SwingUtilities</a></code> tienen
      métodos sinónimos también). Sun recomienda usar <code>invokeLater</code> como el estilo habitual preferido.
    </p>
    <p>
      Cuando se usan subprocesos de esta forma, es usualmente una buena idea usar subprocesos <em>demonio</em>, no subprocesos de 
      <em>usuario</em>m cuando sea posible: los subprocesos demonio no previenen que una aplicación termine. Ya que los subprocesos 
      son subprocesos de usuario de forma predeterminada, se requiere una llamada explícita a 
      <code>
        Thread.<a
          href="https://docs.oracle.com/javase/10/docs/api/java/lang/Thread.html#setDaemon(boolean)">setDaemon</a>(true)
      </code>.
    </p>
    <p>
      Los ejemplos restantes usan JSE 1.5.
    </p>
    <p>
      <b>Ejemplo 2</b>
    </p>
    <p>
      El tema de <a href="../swing/swing_149.html">Pantalla de Bienvenida</a> (y en particular su clase 
      <code>Launcher</code>) es un buen ejemplo de usar un subproceso de trabajo. Aquí, el estado de un subproceso lanzado como 
      un subproceso de trabajo se explota para mostrar una pantalla de bienvenida al usuario, pero solo hasta que la ventana 
      principal acabe de cargarse.
    </p>
    <p>
      <b>Ejemplo 3</b>
    </p>
    <p>
      La clase <code>ColorTip</code>, mostrada abajo, cambia el color de fondo de un componente para un intervalo de tiempo fijo y 
      corto, como una forma simple de llamar la atención de ese componente.
    </p>
    <p>
      Su subproceso de trabajo no trabaja muy duro - duerme un montón. Las llamadas a <code>sleep</code> no causan que el IGU 
      deje de responder, sin embargo, ya que estas llamadas no tienen lugar en el subproceso de envío de eventos.
    </p>
    <p>
      <code>ColorTip</code> tiene tres clases anidadas <code>private</code>, <code>Runnable</code>:
    </p>
    <ul>
      <li><code>Worker</code> - inserta intervalos de tiempo específicos entre los colores cambiantes</li>
      <li><code>ChangeColor</code> - actualiza la IGU cambiando el color de fondo de un componente de destino</li>
      <li><code>RevertColor</code> - actualiza la IGU cambiando el color de fondo a su color original</li>
    </ul>
    <br />
    <pre>
<span class="keyword">package</span> hirondelle.stocks.quotes;

<span class="keyword">import</span> hirondelle.stocks.util.Args;
<span class="keyword">import</span> hirondelle.stocks.util.Consts;
<span class="keyword">import</span> hirondelle.stocks.util.Util;

<span class="keyword">import</span> java.awt.Color;
<span class="keyword">import</span> java.awt.EventQueue;
<span class="keyword">import</span> java.util.logging.Logger;

<span class="keyword">import</span> javax.swing.JComponent;

<span class="comment">/**
* Llama la atención del usuario sobre un aspecto de la IGU (muy parecido a un
* &lt;tt&gt;ToolTip&lt;/tt&gt;) cambiando el color de fondo de un 
* componente (habitualmente una &lt;tt&gt;JLabel&lt;/tt&gt;) por unos pocos segundos;
* el componente siempre revertirá a su color de fondo original
* después de que haya pasado un corto espacio de tiempo. Esto se hace una vez, sin repetirse.
* 
* &lt;p&gt;Ejemplo de caso de uso:
* 
&lt;pre&gt;
 //sin retardo inicia, y muestra el nuevo color solo por 2 segundos
 ColorTip tip = new ColorTip(0, 2, someLabel, temporaryColor);
 tip.start();
&lt;/pre&gt;
* 
* Usa un subproceso demonio, de forma que esta clase no previene de que el programa 
* termine. No bloqueará el IGU.
*/</span>
<span class="keyword">final</span> <span class="keyword">class</span> ColorTip {
  
  <span class="comment">/**
  * Constructor. 
  *  
  * @param aInitialDelay número de segundos a esperar antes de cambiar el 
  * color de fondo de &lt;tt&gt;aComponent&lt;/tt&gt;, y debe estar en el rango de 0..60 (inclusive).
  * @param aActivationInterval número de segundos a mostrar &lt;tt&gt;aTempColor&lt;/tt&gt;, 
  * y debe estar en el rango de 1..60 (inclusive).
  * @param aComponent elemento del IGU cuyo color de fondo será cambiado.
  * @param aTempColor color de fondo cuyo &lt;tt&gt;aComponent&lt;/tt&gt; tomará por 
  * &lt;tt&gt;aActivationInterval&lt;/tt&gt; segundos.
  */</span>
  ColorTip (
    <span class="keyword">int</span> aInitialDelay, <span
            class="keyword">int</span> aActivationInterval, JComponent aComponent, Color aTempColor
   ) {
    Args.checkForRange(aInitialDelay, <span class="literal">0</span>, Consts.SECONDS_PER_MINUTE);
    Args.checkForRange(aActivationInterval, <span class="literal">1</span>, Consts.SECONDS_PER_MINUTE);
    Args.checkForNull(aTempColor);
    fInitialDelay = aInitialDelay;
    fActivationInterval = aActivationInterval;
    fComponent = aComponent;
    fTemporaryColor = aTempColor;
    fOriginalColor = aComponent.getBackground();
    fOriginalOpacity = aComponent.isOpaque();
  }

  <span class="comment">/**
  * Cambia temporalmente el color de fon del componente, sin interferir con 
  * el control del usuario del igu, y sin prevenir la terminación del programa.
  * 
  * &lt;P&gt;Si el color objetivo temporalmente es el mismo que el color de fondo actual, entonces 
  * no hace nada. (Esta condición ocurre cuando dos objetos &lt;tt&gt;ColorTip&lt;/tt&gt; están 
  * alterando el mismo elemento aproximadamente al mismo tiempo, de tal manera que se "superponen").
  */</span>
  <span class="keyword">void</span> start(){
    <span class="keyword">if</span> (isSameColor()) <span
            class="keyword">return</span>;
    <span class="comment">/*
     * El uso de un Thread de bajo nivel, en vez de una clase más moderna, no es habitual aquí.
     * Es aceptable ya que otras herramientas no son ideales para esta tarea, lo que es 
     * ir y venir DOS VECES (esperar, colorear, esperar, colorear) entre un subproceso de trabajo  
     * y el Subproceso de Envío de Eventos; eso no es una buena combinación para SwingWorker 
     * o javax.swing.Timer.
     */</span>
    Thread thread = <span class="keyword">new</span> Thread(<span
            class="keyword">new</span> Worker());
    thread.setDaemon(<span class="keyword">true</span>);
    thread.start();
  }
  
  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">int</span> fInitialDelay;
  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">int</span> fActivationInterval;
  <span class="keyword">private</span> <span class="keyword">final</span> JComponent fComponent;
  <span class="keyword">private</span> <span class="keyword">final</span> Color fTemporaryColor;
  <span class="keyword">private</span> <span class="keyword">final</span> Color fOriginalColor;
  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">int</span> fCONVERSION_FACTOR = Consts.MILLISECONDS_PER_SECOND;
  
  <span class="comment">/**
  * Almacena el valor original de esta propiedad opaca de fComponent.
  * 
  * Cambiar el color de fondo de un componente 
  * toma efecto solo si el componente está a cargo de dibujar su fondo.
  * Esto está definido por la propiedad opaca, que necesita estár en verdadero para que estos
  * cambios tengan efecto.
  *
  * &lt;P&gt;Si fComponent no es opaco, entonces esta propiedad es cambiada 
  * temporalmente por esta clase para cambiar el color de fondo.
  */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">boolean</span> fOriginalOpacity;
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> Logger fLogger = Util.getLogger(ColorTip.<span
            class="keyword">class</span>);

  <span class="comment">/**
  * Devuelve verdadero solo si fTemporaryColor es el mismo que fOriginalColor. 
  */</span>
  <span class="keyword">private</span> <span class="keyword">boolean</span> isSameColor(){
    <span class="keyword">return</span> fTemporaryColor.equals(fOriginalColor);
  }
  
  <span class="comment">/** 
   La suspensión realizada por esta clase NO se realiza en el subproceso de envío de eventos; 
   eso bloquearía la GUI.
  */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">class</span> Worker <span class="keyword">implements</span> Runnable {
    <span class="keyword">@Override</span> <span class="keyword">public</span> <span
            class="keyword">void</span> run(){
      <span class="keyword">try</span> {
        fLogger.fine(<span class="literal">"Pausado inicialmente..."</span>);
        Thread.sleep(fCONVERSION_FACTOR * fInitialDelay);
        EventQueue.invokeLater(<span class="keyword">new</span> ChangeColor());
        fLogger.fine(<span class="literal">"Activación de la Pausa..."</span>);
        Thread.sleep(fCONVERSION_FACTOR * fActivationInterval);
        EventQueue.invokeLater(<span class="keyword">new</span> RevertColor());
      }
      <span class="keyword">catch</span> (InterruptedException ex) {
        fLogger.severe(<span class="literal">"No puedo pausar."</span>);
      }
      fLogger.fine(<span class="literal">"Trabajador de color hecho."</span>);
    }
  }
  
  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">class</span> ChangeColor <span
            class="keyword">implements</span> Runnable {
    <span class="keyword">@Override</span> <span class="keyword">public</span> <span
            class="keyword">void</span> run(){
      <span class="keyword">if</span> (! fOriginalOpacity) {
        fComponent.setOpaque(<span class="keyword">true</span>);
      }
      fComponent.setBackground(fTemporaryColor);
    }
  }
  
  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">class</span> RevertColor <span
            class="keyword">implements</span> Runnable {
    <span class="keyword">@Override</span> <span class="keyword">public</span> <span
            class="keyword">void</span> run(){
      fComponent.setBackground(fOriginalColor);
      fComponent.setOpaque(fOriginalOpacity);
    }
  }
}
 
    </pre>
    <br />
    <p></p>
    <div class="topic-section" id="see-also-title">
      Vea También:
    </div>
    <div id="see-also" class="main-body">
      <a href="../swing/swing_149.html">Pantalla de Bienvenida</a><br />
      <a href="../swing/swing_160.html">Temporizador</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>