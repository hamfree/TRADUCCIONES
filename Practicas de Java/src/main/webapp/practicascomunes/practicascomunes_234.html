<!DOCTYPE html>
<!-- saved from url=(0056)http://www.javapractices.com/topic/TopicAction.do?Id=234 -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Usar un reloj de sistema falso</title>
<link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Búsqueda" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Usar un reloj de sistema falso</div>
    <br />
    <p>
      Cuando se prueba una aplicación, es a menudo útil definir una <i>reloj de sistema falso</i> para ejercitar el código que usa 
      fechas y horas.
    </p>
    <p>
      Mientras es siempre posible cambiar el reloj del sistema <i>directamente</i>, muchos ven ese estilo como indeseable:
    </p>
    <ul>
      <li>
        afecta a <i>todos</i> los programas que se ejecutan en una máquina, y no simplemente la aplicación que está siendo 
        comprobada
      </li>
      <li>puede llevar mucho tiempo y ser molesto cambiar rápidamente el reloj del sistema</li>
    </ul>
    <p>
      en lugar de cambiar el reloj del sistema, es posible definir un reloj del sistema <i>falso</i> simplemente para su 
      aplicación. En producción el reloj del sistema falso devuelve el tiempo normal. Durante la comprobación, el reloj del sistema 
      falso se cambia para devolver cualquier hora que necesite para una cobertura de prueba efectiva.
    </p>
    <p>
      Para este trabajo, necesita definir varias implementaciones de reloj diferentes, y ser capaz de intercambiarlos fácilmente. 
      Muchos elijirían usar una herramienta de inyección de dependencias para esto, o quizás un 
      <a href="../patrones/patrones_237.html">mecanismo de plug-in</a>.
    </p>
    <p>
      Para que esto funcione, <b>nunca debe hacer referencia al reloj del sistema predeterminado y la zona horaria directamente</b>, 
      evitando métodos tales como:
    </p>
    <ul>
      <li>
        <code>
          <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#currentTimeMillis()">System.currentTimeMillis()</a>
        </code>
      </li>
      <li>
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/time/LocalDateTime.html#now()">LocalDateTime.now()</a></code> 
        (y similares)
      </li>
      <li>
        el constructor predeterminado para la clase 
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/util/Date.html#Date()">Date</a></code> (que a su vez usa 
        <code>System.currentTimeMillis()</code>)
      </li>
    </ul>
    <b>Esto requiere algo de disciplina</b>, porque muchos ejemplos de código usan el reloj del sistema predeterminado (y la zona 
    horaria), y porque llamar a los métodos anteriores se ha vuelto habitual.
    <p>
      Posibles comportamientos para un reloj falso incluye:
    </p>
    <ul>
      <li>saltar hacia el futuro</li>
      <li>volver al pasado</li>
      <li>usar una fecha fija y una hora fija</li>
      <li>usar una fecha fija, pero dejar que el tiempo varíe</li>
      <li>incrementar en un segundo cada vez que 'mires' el rejol</li>
      <li>cambiar la <i>tasa</i> en la que pasa el tiempo, acelerando o desacelerando en un cierto factor</li>
      <li>utilizar el reloj normal del sistema sin alteraciones</li>
    </ul>
    <p>
      De acuerdo a sus necesidades, puede tener que usar el reloj del sistema falso en alguno o todas estos lugares:
    </p>
    <ul>
      <li>su código de aplicación</li>
      <li>su código que interactua con la base de datos</li>
      <li>su salida de registro</li>
      <li>sus clases del marco de trabajo</li>
    </ul>
    <p>
      <b>Ejemplos para Java 8</b>
    </p>
    <p>
      La clase <code><a href="https://docs.oracle.com/javase/10/docs/api/java/time/Clock.html">Clock</a></code> del paquete 
      <code>java.time</code> le permite crear un reloj de sistema falso. Es un método 
      <code>
        <a href="https://docs.oracle.com/javase/10/docs/api/java/time/Clock.html#fixed(java.time.Instant,java.time.ZoneId)">fijo</a>
      </code> que le permite crear rápidamente un tipo común de falso <code>Clock</code>, que simplemente devuelve un valor fijo en 
      una zona horaria dada. En general, necesitará extender la clase abstracta <code>Clock</code>, e implementar sus métodos 
      abstractos.
      <br />
    </p>
    <pre>
<span class="keyword">import</span> java.time.Clock;
<span class="keyword">import</span> java.time.Instant;
<span class="keyword">import</span> java.time.ZoneId;
<span class="keyword">import</span> java.util.Objects;

<span class="comment">/** 
 Incrementar en 1 segundo cada vez que mira el reloj.
 Comienza con el instante y la zona horaria del reloj del sistema predeterminado.
 
 Salida de ejemplo:
  2018-05-26T14:00:12.778Z
  2018-05-26T14:00:13.778Z
  2018-05-26T14:00:14.778Z
  2018-05-26T14:00:15.778Z
  2018-05-26T14:00:16.778Z
   
 @since Java 8.
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> ClockTicker <span class="keyword">extends</span> Clock {
  
  <span class="comment">/** Demostración simple del comportamiento de esta clase. */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
			class="keyword">void</span> main(String... args) {
    ClockTicker ticker = <span class="keyword">new</span> ClockTicker();
    log(ticker.instant());
    log(ticker.instant());
    log(ticker.instant());
    log(ticker.instant());
    log(ticker.instant());
  }
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">void</span> log(Object msg){
    System.out.println(Objects.toString(msg));
  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> ZoneId getZone() {
    <span class="keyword">return</span> DEFAULT_TZONE;
  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> Clock withZone(ZoneId zone) {
    <span class="keyword">return</span> Clock.fixed(WHEN_STARTED, zone);
  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> Instant instant() {
    <span class="keyword">return</span> nextInstant();
  }
  
  <span class="comment">//PRIVADO
</span>  <span class="keyword">private</span> <span class="keyword">final</span> Instant WHEN_STARTED = Instant.now();
  <span class="keyword">private</span> <span class="keyword">final</span> ZoneId DEFAULT_TZONE = ZoneId.systemDefault();
  <span class="keyword">private</span> <span class="keyword">long</span> count = <span
			class="literal">0</span>;
  
  <span class="keyword">private</span> Instant nextInstant() {
    ++count;
    <span class="keyword">return</span> WHEN_STARTED.plusSeconds(count);
  }
} 
    </pre>
    <br />
    <pre>
<span class="keyword">import</span> java.time.Clock;
<span class="keyword">import</span> java.time.Instant;
<span class="keyword">import</span> java.time.LocalDateTime;
<span class="keyword">import</span> java.time.ZoneId;
<span class="keyword">import</span> java.time.ZoneOffset;
<span class="keyword">import</span> java.util.Objects;

<span class="comment">/** 
 Establece la fecha-hora de inicio y la zona horaria, pero después
 permite que el tiempo varía normalmente.
 
 Salida de ejemplo:
  2018-12-25T05:00:00Z
  Dormir por 5 segundos...
  2018-12-25T05:00:05.005Z
  Hecho.

 @since Java 8.
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> ClockTimeTravel <span class="keyword">extends</span> Clock {
  
  <span class="comment">/** Demostración simple del comportamiento de esta clase. */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
			class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> InterruptedException {
    ClockTimeTravel timeTravel = <span class="keyword">new</span> ClockTimeTravel(
      LocalDateTime.parse(<span class="literal">"2018-12-25T00:00:00"</span>), ZoneOffset.of(<span
			class="literal">"-05:00"</span>)
    );
    log(timeTravel.instant());
    log(<span class="literal">"Dormir por 5 segundos..."</span>);
    Thread.currentThread().sleep(<span class="literal">5000</span>);
    log(timeTravel.instant());
    log(<span class="literal">"Hecho."</span>);
  }
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">void</span> log(Object msg){
    System.out.println(Objects.toString(msg));
  }
  
  <span class="keyword">public</span> ClockTimeTravel(LocalDateTime t0, ZoneOffset zoneOffset){
    <span class="keyword">this</span>.zoneOffset = zoneOffset;
    <span class="keyword">this</span>.t0LocalDateTime = t0;
    <span class="keyword">this</span>.t0Instant = t0.toInstant(zoneOffset);
    <span class="keyword">this</span>.whenObjectCreatedInstant = Instant.now();
  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> ZoneId getZone() {
    <span class="keyword">return</span> zoneOffset;
  }
  
  <span class="comment">/** El llamador necesita en realidad pasar un objeto ZoneOffset aquí. */</span>
  <span class="keyword">@Override</span> <span class="keyword">public</span> Clock withZone(ZoneId zone) {
    <span class="keyword">return</span> <span class="keyword">new</span> ClockTimeTravel(t0LocalDateTime, (ZoneOffset)zone);
  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> Instant instant() {
    <span class="keyword">return</span> nextInstant();
  }
  
  <span class="comment">//PRIVADO
</span>  
  <span class="comment">/** t0 es el momento que este objeto clock fue creado en Java-land. */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> Instant t0Instant;
  <span class="keyword">private</span> <span class="keyword">final</span> LocalDateTime t0LocalDateTime;
  
  <span class="keyword">private</span> <span class="keyword">final</span> ZoneOffset zoneOffset;
  <span class="keyword">private</span> <span class="keyword">final</span> Instant whenObjectCreatedInstant;
  
  <span class="comment">/** 
   Averigüe cuánto tiempo ha transcurrido entre el momento en que 
   se creó este objeto y el momento en que se llama a este método.
   Después, aplica esa diferencia a t0.
  */</span>
  <span class="keyword">private</span> Instant nextInstant() {
    Instant now = Instant.now();
    <span class="keyword">long</span> diff = now.toEpochMilli() - whenObjectCreatedInstant.toEpochMilli();
    <span class="keyword">return</span> t0Instant.plusMillis(diff);
  }
} 
    </pre>
    <p>
      <b>Ejemplo para Java &lt; 8</b>
    </p>
    <p>
      La interfaz <code>TimeSource</code> le permite definir varias implementaciones de un reloj del sistema falso:<br />
    </p>
    <pre>
<span class="keyword">public</span> <span class="keyword">interface</span> TimeSource {

  <span class="comment">/** Devuelve la hora del sistema. */</span>  
  <span class="keyword">long</span> currentTimeMillis();

} 
    </pre>
    Esta implementación imita un reloj del sistema que se ejecuta con un día de anticipación:
    <br />
    <pre>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> TimeSrc <span class="keyword">implements</span> TimeSource {

  <span class="comment">/** Un día antes de la hora real.*/</span>
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">long</span> currentTimeMillis() {
    <span class="keyword">return</span> System.currentTimeMillis() + ONE_DAY;
  }
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">final</span> <span class="keyword">long</span> ONE_DAY = <span
			class="literal">24</span>*<span class="literal">60</span>*<span
			class="literal">60</span>*<span class="literal">1000</span>;

} 
    </pre>
    Usando varias implementaciones <code>TimeSource</code>, puede imitar cualquier comportamiento deseados para un reloj de 
    sistema.
    <p>
      Es simple configurar el logger del KDJ para usar su reloj de sistema falso. Una personalización simple de 
      <a href="https://docs.oracle.com/javase/10/docs/api/java/util/logging/Formatter.html"><code>Formatter</code></a> puede usar 
      su <code>TimeSource</code> para alterar el tiempo de <code>LogRecord</code>:<br />
    </p>
    <pre>
<span class="keyword">import</span> java.util.logging.LogRecord;
<span class="keyword">import</span> java.util.logging.SimpleFormatter;

<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> SimpleFormatterTimeSource <span
			class="keyword">extends</span> SimpleFormatter {

  <span class="keyword">@Override</span> <span class="keyword">public</span> String format(LogRecord aLogRecord) {
    aLogRecord.setMillis(fTimeSource.currentTimeMillis());
    <span class="keyword">return</span> <span class="keyword">super</span>.format(aLogRecord);
  }

  <span class="keyword">private</span> TimeSource fTimeSource = BuildImpl.forTimeSource();
}
 
    </pre>
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\practicascomunes\practicascomunes_33.html">Use un marco de trabajo de pruebas (JUnit)</a><br />
      <a href="..\patrones\patrones_237.html">Factoría de Complemento</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>

  </body>
</html>