<!DOCTYPE html>
<!-- saved from url=(0056)http://www.javapractices.com/topic/TopicAction.do?Id=174 -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Comprobar usando el método main</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Búsqueda" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Comprobar usando el método main</div>
    <br />
    El método 
    <pre>
		<code>public static void main(String...){}</code>
    </pre>
    puede usarse para comprobar la operación de una clase. Probablemente debería usarse informalmente, ya que carece de 
    las características de una herramienta de pruebas más completa como <a href="practicascomunes_33.html">JUnit</a>.
    <p>
      Cuando se finalizan las comprobaciones, simplemente se puede borrar <code>main</code>, o puede ser mantenido para necesidades 
      futuras. Si se mantiene, es probablemente una buena idea cambiar su alcance a <code>private</code>, para evitar polucionar la 
      IPA de la calse con un método dirigido sólo al desarrollo. Por supuesto, si <code>main</code> necesitsa ser ejecutado de 
      nuevo más tarde, necesitará cambiar temporalmente su alcance de vuelta a <code>public</code>.
    </p>
    <p>
      <b>Ejemplo</b>
    </p>
    <p>
      Aquí, <code>SplashScreen.main</code> ejercita la visualización de una pantalla de bienvenida. Es colocada en la parte más 
      inferior de la clase, ya que está pensada solo como una herramienta de desarrollo. El carácter informal de este 
      <code>main</code> se refleja en la llamada a <code>Thread.sleep</code>, que simplemente pierde el tiempo por unos pocos 
      segundos. Hacer esto en una aplicación real sería estúpido, ya que el propósito de una pantalla de bienvenida es dar la 
      ilusión de una retroalimentación rápida. En la aplicación real, <code>SplashScreen</code> se elimina no después de un número 
      fino de segundos, sino después de la aparición de la ventana principal.<br />
    </p>
    <pre>
<span class="keyword">package</span> hirondelle.stocks.main;

<span class="keyword">import</span> java.awt.*;
<span class="keyword">import</span> java.net.URL;
<span class="keyword">import</span> java.awt.image.ImageObserver;

<span class="comment">/**
* Presenta un gráfico simple al usuario hasta lanzar la aplicación, para 
* proporcionar una respuesta inicial más rápida de la que es posible con la ventana principal. 
* 
* &lt;P&gt;Adaptaado de un 
* &lt;a href=http://developer.java.sun.com/developer/qow/archive/24/index.html&gt;item&lt;/a&gt; 
* en la Sun's Java Developer Connection.
*
* &lt;P&gt;Esta pantalla de bienvenida aparece dentro de acerca 2.5 segundos en una máquina de desarrollo. La pantalla 
* principal toma sobre 6.0 segundos en cargarse, así que el uso de una pantalla 
* bienvenida reduce el retraso de visualización inicial en aproximadamente un 55 por ciento.
* 
* &lt;P&gt;Cuando KDJ 6+ esté disponible, se debe usar su clase java.awt.SplashScreen en vez de 
* esta clase.
*/</span>
<span class="keyword">final</span> <span class="keyword">class</span> SplashScreen <span
            class="keyword">extends</span> Frame {

  <span class="comment">/**
  * Construye usando una imagen para la pantalla de bienvenida.
  *  
  * @param aImageId debe tener contenido, y es usada por 
  * {@link Class#getResource(java.lang.String)} para recuperar la imagen de la pantalla de bienvenida.
  */</span>
  SplashScreen(String aImageId) {
    <span class="comment">/* 
    * Nota de Implementación
    * Args.checkForContent no se llama aquí, en un intento de minimizar 
    * la carga de clases.
    */</span>
    <span class="keyword">if</span> (aImageId == <span class="keyword">null</span> || aImageId.trim().length() == <span
            class="literal">0</span>){
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span
            class="literal">"El Id de imagen not tiene contenido."</span>);
    }
    fImageId = aImageId;
  }
   
  <span class="comment">/**
  * Muestra la pantalla de bienvenida al usuario final.
  *
  * &lt;P&gt;Una vez este metodo vuelve, se realiza la pantalla de bienvenida
  * lo que significa que casi todo el trabajo en la pantalla de bienvenida debe proceder a través 
  * del subproceso de despacho de eventos. En particular, cualquier llamada a &lt;tt&gt;dispose&lt;/tt&gt; para la 
  * pantalla de bienvenida debe ser realizada en el subproceso de despacho de eventos.
  */</span>
  <span class="keyword">void</span> splash(){
    initImageAndTracker();
    setSize(fImage.getWidth(NO_OBSERVER), fImage.getHeight(NO_OBSERVER));
    center();
    fMediaTracker.addImage(fImage, IMAGE_ID);
    <span class="keyword">try</span> {
      fMediaTracker.waitForID(IMAGE_ID);
    }
    <span class="keyword">catch</span>(InterruptedException ex){
      System.out.println(<span class="literal">"No se puede rastear la carga de la imagen."</span>);
    }
    SplashWindow splashWindow = <span class="keyword">new</span> SplashWindow(<span
            class="keyword">this</span>,fImage);
  }
  
  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> <span class="keyword">final</span> String fImageId;
  <span class="keyword">private</span> MediaTracker fMediaTracker;
  <span class="keyword">private</span> Image fImage;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> ImageObserver NO_OBSERVER = <span
            class="keyword">null</span>; 
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> <span class="keyword">int</span> IMAGE_ID = <span
            class="literal">0</span>;

  <span class="keyword">private</span> <span class="keyword">void</span> initImageAndTracker(){
    fMediaTracker = <span class="keyword">new</span> MediaTracker(<span
            class="keyword">this</span>);
    URL imageURL = SplashScreen.<span class="keyword">class</span>.getResource(fImageId);
    fImage = Toolkit.getDefaultToolkit().getImage(imageURL);
  }

  <span class="comment">/**
  * Centra el marco en la pantalla.
  *
  *&lt;P&gt;Este servicio de centrado es más o menos en {@link hirondelle.stocks.util.ui.UiUtil}; 
  * esta duplicación se justifica solo porque el uso de 
  * {@link hirondelle.stocks.util.ui.UiUtil} implicaría más carga de clases, lo que 
  * no es deseable para una pantalla de presentación.
  */</span>
  <span class="keyword">private</span> <span class="keyword">void</span> center(){
    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
    Rectangle frame = getBounds();
    setLocation((screen.width - frame.width)/<span class="literal">2</span>, (screen.height - frame.height)/<span
            class="literal">2</span>);
  }
 
  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">class</span> SplashWindow <span
            class="keyword">extends</span> Window {
    SplashWindow(Frame aParent, Image aImage) {
       <span class="keyword">super</span>(aParent);
       fImage = aImage;
       setSize(fImage.getWidth(NO_OBSERVER), fImage.getHeight(NO_OBSERVER));
       Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
       Rectangle window = getBounds();
       setLocation((screen.width - window.width) / <span class="literal">2</span>,(screen.height - window.height)/<span
            class="literal">2</span>);
       setVisible(<span class="keyword">true</span>);
    }
    <span class="keyword">@Override</span> <span class="keyword">public</span> <span
            class="keyword">void</span> paint(Graphics graphics) {
      <span class="keyword">if</span> (fImage != <span class="keyword">null</span>) {
        graphics.drawImage(fImage,<span class="literal">0</span>,<span
            class="literal">0</span>,<span class="keyword">this</span>);
      }
    }
    <span class="keyword">private</span> Image fImage;
  }
  
  <span class="comment">/**
  * La prueba del desarrollador muestra la pantalla de bienvenida para una longitud fija de
  * tiempo, sin iniciar la aplicación completa.
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> main(String... aArgs){
    SplashScreen splashScreen = <span class="keyword">new</span> SplashScreen(<span
            class="literal">"StocksMonitor.gif"</span>);
    splashScreen.splash();
    <span class="keyword">try</span> {
      Thread.sleep(<span class="literal">2000</span>);
    }
    <span class="keyword">catch</span>(InterruptedException ex) {
      System.out.println(ex);
    }
    System.exit(<span class="literal">0</span>);
  }
}
 
    </pre>
    <br />
    <p></p>
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\practicascomunes\practicascomunes_33.html">Use un marco de trabajo de pruebas (JUnit)</a><br />
      <a href="..\swing\swing_149.html">Pantalla de Bienvenida</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>