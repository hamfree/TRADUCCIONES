<!DOCTYPE html>
<!-- saved from url=(0055)http://www.javapractices.com/topic/TopicAction.do?Id=91 -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Método de clarificación</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Search" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Método de clarificación</div>
    <br />
    La estructura de un método a menudo se puede hacer más clara dividiéndolo en métodos más pequeños. Martin Fowler, autor de 
    <i>Refactorización</i>, es un entusiasta defensor de este estilo.
    <p>
      Refactorizar un método original en piezas más pequeñas tiene varias ventajas:
    </p>
    <ul>
      <li>
        permite que el método original se mantenga en un nivel más alto de abstracción, lo que siempre incrementa la legibilidad
      </li>
      <li>hace el método original más simple</li>
      <li>reduce el número de variables locales en el método original</li>
      <li>permite que los nombres de los métodos automáticamente documenten las intenciones del código</li>
    </ul>
    Algunas veces se coloca un comentario al principio de un fragmento de código, explicando su intención. Si en su lugar se usa un 
    método de aclaración, entonces el fragmento de código se refactoriza en su propio método, mientras que el comentario en sí 
    es reemplazado por una llamada a un método bien nombrado. 
    "<i>Cuando un comentario crece, se convierte en una llamada a un método.</i>".
    <p>
      <b>Ejemplo</b>
    </p>
    <p>
      Aquí, el método <code>parseSearchText</code>, que era originalmente monolítico, ha sido refactorizado para llamar a varios 
      métodos <code>private</code> que realizan tareas simples y muy bien definidas.
    </p>
    <p>
      Las condiciones booleanas pueden a menudo beneficiarse de ser colocadas en su propio método. Aquí, <code>isDoubleQuote</code>,
      <code>isCommonWord</code>, y <code>textHasContent</code> son todos ejemplos de esto.<br />
    </p>
    <pre>
<span class="keyword">import</span> java.util.*;

<span class="comment">/**
* El usuario introduce texto en una caja de búsqueda. Esta clase se usa 
* para analizar ese texto en términos de búsqueda específicos (o tokens).
* Elimina las palabras comunes, y permite el entrecomillado del texto, usando 
* comillas dobles.
* JDK 7+.
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> SearchBoxParser {

  <span class="keyword">public</span> <span class="keyword">static</span> <span
			class="keyword">void</span> main(String... aArguments) {
    SearchBoxParser parser = <span class="keyword">new</span> SearchBoxParser(<span
			class="literal">"mars venus \"milky way\" sun"</span>);
    Set&lt;String&gt; tokens = parser.parseSearchText();
    <span class="comment">//muestra los tokens
</span>    System.out.println(tokens);
  }

  <span class="comment">/**
  * @param aSearchText es no nulo, pero puede no tener contenido,
  * y representa lo que el usuario ha introducido en la caja de búsqueda.
  */</span>
  <span class="keyword">public</span> SearchBoxParser(String aSearchText) {
    <span class="keyword">if</span> (aSearchText == <span
			class="keyword">null</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span
			class="literal">"El Texto de Búsqueda no puede ser nulo."</span>);
    }
    fSearchText = aSearchText;
  }

  <span class="comment">/**
  * Analiza la entrada del usuario en la caja de búsqueda en un conjunto de tokens de Strings.
  *
  * @return un Conjunto de Strings, uno para cada palabra en fSearchText; aquí "palabra"
  * se define como una sola palabra rodeada de espacios en blanco, o como una serie 
  * de palabras rodeadas de comillas dobles, "como esto"; también, palabras 
  * muy comunes (y, el, etc.) no cualifican como posibles objetivos de búsqueda.
  */</span>
  <span class="keyword">public</span> Set&lt;String&gt; parseSearchText() {
    Set&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();

    <span class="keyword">boolean</span> returnTokens = <span
			class="keyword">true</span>;
    String currentDelims = fWHITESPACE_AND_QUOTES;
    StringTokenizer parser = <span class="keyword">new</span> StringTokenizer(
      fSearchText, currentDelims, returnTokens
    );

    String token = <span class="keyword">null</span>;
    <span class="keyword">while</span> (parser.hasMoreTokens()) {
      token = parser.nextToken(currentDelims);
      <span class="keyword">if</span> (!isDoubleQuote(token)){
        addNonTrivialWordToResult(token, result);
      }
      <span class="keyword">else</span> {
        currentDelims = flipDelimiters(currentDelims);
      }
    }
    <span class="keyword">return</span> result;
  }

  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> String fSearchText;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">final</span> Set&lt;String&gt; fCOMMON_WORDS = <span
			class="keyword">new</span> LinkedHashSet&lt;&gt;();
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">final</span> String fDOUBLE_QUOTE = <span
			class="literal">"\""</span>;

  <span class="comment">//the parser flips between these two sets of delimiters
</span>  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">final</span> String fWHITESPACE_AND_QUOTES = <span
			class="literal">" \t\r\n\""</span>;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">final</span> String fQUOTES_ONLY =<span
			class="literal">"\""</span>;

  <span class="comment">/**Palabras muy comunes que se excluyen de las búsquedas.*/</span>
  <span class="keyword">static</span> {
    fCOMMON_WORDS.add(<span class="literal">"a"</span>);
    fCOMMON_WORDS.add(<span class="literal">"y"</span>);
    fCOMMON_WORDS.add(<span class="literal">"ser"</span>);
    fCOMMON_WORDS.add(<span class="literal">"para"</span>);
    fCOMMON_WORDS.add(<span class="literal">"desde"</span>);
    fCOMMON_WORDS.add(<span class="literal">"tiene"</span>);
    fCOMMON_WORDS.add(<span class="literal">"i"</span>);
    fCOMMON_WORDS.add(<span class="literal">"en"</span>);
    fCOMMON_WORDS.add(<span class="literal">"es"</span>);
    fCOMMON_WORDS.add(<span class="literal">"eso"</span>);
    fCOMMON_WORDS.add(<span class="literal">"de"</span>);
    fCOMMON_WORDS.add(<span class="literal">"sobre"</span>);
    fCOMMON_WORDS.add(<span class="literal">"hacia"</span>);
    fCOMMON_WORDS.add(<span class="literal">"el"</span>);
  }

  <span class="comment">/**
  * Úselo para determinar si una palabra particular introducida en la 
  * caja de búsqueda debe ser descartada de la búsqueda.
  */</span>
  <span class="keyword">private</span> <span class="keyword">boolean</span> isCommonWord(String aSearchTokenCandidate){
    <span class="keyword">return</span> fCOMMON_WORDS.contains(aSearchTokenCandidate);
  }

  <span class="keyword">private</span> <span class="keyword">boolean</span> textHasContent(String aText){
    <span class="keyword">return</span> (aText != <span class="keyword">null</span>) &amp;&amp; (!aText.trim().equals(<span
			class="literal">""</span>));
  }

  <span class="keyword">private</span> <span class="keyword">void</span> addNonTrivialWordToResult(String aToken, Set&lt;String&gt; aResult){
    <span class="keyword">if</span> (textHasContent(aToken) &amp;&amp; !isCommonWord(aToken.trim())) {
      aResult.add(aToken.trim());
    }
  }

  <span class="keyword">private</span> <span class="keyword">boolean</span> isDoubleQuote(String aToken){
    <span class="keyword">return</span> aToken.equals(fDOUBLE_QUOTE);
  }

  <span class="keyword">private</span> String flipDelimiters(String aCurrentDelims){
    String result = <span class="keyword">null</span>;
    <span class="keyword">if</span> (aCurrentDelims.equals(fWHITESPACE_AND_QUOTES)){
      result = fQUOTES_ONLY;
    }
    <span class="keyword">else</span> {
      result = fWHITESPACE_AND_QUOTES;
    }
    <span class="keyword">return</span> result;
  }
} 
    </pre>
    <br />
    <p></p>
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\practicascomunes\practicascomunes_227.html">Evite los estilos de error básicos</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>