<!DOCTYPE html>
<!-- saved from url=(0056)http://www.javapractices.com/topic/TopicAction.do?Id=261 -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Anide clases con cuidado</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Search" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Anide clases con cuidado</div>
    <br />
    In Java, you can nest classes within other classes. This feature is very useful when you need it, but it can be easily abused.
    <p>
      When you have a choice, you should declare your nested classes as <code>static</code>. The reason is that non-static nested 
      classes (inner classes) are tightly coupled to the enclosing parent, while static nested classes aren't. This extra coupling 
      can sometimes cause problems. In general, static nested classes are safer than non-static ones, and less prone to error.
    </p>
    <p>
      Secondly, you should very rarely use deep levels of nesting.
    </p>
    <p>
      The terminology for nested classes is a bit confusing. Here's a reminder of the hierarchy:
    </p>
    <pre>
  <b>nested</b> class
  <b>static</b>
  <b>inner</b> class (non-static)
    regular, not within a method or constructor
    inside a method or constructor
      <b>anonymous</b>
      <b>local</b>
    </pre>
    Some more reminders:
    <ul>
      <li>static - not tied to a parent instance (but can see the private fields of a parent, if it has an object reference)</li>
      <li>non-static (inner class) - always tied to a parent instance</li>
      <li>anonymous - no access modifiers; no <code>extends</code> or <code>implements</code>; no constructor</li>
      <li>
        local - never static; no access modifiers; can access only <code>final</code> items that are in scope; this is the rarest 
        form of nested class.
      </li>
    </ul>
    Here's a class which sketches all the different types of nested class:
    <br />
    <pre>
<span class="keyword">import</span> java.math.BigDecimal;
<span class="keyword">import</span> java.util.Date;
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> java.util.Timer;
<span class="keyword">import</span> java.util.TimerTask;

<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> MakeMovie {

  <span class="comment">/**
    Static, since has no need of being attached to a parent instance.
   */</span>
  <span class="keyword">static</span> <span class="keyword">final</span> <span
			class="keyword">class</span> Actor {
    Actor(String aName){
      fName = aName;
    }
    String getName(){ 
      <span class="keyword">return</span> fName; 
    }
    <span class="keyword">private</span> String fName;
  }

  <span class="comment">/**
    Non-static (inner) class, since casting will need to know about the 
    movie's data - its name, director, and budget.
  */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> Casting {
    <span class="keyword">void</span> chooseFrom(List&lt;Actor&gt; aActors){
      <span class="comment">//can reference the parent's data directly:
</span>      <span class="keyword">if</span>(fDirector.equals(<span
			class="literal">"Stanley Kubrick"</span>)){
        <span class="comment">//elided...
</span>      }
    }
    List&lt;Actor&gt; getSelectedCast(){ 
      <span class="keyword">return</span> fSelectedCast; 
    }
    <span class="comment">//static void doThis(){} //does not compile, since static
</span>    <span class="keyword">private</span> List&lt;Actor&gt; fSelectedCast;
  }
  
  <span class="keyword">void</span> wrapParty(){
    Timer timer = <span class="keyword">new</span> Timer();
    <span class="comment">//anonymous class - the implementation of TimerTask
</span>    <span class="comment">//this is usually how anonymous classes are used - to define a single method
</span>    timer.schedule(
      <span class="keyword">new</span> TimerTask(){ 
        <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> run() {
          <span class="comment">//elided...
</span>        };
      },
      <span class="keyword">new</span> Date()
    );
  }

  <span class="keyword">void</span> shootScene(<span class="keyword">final</span> <span
			class="keyword">int</span> aSceneNumber){
    <span class="comment">//local class - this style seems to be rather rare
</span>    <span class="keyword">class</span> Camera {
      <span class="keyword">void</span> shoot(){
        <span class="comment">//won't compile unless aSceneNumber is final:
</span>        System.out.println(aSceneNumber);
      }
    }
    Camera camera = <span class="keyword">new</span> Camera();
    camera.shoot();
  }
  
  <span class="comment">//elided...
</span>
  <span class="keyword">private</span> String fName;
  <span class="keyword">private</span> String fDirector;
  <span class="keyword">private</span> BigDecimal fBudget;

} 
    </pre>
    <p></p>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>