<!DOCTYPE html>
<!-- saved from url=(0056)http://www.javapractices.com/topic/TopicAction.do?Id=264 -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Prefiera las clases de fecha modernas</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Search" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Prefiera las clases de fecha modernas</div>
    <br /> 
    La clase <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Date.html">java.util.Date</a> y su clase 
    relacionada <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Calendar.html">Calendar</a> han estado en el KDJ por 
    mucho tiempo. Sin embargo, estas viejas clases de fechas sufren de un número de defectos en su diseño.
    <p>
      Si es posible, debería estar usando las clases más nuevas de 
      <a href="https://docs.oracle.com/javase/10/docs/api/java/time/package-summary.html">java.time</a>. Estas fueron 
      <a href="https://docs.oracle.com/javase/tutorial/datetime/index.html">inroducidas en el KDJ 8</a>.
    </p>
    <p>Recordatorios:</p>
    <ul>
      <li>puede convertir fechas viejas usando <code>java.util.Date.toInstant()</code> </li>
      <li>
        cuando trabaja con fechas como cadenas, los distintos parse y format lanza excepciones <em>no comprobadas</em>
      </li>
      <li><code>DayOfWeek.getValue()</code> 1..7 corresponden a Lunes-a-Domingo</li>
      <li>las distintas enumeraciones definidas por el paquete son buenos candidatos para importaciones estáticas</li>
      <li>la clase <code>Clock</code> está pensada solo para pruebas</li>
      <li>JDBC usa <code>getObject/setObject</code> para tratar con estas nuevas clases</li>
    </ul>
    <p>
      Las clases <code> java.time </code> modelan el tiempo con una precisión de nanosegundos. Sin embargo, muchos relojes del 
      sistema tienen una precisión de unos pocos milisegundos, así que tenga cuidado con la falsa precisión. (Cómo una librería 
      modela el tiempo es independiente de la precisión de su reloj de sistema).
    </p>
    <p>
      Es siempre útil recordar que <em>el desplazamiento y la zona horaria son dos ideas diferentes</em>. Es un error tratarlos de 
      la misma forma. Un desplazamiento es una diferencia <em>fija</em> del Tiempo Universal (UT). En general, una zona horaria no 
      es lo mismo que un desplazamiento. En Norteamérica y Europa, es común que una zona horaria consista de <em>dos</em> 
      desplazamientos, y una regla para cambiar entre ellos. Puede pensar que la diferencia es trivial, pero mantener clara la 
      diferencia es importante para comprender lo que está sucediendo.
    </p>
    <p>
      Por lo tanto, en <code>java.time</code>, tiene tanto <code>ZonedDateTime</code> como <code>OffsetDateTime</code>. 
      (¡La clase llamada <code>ZoneOffset</code> aumenta la confusión! Debería llamarse simplemente <code>Offset</code>).
    </p>
    <p>
      <b>Ejemplo</b>
    </p>
    <p>
      Aquí tiene un ejemplo de usar <code>java.time</code>.<br />
    </p>
    <pre>
<span class="comment">/* Tenga en cuenta las importaciones estáticas. */</span>
<span class="keyword">import</span> <span class="keyword">static</span> java.time.DayOfWeek.MONDAY;
<span class="keyword">import</span> <span class="keyword">static</span> java.time.temporal.TemporalAdjusters.firstDayOfMonth;
<span class="keyword">import</span> <span class="keyword">static</span> java.time.temporal.TemporalAdjusters.next;

<span class="keyword">import</span> java.time.Instant;
<span class="keyword">import</span> java.time.LocalDate;
<span class="keyword">import</span> java.time.LocalDateTime;
<span class="keyword">import</span> java.time.Month;
<span class="keyword">import</span> java.time.ZoneId;
<span class="keyword">import</span> java.time.ZonedDateTime;
<span class="keyword">import</span> java.time.format.DateTimeFormatter;
<span class="keyword">import</span> java.time.temporal.ChronoUnit;
<span class="keyword">import</span> java.util.Objects;
<span class="keyword">import</span> java.util.Set;
<span class="keyword">import</span> java.util.TreeSet;

<span class="comment">/** 
 Las clases date-time agregadas en el KDJ 8.
 https://docs.oracle.com/javase/tutorial/datetime/iso/overview.html
 http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> PlayDate {
  
  <span class="keyword">public</span> <span class="keyword">static</span> <span
			class="keyword">void</span> main(String... args) {
    PlayDate pd = <span class="keyword">new</span> PlayDate();
    pd.makeDate();
    pd.makeDateTime();
    pd.format();
    pd.alterField();
    pd.conversions();
    pd.calc();
    <span class="comment">//pd.listAllTimeZones();
</span>    log(<span class="literal">"Hecho."</span>);
  }
  
  <span class="keyword">void</span> makeDate(){
    LocalDate date1 = LocalDate.parse(<span class="literal">"2017-12-31"</span>);
    LocalDate date2 = LocalDate.now();
    LocalDate date3 = LocalDate.of(<span class="literal">2017</span>, <span
			class="literal">12</span>, <span class="literal">31</span>);
    LocalDate date4 = LocalDate.of(<span class="literal">2017</span>, Month.DECEMBER, <span
			class="literal">31</span>);
    LocalDate date5 = LocalDate.now(ZoneId.of(<span class="literal">"America/New_York"</span>));
  }
  
  <span class="keyword">void</span> makeDateTime(){
    <span class="comment">//puede llegar a los nanosegundos, pero no más lejos
</span>    <span class="comment">//tenga en cuenta el molesto separador 'T'
</span>    LocalDateTime a = LocalDateTime.parse(<span class="literal">"2017-12-31T23:59:59.123456789"</span>);
    <span class="comment">//esto falla; necesita pasar la 'T'
</span>    <span class="comment">//LocalDateTime b = LocalDateTime.parse("2017-12-31 23:59:59.123456789");
</span>    LocalDateTime b = LocalDateTime.now();
    LocalDateTime c = LocalDateTime.of(<span class="literal">2017</span>,<span
			class="literal">12</span>,<span class="literal">31</span>,<span
			class="literal">18</span>,<span class="literal">59</span>,<span
			class="literal">59</span>);
    LocalDateTime d = LocalDateTime.of(<span class="literal">2017</span>,<span
			class="literal">12</span>,<span class="literal">31</span>,<span
			class="literal">18</span>,<span class="literal">59</span>,<span
			class="literal">59</span>,<span class="literal">1</span>); <span
			class="comment">//con los nanos al final
</span>  }
  
  <span class="keyword">void</span> listAllTimeZones(){
    Set&lt;String&gt; ids = ZoneId.getAvailableZoneIds();
    TreeSet&lt;String&gt; ordered = <span class="keyword">new</span> TreeSet&lt;&gt;(ids);
    ordered.stream().forEach(id -&gt; log(id));
  }
  
  <span class="keyword">void</span> format(){
    LocalDate date = someDate();
    LocalDateTime dateTime = someDateTime();
    
    <span class="comment">//2017-12-31
</span>    demoFormat(DateTimeFormatter.ISO_LOCAL_DATE, date);
    
    <span class="comment">//2017-12-31T23:59:59 (molestia: la 'T' en el medio)
</span>    demoFormat(DateTimeFormatter.ISO_LOCAL_DATE_TIME, dateTime); 
    
    <span class="comment">//2017-12-31 23:59:59
</span>    demoFormat(DateTimeFormatter.ofPattern(<span class="literal">"yyyy-MM-dd HH:mm:ss"</span>), dateTime); 
  }
  
  <span class="comment">/** El uso de esta fecha única resalta algunos aspectos del formato. */</span>
  LocalDate someDate(){
    <span class="keyword">return</span> LocalDate.of(<span
			class="literal">2017</span>, <span class="literal">12</span>, <span
			class="literal">31</span>);
  }
  
  LocalDateTime someDateTime(){
    <span class="keyword">return</span> LocalDateTime.of(<span
			class="literal">2017</span>, <span class="literal">12</span>, <span
			class="literal">31</span>, <span class="literal">23</span>, <span
			class="literal">59</span>, <span class="literal">59</span>);
  }
  
  <span class="keyword">void</span> demoFormat(DateTimeFormatter formatter, LocalDate date){
    log(formatter.format(date));
  }
  
  <span class="keyword">void</span> demoFormat(DateTimeFormatter formatter, LocalDateTime dateTime){
    log(formatter.format(dateTime));
  }

  <span class="comment">/** 
   La mayoría de las clases java.time son inmutables.
   Para alterar un campo de fecha-tiempo a algún nuevo valor, llama un método que 
   devuelve un nuevo objeto que tiene el estado deseado. 
  */</span>
  <span class="keyword">void</span> alterField(){
    LocalDate today = someDate();
    LocalDate tomorrow = today.plusDays(<span class="literal">1</span>);
    <span class="comment">//usar importaciones estáticas le permite evitar el estilo más detallado:
</span>    <span class="comment">//  LocalDate startOfMonth = today.with(TemporalAdjusters.firstDayOfMonth());
</span>    <span class="comment">//  LocalDate followingMonday = today.with(next(DayOfWeekWeek.MONDAY));
</span>    LocalDate startOfMonth = today.with(firstDayOfMonth());
    LocalDate followingMonday = today.with(next(MONDAY));
  }
  
  <span class="keyword">void</span> conversions(){
    java.util.Date now = <span class="keyword">new</span> java.util.Date();
    Instant instant = now.toInstant(); <span class="comment">//toInstant() es un nuevo método de conversión
</span>    
    <span class="comment">//necesita usar una zona horaria:
</span>    LocalDateTime dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
    ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, ZoneId.systemDefault());
    
    LocalDateTime dateTime2 = zonedDateTime.toLocalDateTime(); <span
			class="comment">//convierte a la forma no-tz
</span>    assert(dateTime.equals(dateTime2));
  }
  
  <span class="keyword">void</span> calc(){
    LocalDate a = LocalDate.parse(<span class="literal">"1900-01-01"</span>);
    LocalDate b = LocalDate.parse(<span class="literal">"1999-12-31"</span>);
    Long daysBetween = ChronoUnit.DAYS.between(a, b);
    log(<span class="literal">"Número de días en el siglo 20: "</span> + (daysBetween + <span
			class="literal">1</span>));
    
    LocalDate now = LocalDate.now();
    <span class="keyword">int</span> year = now.getYear();
    <span class="keyword">if</span> (now.getMonthValue() == <span
			class="literal">12</span> &amp;&amp; now.getDayOfMonth() &gt; <span
			class="literal">25</span>){
      year = year + <span class="literal">1</span>;
    }
    LocalDate christmas = LocalDate.of(year, <span class="literal">12</span>, <span
			class="literal">25</span>);
    log(<span class="literal">"Días hasta Navidad: "</span> + ChronoUnit.DAYS.between(now, christmas));
  }
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">void</span> log(Object thing){
    <span class="comment">//tenga en cuenta el estilo amigable con los nulls:
</span>    System.out.println(Objects.toString(thing));
  }
}
 
    </pre>
    <br />
    <p></p>
    <p></p>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>