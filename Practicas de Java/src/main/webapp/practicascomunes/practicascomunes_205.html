<!DOCTYPE html>
<!-- saved from url=(0056)http://www.javapractices.com/topic/TopicAction.do?Id=205 -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Empaquete por funcionalidad, no por capa</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Búsqueda" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Empaquete por funcionalidad, no por capa</div>
    <br />
    La primera cuestión al construir una aplicación es <em>"¿Cómo la divido en paquetes?"</em>. Para <em>aplicaciones típicas de 
      negocios</em>, parecer haber dos formas de responder a esta cuestión.
    <h3>
      Paquete por Característica
    </h3>
    <i>Paquete-por-característica</i> usa paquetes para reflejar el conjunto de características. Intenta colocar todos los 
    elementos  relacionados con una única característica ( y <em>solo</em> esa característica). en un único directorio/paquete. 
    Estos resultados en paquetes con alta cohesión y alta modularidad, y con acoplamiento mínimo entre paqeutes. Los elementos que 
    trabajan en estrecha colaboración se colocan uno al lado de otro. No están repartidos por toda la aplicación. Es también 
    interesante notar que, <em>en algunos casos</em>, eliminar una característica puede reducirse a una única operación - borrar un 
    directorio. (Las operaciones de eliminación pueden considerarse una buena prueba de la máxima modularidad: un elemento tiene la 
    máxima modularidad solo si se puede eliminar en una sola operación).
    <p>
      En paquete-por-característica, los nombres de los paquetes se corresponde con aspectos importantes, de alto nivel del dominio 
      del problema. Por ejemplo, una aplicación de prescripción de medicamentos podría tener estos paquetes:
    </p>
    <ul>
      <li><code>com.app.doctor</code></li>
      <li><code>com.app.drug</code></li>
      <li><code>com.app.patient</code></li>
      <li><code>com.app.presription</code></li>
      <li><code>com.app.report</code></li>
      <li><code>com.app.security</code></li>
      <li><code>com.app.webmaster</code></li>
      <li><code>com.app.util</code></li>
      <li>etcetera...</li>
    </ul>
    Cada paquete usualmente contiene solo los elementos relaciones con esa característica particular, y no otras características. 
    Por ejemplo, el paquete <code>com.app.doctor</code> podría contener estos elementos:
    <ul>
      <li><code>DoctorAction.java</code> - un objeto de acción o controlador</li>
      <li><code>Doctor.java</code> - un Objeto de Modelo</li>
      <li><code>DoctorDAO.java</code> - Un Objeto de Acceso a Datos</li>
      <li>elementos de la base de datos (Sentencias SQL)</li>
      <li>elementos de la interfaz de usuarios (quizás una JSP, en el caso de una aplicación web)</li>
    </ul>
    <p>
      Es importante notar que un paquete puede contener no simplemente código Java, sino otros ficheros también. De hecho, para que 
      el paquete-por-característica funcione realmente como se desea, <em>todos</em> los elementos relacionados con una 
      característica dada - desde la interfaz de usuario, al código Java, a los elementos de bases de datos - deben ser colocados 
      en un directorio dedicado a esa característica (y solo a esa característica).
    </p>
    <p>
      <em>En algunos casos</em>, un paquete/funcionalidad no será usada por cualquier otra característica en la aplicación. Si ese 
      es el caso, puede ser eliminado simplemente eliminando el directorio. Si de hecho lo utiliza alguna otra función, su 
      eliminación no será tan simple como una sola operación de eliminación.
    </p>
    <p>
      Es decir, la idea de paquete-por-característica no implica que un paquete no pueda nunca usar elementos que pertenezcan a 
      otros paquetes. Más bien, paquete-por-función <b>prefiere agresivamente el paquete privado como el alcance predeterminado</b>, 
      y solo aumenta el alcance de un elemento a público cuando es necesario.
    </p>
    <h3>
      Paquete por Capa
    </h3>
    El estilo de la competencia <i>paquete-por-capa</i> es diferente. En paquete-por-capa, los paquetes de nivel más alto reflejan 
    las diversas "capas" de la aplicación, en vez de las características, como en:
    <ul>
      <li><code>com.app.action</code></li>
      <li><code>com.app.model</code></li>
      <li><code>com.app.dao</code></li>
      <li><code>com.app.util</code></li>
    </ul>
    Aquí, cada funcionalidad tiene su implementación dispersada sobre múltiples directorios, en lo que podría llamarse libremente 
    "categorías de implementación". Cada directorio contiene elementos que usualmente no están relacionados estrechamente entre 
    ellos. Estos resulta en paquetes con <b>baja cohesión y baja modularidad</b>, con acople alto entre paquetes. Como resultado, 
    editar una característica o funcionalidad involucra la edición de archivos a través de diferentes directorios. Además, eliminar 
    una característica o funcionalidad casi nunca puede ser realizada en una única operación.
    <h3>
      Recomendación: Use Paquetes por Características/Funcionalidades
    </h3>
    <em>Para las aplicaciones típicas de negocios</em>, el estilo paquete-por-característica parece ser el superior de los dos:
    <p>
      <b>Mayor Modularidad</b> <br />
      Como se mencionó arriba, solo paquete-por-característica tiene paquetes con alta cohesión, alta 
      modularidad, y acople bajo entre paquetes.
    </p>
    <p>
      <b>Navegación de Código Más Fácil</b> <br />
      Los programadores de mantenimiento necesitan hacer un montón menos de búsquedas de 
      elementos, ya que todos los elementos necesitados para una tarea dada están usualmente en el mismo directorio. Algunas 
      herramientas que fomentan el uso de paquetes por capas utilizan convenciones de nomenclatura de paquetes para aliviar el 
      problema de la tediosa navegación de código. Sin embargo, paquete-por-característica <em>transciende la necesidad de tales 
        convenciones en primer lugar</em>, reduciendo en gran medida la necesidad de navegar entre directorios.
    </p>
    <p>
      <b>Mayor Nivel de Abstracción</b> <br />
      Mantenerse en un alto nivel de abstracción es uno de los principios rectores de la programación de valor duradero. Esto hace 
      más fácil pensar sobre un problema, y enfatiza los servicios fundamentales sobre los detalles de implementación. Como un 
      beneficio directo de estar a un alto nivel de abstracción, la aplicación se vuelve más autodocumentada: el tamaño total de la 
      aplicación se comunica por el número de paquetes, y las características básicas se comunican por los nombres de los paquetes. 
      <span class="highlight">El fallo fundamental del estilo paquete-por-<em>capa</em>, por otro lado, es que coloca los detalles 
        de implementación por delante de las abstracciones de alto nivel - que está al revés.</span>
    </p>
    <p>
      <b>Separar Ambas Características <i>y</i> Capas</b> <br />
      El estilo paquete-por-característica aún respeta la idea de separar las capas, pero la separación se implementa usando 
      <em>clases</em> separadas. EL estilo paquete-por-<em>capa</em>, por otro lado, implementa esa separación usando <i>tanto</i> 
      clases separadas <i>como</i> paquetes separados, lo que no parece necesario o deseable.
    </p>
    <p>
      <b>Minimiza el Alcance</b> <br />
      Minimizar el alcance es otro principio rector de valor duradero. Aquí, paquete-por-característica permite que algunas clases 
      rebajen su alcance de público a privado-de-paquete. Esto es un cambio significativo, y ayudará a 
      <a href="practicascomunes_123.html">minimizar los efectos dominantes</a>. El estilo paquete-por-capa, por otro lado, 
      efectivamente abandona el alcance privado-de-paquete, y le fuerza a implementar todos los elementos como <code>public</code>. 
      Esto es un fallo fundamental, ya que no le permite minimizar los efectos dominantes guardando secretos. 
    </p>
    <p>
      <b>Mejor Estilo de Crecimiento</b><br /> 
      En el estilo paquete-por-característica, el número de clases dentro de cada paquete permanece limitado a los elementos 
      relacionaods con una característica específica. Si un paquete se vuelve muy grande, puede ser refactorizado de una forma 
      natural en dos o más paquetes. El estilo paquete-por-<em>capa</em>, por otro lado, es monolítico. A medida que una aplicación 
      crece en tamaño, la cantidad de paquetes permanece aproximadamente igual, mientras que la cantidad de clases en cada paquete 
      aumentará sin límite.
    </p>
    <hr style="width: 30%">
    <p>
      Si aún necesita más convencimiento, considere lo siguiente.
    </p>
    <p>
      <b>La Estructura del Directorio es Fundamental para su Código</b>
    </p>
    <p>
      <span class="highlight">"Como cualquier diseñador le contará, estos son los primeros pasos en un proceso de diseño los que 
        más cuentan. Los primeros trazos, que crean la forma, llevan consigo el destino del resto."</span> - 
      <em>Christopher Alexander</em>
    </p>
    <p>
      (Christopher Alexander es un arquitecto. Sin haber trabajado como programador, ha influenciado a mucha gente que piensa un 
      montón sobre programación. Su primer libro <em>Un Lenguaje de Patrones</em> fue la inspiración original para el movimiento de 
      Patrones de Diseño. El ha pensado mucho y muy duro sobre construir cosas bonitas, y estas reflexiones parecen aplicarse en 
      gran medida a la construcción de software).
    </p>
    <p>
      En una entrevista en la radio CBC, Alexander contó la siguiente historia (parafraseada aquí): "Esta trabajando con uno de 
      mis estudiantes. El había pasado un período muy difícil construyendo algo. Simplemente no sabía como proceder en absoluto. 
      Así que me senté con él, y dije esto: Escucha, empieza por averiguar qué es lo más importante. Primero entiende eso. Ten eso 
      claro en tu mente. Tómate tu tiempo. No te apresures. Piense en ello por un momento. Cuando sientas que lo has encontrado, 
      cuando no tengas dudas en tu mente de que es <em>en realidad</em> la cosa más importante, entonces continúa y haz esa cosa 
      más importante. Cuando hayas hecho la cosa más importante, pregúntate a tí mismo si puedes hacerlo más bonito. Corta la 
      mierda, solo ponlo directo en tu cabez, si puedes hacerlo mejor o no. Cuando eso esté hecho, y sienta que no puedes hacerlo 
      mejor, entonces encuentra la <em>siguiente</em> cosa más importante."
    </p>
    <p>
      ¿Cuáles son los primeros trazos en una aplicación que crean su forma general? Es la estructura de directorios.
      <span class="highlight">La estructura de directorios es la primera cosa que se encuentran un programador cuando navega por el 
        codigo fuente. Todo fluye de ella. Todo depende de ella.</span> Es claramente uno de los aspectos más importantes de su 
        código fuente.
    </p>
    <p>
      Considere las diferentes reacciones de un programador cuando encuentra diferentes estructuras de directorio. Para el estilo 
      paquete-por-característica, los pensamientos del programador de la aplicación podrían ser como estos:
    </p>
    <ul>
      <li>"Ya veo. Esto enumera todas las características de nivel superior de la aplicación de una sola vez. Lindo"</li>
      <li>
        "Veamos. Me pregunto donde se ubica este elemento... Oh, aquí está. Y todo el resto que voy a necesitar está justo aquí 
        también, todo en el mismo lugar. Excelente."
      </li>
    </ul>
    Para el estilo paquete-por-<em>capa</em>, sin embargo, los pensamientos del programador de aplicaciones podrían ser más como 
    estos:
    <ul>
      <li>
        "Estos directorios no me dicen nada. ¿Cuántas características en esta aplicación? Me gana. Se ve exactamente igual que todos 
        los demás. No hay ninguna diferencia. Estupendo. Aquí vamos de nuevo..."
      </li>
      <li>
        "Mmm. Me preguntao dónde se ubica este elemento ... Supongo que sus partes están por toda la aplicación, repartidas por 
        todos estos directorios. ¿Realmente tengo todos los artículos que necesito? Supongo que lo sabremos más tarde."
      </li>
      <li>
        "Me pregunto si todavía se sigue esa convención de nomenclatura. Si no, tendré que buscarlo en ese otro directorio."
      </li>
      <li>"Guau, mira el tamaño de este directorio único ... puf."</li>
    </ul>
    <p>
      <b>El Paquete por Capa en Otros Dominios Es Ineficaz</b>
    </p>
    <p>
      Por analogía, uno puede ver que el estilo paquete-por-capa conduce a malos resultados. Por ejemplo, imagine un chcoe. En el 
      nivel más alto, la 'implementación' de un automóvil se divide de esta forma (paquete-por-característica):
    </p>
    <ul>
      <li>seguridad</li>
      <li>motor</li>
      <li>dirección</li>
      <li>sistema de conbustible</li>
      <li>etcetera...</li>
    </ul>
    <p>
      Ahora imagine un automóvil cuya 'implementación' bajo el capó se divide <em>primero</em>  de acuerdo con estas categorías d e
      nivel inferior (paquete-por-capa);
    </p>
    <ul>
      <li>eléctrico</li>
      <li>mecánico</li>
      <li>hidráulico</li>
    </ul>
    En el caso de un problema de transmisión, por ejemplo, podría necesitar jugar con estos compartimentos. Esto significaría pasar 
    de una parte del automóvil a otra completamente diferente. Mientras en estos diversos compartimentos, podría 'ver' elementos 
    que no tienen nada que ver con el problema que está intentando resolver. Simplemente estarían en el camino, siempre y en todas 
    partes distrayéndote de la verdadera tarea que tienes entre manos. ¿No tendría más sentido si hubiera un solo lugar que tuviera 
    exactamente lo que necesitas y nada más?
    <p>
      Como segundo ejemplo, considere una gran burocracia dividida en varios departamentos (paquete-por-característica):
      As a second example, consider a large bureacracy divided up into various departments (package-by-feature):
    </p>
    <ul>
      <li>oficina frontal</li>
      <li>oficina central</li>
      <li>contabilidad</li>
      <li>personal</li>
      <li>sala de correo</li>
    </ul>
    Si se usa un estilo paquete-por-capa, la división primaria sería algo como:
    <ul>
      <li>ejecutivos</li>
      <li>gestores</li>
      <li>empleados</li>
    </ul>
    Ahora imagine que la burocracia se divide <em>físicamente</em> de acuerdo con estas tres categorías. Cada gestor está ubicado, 
    por ejemplo, con todos los otros gestores, y no con los empleados que trabajan para ellos. ¿Sería eso efectivo? No, no lo sería.
    <p>
      Entonces, ¿por qué el software debería ser diferente? Parece que el paquete-por-capa es solo un mal hábito que espera ser 
      eliminado.
    </p>
    <p>
      Las aplicaciones de ejemplo que vienen con <a href="..\servlets\servlets_188.html">WEB4J</a> usan el estilo 
      paquete-por-característica. 
      <br />
    </p>
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\servlets\servlets_112.html">Los JSPs contendrán sólo lógica de presentación</a><br />
      <a href="..\servlets\servlets_188.html">WEB4J, Un Marco de trabajo de Aplicaciones WEB</a><br /> 
      <a href="..\tareascomunes\tareascomunes_260.html">Abrir un fichero en un directorio nativo</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>