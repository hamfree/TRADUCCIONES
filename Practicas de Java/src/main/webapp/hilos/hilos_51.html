<!DOCTYPE html>
<!-- saved from url=(0055)http://www.javapractices.com/topic/TopicAction.do?Id=51 -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Objetos que se comunican a través de hilos</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Búsqueda" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Objetos que se comunican a través de hilos</div>
    <br />
    Desde la versión 1.5, el KDJ ha incluído el paquete 
    <a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/package-summary.html">
      <code>java.util.concurrent</code></a>. Fue desarrollado por gurús experimentados, e incluye una serie de elementos para 
      crear muchos tipos de programas de subprocesos múltiples. <i>Concurrencia de Java en la Práctica</i> por Goetz y otros es una 
      buena referencia para este paquete.
    <p>
      Aquí tiene un ejemplo básico de usar 
      <a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/ExecutorService.html"><code>ExecutorService</code></a>
      y
      <a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/CountDownLatch.html"><code>CountDownLatch</code></a>
      de <code>java.util.concurrent</code> para comunicarse entre subprocesos. El ejemplo tiene el contexto siguiente: En el lado 
      cliente de programación, es común mostrar al usuario una lista de sus impresoras disponibles. Sin embargo, la herramienta del 
      KDJ para obtener esta información puede tener un rendimiento pobre - Algunas veces resultando en retardos de varios segundos 
      o más. Así, una opción es obtener la lista de impresoras disponibles al inicio de la aplicación, en un subproceso de trabajo 
      separado. Más tarde, cuando el usuario desea imprimir algo, la lista de impresoras ya estará precargada.<br />
    </p>
    <pre>
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> javax.print.PrintService;

<span class="comment">/** 
 Aplicación de cliente de juguete.
 Necesita presentar una lista de impresoras al usuario final.
 El problema es que obtener la lista de impresoras puede tomar varios segundos.
 Así, la idea es iniciar la obtención de la lista en un subproceso de trabajo al inicio.
*/</span> 
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> LaunchApplication {

  <span class="keyword">public</span> <span class="keyword">static</span> <span
			class="keyword">void</span> main(String... aArgs){
    log(<span class="literal">"Lanzando la aplicación."</span>);
    PrinterListDAO.init(); <span class="comment">//lanza el subproceso de trabajo
</span>    
    <span class="comment">//construye la interfaz de usuario, otras tareas de inicio, etc...
</span>    
    <span class="comment">//usa la lista de impresoras más tarde en el proceso
</span>    List&lt;PrintService&gt; printers = <span class="keyword">new</span> PrinterListDAO().getPrinters();
    log(<span class="literal">"Viendo tantas impresoras:"</span> + printers.size());
  }
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">void</span> log(String aMsg){
    System.out.println(aMsg);
  }
} 
    </pre>
    <br />
    <pre>
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> java.util.concurrent.CountDownLatch;
<span class="keyword">import</span> java.util.concurrent.ExecutorService;
<span class="keyword">import</span> java.util.concurrent.Executors;
<span class="keyword">import</span> javax.print.PrintService;

<span class="keyword">final</span> <span class="keyword">class</span> PrinterListDAO {

  <span class="comment">/** Esto debe llamarse al principio del inicio.. */</span>
  <span class="keyword">static</span> <span class="keyword">void</span> init(){
    fLatch = <span class="keyword">new</span> CountDownLatch(<span
			class="literal">1</span>);
    fWorker = <span class="keyword">new</span> PrinterListWorker(fLatch);
    ExecutorService executor = Executors.newSingleThreadExecutor();
    executor.execute(fWorker);
    executor.shutdown();<span class="comment">//reclama los recursos
</span>  }

  <span class="comment">/** Devuelve la lista de impresoras que pueden imprimir PDFs (a doble cara, retrato).*/</span>
  List&lt;PrintService&gt; getPrinters(){
    <span class="keyword">try</span> {
      <span class="comment">//se bloque hasta que el trabajador haya establecido el pestillo en 0:
</span>      fLatch.await();
    }
    <span class="keyword">catch</span> (InterruptedException ex){
      log(ex.toString());
      Thread.currentThread().interrupt();
    }
    <span class="keyword">return</span> fWorker.getPrinterList();
  }
  
  <span class="comment">// PRIVADO
</span>  
  <span class="comment">/** Usado para comunicación entre subprocesos. */</span>
  <span class="keyword">static</span> <span class="keyword">private</span> CountDownLatch fLatch;
  
  <span class="keyword">static</span> <span class="keyword">private</span> PrinterListWorker fWorker;
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">void</span> log(String aMsg){
    System.out.println(aMsg);
  }
} 
    </pre>
    <br />
    <pre>
<span class="keyword">import</span> java.util.*;
<span class="keyword">import</span> java.util.concurrent.CountDownLatch;
<span class="keyword">import</span> javax.print.PrintService;
<span class="keyword">import</span> javax.print.PrintServiceLookup;
<span class="keyword">import</span> javax.print.attribute.HashPrintRequestAttributeSet;
<span class="keyword">import</span> javax.print.attribute.PrintRequestAttributeSet;
<span class="keyword">import</span> javax.print.attribute.standard.OrientationRequested;
<span class="keyword">import</span> javax.print.attribute.standard.Sides;
<span class="keyword">import</span> javax.print.DocFlavor;

<span class="comment">/** Busca la lista de impresoras. */</span>
<span class="keyword">final</span> <span class="keyword">class</span> PrinterListWorker <span
			class="keyword">implements</span> Runnable {

  <span class="comment">/** Cuando se hace el trabajo, el pestillo contará hacia atrás hasta 0. */</span>
  PrinterListWorker(CountDownLatch aLatch){
    fLatch = aLatch;  
  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> run() {
    log(<span class="literal">"Se inició el subproceso de trabajo..."</span>);
    <span class="keyword">long</span> start = System.nanoTime();

    <span class="comment">//a doble cara, retrato, para ficheros PDF.
</span>    PrintRequestAttributeSet attrs = <span class="keyword">new</span> HashPrintRequestAttributeSet();
    attrs.add(Sides.DUPLEX);
    attrs.add(OrientationRequested.PORTRAIT);
    <span class="comment">//esto puede tomar varios segundos en algunos entornos:
</span>    fPrintServices = Arrays.asList(
      PrintServiceLookup.lookupPrintServices(DocFlavor.INPUT_STREAM.PDF, attrs)
    );
    
    <span class="keyword">long</span> end = System.nanoTime();
    log(<span class="literal">"Se terminó de obtener la lista de impresoras. Nanos: "</span> + (end-start));
    log(<span class="literal">"Número de impresoras encontradas:"</span> + fPrintServices.size());
    fLatch.countDown();
  }

  <span class="comment">/** Devuelve una lista no modificable de impresoras. */</span>
  List&lt;PrintService&gt; getPrinterList(){
    <span class="keyword">return</span> Collections.unmodifiableList(fPrintServices);
  }
  
  <span class="comment">// PRIVADO
</span>  
  <span class="comment">/** Usado para comunicación entre subprocesos. */</span>
  <span class="keyword">private</span> CountDownLatch fLatch;

  <span class="keyword">private</span> List&lt;PrintService&gt; fPrintServices;
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">void</span> log(String aMsg){
    System.out.println(aMsg);
  }
} 
    </pre>
    Aquí hay un ejemplo de ejecución:
    <p></p>
    <pre>
Lanzando la aplicación.
Se inició el subproceso de trabajo...
Se terminó de obtener la lista de impresoras. Nanos: 586542213
Número de impresoras encontradas:0
Viendo tantas impresoras:0
    </pre>

    <h3>KDJs más antiguas</h3>
    Si no tiene disponble un KDJ moderno, entonces no puede usar los servicios de <code>java.util.concurrent</code>. En su lugar, 
    deberá confiar en otros medios, a menudo la clase Thread y los métodos <code> wait </code> y <code> notificar </code> de la 
    clase Object.
    <p>
      La técnica siguiente usa el idioma de bucle <code>wait-</code> y <code>notifyAll</code>. Para estar seguro, siempre use 
      <code><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#notifyAll()">notifyAll</a></code> en vez de 
      <code><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#notify()">notify</a></code>. (Como una 
      optimización, se puede usar <code>notify</code> en vez de <code>notifyAll</code>, pero solo si sabe exactamente lo que está 
      haciendo).
    </p>
    <p>
      Puntos importantes:
    </p>
    <ul>
      <li>
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#wait()">wait</a></code> y
        <code>notifyAll</code> siempre deben ocurrir dentro de un bloque <code>synchronized</code>
      </li>
      <li>
        <code>wait</code> debe siempre ser invocado dentro de un bucle <code>while</code>, y no en una sentencia <code>if</code>
      </li>

    </ul>
    <b>Ejemplo</b>
    <p>
      En este ejemplo, el <code>Airplane</code> siempre necesita comprobar con el <code>Airport</code> para ver si tiene una pista 
      disponible antes de ser capaz de despegar o aterrizar.<br />
    </p>
    <pre>
<span class="comment">/** Usa el idioma de bucle wiait para comunicación entre subprocesos. */</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> Airplane <span class="keyword">implements</span> Runnable {

  <span class="keyword">public</span> Airplane (Airport aAirport, String aFlightId){
    fAirport = aAirport;
    fFlightId = aFlightId;
  }

  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> run() {
    takeOff();
    fly();
    land();
  }

  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> Airport fAirport;
  <span class="keyword">private</span> String fFlightId;

  <span class="keyword">private</span> <span class="keyword">void</span> takeOff() {
    <span class="keyword">synchronized</span>( fAirport ) {
      <span class="comment">//siempre use un bucle while, nunca una sentencia if:
</span>      <span class="keyword">while</span> (!fAirport.hasAvailableRunway()) {
        System.out.println( fFlightId + <span class="literal">": esperando por pista..."</span> );
        <span class="keyword">try</span> {
          <span class="comment">//espera la notificación del aeropuerto de que 
</span>          <span class="comment">//el estado del aeropuerto ha cambiado.
</span>          <span class="comment">//wait debe ocurrir siempre dentro de un bloque sincronizado
</span>          fAirport.wait();
        }
        <span class="keyword">catch</span> (InterruptedException ex) {
          Thread.currentThread().interrupt();
          System.err.println( ex );
        }
      }
      <span class="comment">//hay una pista disponible ahora, así que podemos despegar
</span>      System.out.println(fFlightId + <span class="literal">": despegando ahora..."</span>);
    }
  }

  <span class="keyword">private</span> <span class="keyword">void</span> fly() {
    System.out.println(fFlightId + <span class="literal">": volando ahora..."</span>);
    <span class="keyword">try</span> {
      <span class="comment">//no hace nada en varios segundos
</span>      Thread.sleep(<span class="literal">10000</span>);
    }
    <span class="keyword">catch</span> (InterruptedException ex){
      System.err.println(ex);
      Thread.currentThread().interrupt();
    }
  }

  <span class="keyword">private</span> <span class="keyword">void</span> land() {
    <span class="keyword">synchronized</span>(fAirport) {
      <span class="keyword">while</span> (!fAirport.hasAvailableRunway()) {
        <span class="comment">//espera por la notificación desde el aeropuerto que 
</span>        <span class="comment">//el estado del aeropuerto ha cambiado.
</span>        System.out.println(fFlightId + <span class="literal">": esperando por pista..."</span>);
        <span class="keyword">try</span> {
          fAirport.wait();
        }
        <span class="keyword">catch</span> (InterruptedException ex) {
          System.err.println( ex );
          Thread.currentThread().interrupt();
        }
      }
      <span class="comment">//hay una pista disponible ahora, así que podemos aterrizar
</span>      System.out.println(fFlightId + <span class="literal">": aterrizando ahora..."</span>);
    }
  }
} 
    </pre>
    <br />
    <pre>
<span class="comment">/** Notifica a los Airplanes cuando su estado cambia. */</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> Airport <span class="keyword">implements</span> Runnable {

  <span class="keyword">public</span> Airport(String aName) {
    <span class="keyword">super</span>();
    fName = aName;
  }

  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span
			class="keyword">boolean</span> hasAvailableRunway() {
    <span class="keyword">return</span> fHasAvailableRunway;
  }

  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> run() {
    System.out.println(<span class="literal">"Ejecutando "</span> + fName + <span
			class="literal">" Aeropuerto."</span>);
    <span class="keyword">while</span> (<span class="keyword">true</span>) {
      <span class="keyword">try</span> {
        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {
          <span class="comment">//simplemente cambia el estado entre disponible y no disponible
</span>          fHasAvailableRunway = !fHasAvailableRunway;
          System.out.println(fName + <span class="literal">" Has Available Runway: "</span> + fHasAvailableRunway);
          <span class="comment">//notifica a todos los que esperan del cambio de estado
</span>          notifyAll();
        }
        <span class="comment">//pausa la ejecución por unos pocos segundos
</span>        Thread.sleep(<span class="literal">1000</span>);
      }
      <span class="keyword">catch</span> (InterruptedException ex){
        System.err.println(ex);
        Thread.currentThread().interrupt();
      }
    }
  }

  <span class="comment">//PRIVADO
</span>  <span class="keyword">private</span> <span class="keyword">boolean</span> fHasAvailableRunway = <span
			class="keyword">true</span>;

  <span class="keyword">private</span> String fName;
} 
    </pre>
    <br />
    Un ejemplo de la ejecución de la siguiente clase <code>FlightSimulator</code> resultó en esta salida:
    <p></p>
    <p>
      <code>Ejecutando Simulador de Vuelo.</code><br />
      <b><code>Terminando el subproceso de usuario original.</code></b><br />
      <code>Ejecución del Aeropuerto Charles de Gaulle.</code><br />
      <code>Charles de Gaulle tiene pista disponible: falso</code><br />
      <code>Vuelo 8875: esperando pista...</code><br />
      <code>Charles de Gaulle tiene pista disponible: verdadero</code><br />
      <code>Vuelo 8875: despegando ahora...</code><br />
      <code>Vuelo 8875: volando ahora...</code><br />
      <code>Charles de Gaulle tiene pista disponible: falso</code><br />
      <code>Charles de Gaulle tiene pista disponible: verdadero</code><br />
      <code>Charles de Gaulle tiene pista disponible: falso</code><br />
      <code>Charles de Gaulle tiene pista disponible: verdadero</code><br />
      <code>Charles de Gaulle tiene pista disponible: falso</code><br />
      <code>Charles de Gaulle tiene pista disponible: verdadero</code><br />
      <code>Charles de Gaulle tiene pista disponible: falso</code><br />
      <code>Charles de Gaulle tiene pista disponible: verdadero</code><br />
      <code>Charles de Gaulle tiene pista disponible: falso</code><br />
      <code>Vuelo 8875: esperando pista...</code><br />
      <code>Charles de Gaulle tiene pista disponible: verdadero</code><br />
      <code>Vuelo 8875: aterrizando ahora...</code><br />
      <code>Charles de Gaulle tiene pista disponible: falso</code><br />
      <code>Charles de Gaulle tiene pista disponible: verdadero</code><br />
    </p>
    <pre>
<span class="comment">/** 
 Construye e inicia los subprocesos para Airport y Airplanes.
 (Se desaconseja el uso de objetos Thread sin procesar en 
 favor del paquete java.util.concurrent más moderno.)
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> FlightSimulator {

  <span class="keyword">public</span> <span class="keyword">static</span> <span
			class="keyword">void</span> main(String... arguments) {
    System.out.println(<span class="literal">"Ejecutando Simulador de Vuelo."</span>);

    <span class="comment">//construye un aeropuerto e inicia su ejecución
</span>    Airport charlesDeGaulle = <span class="keyword">new</span> Airport(<span
			class="literal">"Charles de Gaulle"</span>);
    Thread airport = <span class="keyword">new</span> Thread(charlesDeGaulle);
    airport.start();

    <span class="comment">//construye un avión e inicia su ejecución
</span>    Thread planeOne = <span class="keyword">new</span> Thread(<span
			class="keyword">new</span> Airplane(charlesDeGaulle, <span
			class="literal">"Vuelo 8875"</span>));
    planeOne.start();

    <span class="comment">//observe que este subproceso de usuario ahora termina, pero el programa en sí no lo hace.
</span>    <span class="comment">//NO termina ya que los subprocesos creados anteriormente también son subprocesos 
</span>    <span class="comment">//de usuario. Todos los subprocesos de usuario tienen el mismo estado, y no 
</span>    <span class="comment">//hay nada especial acerca del subproceso que lanza un programa.
</span>    System.out.println(<span class="literal">"Terminando el subproceso de usuario original."</span>);
  }
} 
    </pre>
    <br />
    <p></p>
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\hilos\hilos_50.html">Lanzar un hilo es simplemente como otro hilo de usuario</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>