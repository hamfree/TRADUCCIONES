<!DOCTYPE html>
<!-- saved from url=(0055)http://www.javapractices.com/topic/TopicAction.do?Id=54 -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Planifique tareas periódicas</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Search" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Planifique tareas periódicas</div>
    <br />
    Las tareas pueden ser planificadas para la ejecución en el futuro. Tales tareas pueden ser realizadas periódicamente, o 
    simplemente una vez. Además, la primera ejecución puede ser retrasada a un tiempo específico en el futuro.
    <p>
      Hay dos estilos diferentes de implementar una tarea planificada:
    </p>
    <ul>
      <li>
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/ScheduledExecutorService.html">
            ScheduledExecutorService</a></code> y 
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/ScheduledFuture.html">ScheduledFuture</a></code>
      </li>
      <li>
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/util/Timer.html">Timer</a></code> y 
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/util/TimerTask.html">TimerTask</a></code>
      </li>
    </ul>
    <p>
      El primer par es la IPA más moderna. Como es habitual, la IPA más moderna es habitualmente la preferida. La principal 
      diferencia entre estas dos IPAs es que la primera siempre usa tiempos relativos, mientras que la segunda no. Si se necesita, 
      siempre puede transformar una 
      <code>LocalDateTime</code>, <code>Date</code>, u objeto similar en un tiempo relativo:
    </p>
    <pre>
LocalDateTime now = LocalDateTime.now();
LocalDateTime futureTime = LocalDateTime.parse("2100-01-01T00:00:00"); 
Long msecsUntil = ChronoUnit.MILLIS.between(now, futureTime);

//con KDJ &lt;8
Date futureDate = ...
Long startTime = futureDate.getTime() - System.currentTimeMillis();
    </pre>
    (Esto solo funcionará si el reloj del sistema no se reinicia.)
    <p>
      <b>Ejemplo 1</b><br />
    </p>
    <p>
      Aquí tiene un ejemplo de una clase <code>AlarmClock</code>, que usa un <code>ScheduledExecutorService</code>:<br />
    </p>
    <pre>
<span class="keyword">import</span> java.util.concurrent.Executors;
<span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;
<span class="keyword">import</span> java.util.concurrent.ScheduledFuture;
<span class="keyword">import</span> java.util.concurrent.TimeUnit;

<span class="comment">/**
 Ejecuta una tarea simple cada segundo, empezando en 3 segundos desde ahora.
 Cancela la tarea después de 20 segundos.
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> AlarmClock {
  
  <span class="comment">/** Ejecuta el ejemplo. */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
			class="keyword">void</span> main(String... aArgs) <span
			class="keyword">throws</span> InterruptedException {
    log(<span class="literal">"Main iniciado."</span>);
    AlarmClock alarmClock = <span class="keyword">new</span> AlarmClock(<span
			class="literal">3</span>, <span class="literal">1</span>, <span
			class="literal">20</span>);
    alarmClock.activateAlarmThenStop();
    <span class="comment">/*
    Para iniciar la alarma en la fecha específica en el futuro, el retardo inicial 
    necesita ser calculado relativo a la hora actual, como en:
    Date futureDate = ...
    long startTime = futureDate.getTime() - System.currentTimeMillis();
    AlarmClock alarm = new AlarmClock(startTime, 1, 20);
    Esto funciona solo si el reloj del sistema no se reinicia.
    */</span>
    log(<span class="literal">"Main terminado."</span>);
  }
  
  AlarmClock(<span class="keyword">long</span> aInitialDelay, <span
			class="keyword">long</span> aDelayBetweenBeeps, <span class="keyword">long</span> aStopAfter){
    fInitialDelay = aInitialDelay;
    fDelayBetweenRuns = aDelayBetweenBeeps;
    fShutdownAfter = aStopAfter;
    fScheduler = Executors.newScheduledThreadPool(NUM_THREADS);    
  }
  
  <span class="comment">/** Suena la alarma por unos pocos segundos, después para. */</span>
  <span class="keyword">void</span> activateAlarmThenStop(){
    Runnable soundAlarmTask = <span class="keyword">new</span> SoundAlarmTask();
    ScheduledFuture&lt;?&gt; soundAlarmFuture = fScheduler.scheduleWithFixedDelay(
      soundAlarmTask, fInitialDelay, fDelayBetweenRuns, TimeUnit.SECONDS
    );
    Runnable stopAlarm = <span class="keyword">new</span> StopAlarmTask(soundAlarmFuture);
    fScheduler.schedule(stopAlarm, fShutdownAfter, TimeUnit.SECONDS);
  }

  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService fScheduler;
  <span class="keyword">private</span> <span class="keyword">final</span> <span
			class="keyword">long</span> fInitialDelay;
  <span class="keyword">private</span> <span class="keyword">final</span> <span
			class="keyword">long</span> fDelayBetweenRuns;
  <span class="keyword">private</span> <span class="keyword">final</span> <span
			class="keyword">long</span> fShutdownAfter;
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">void</span> log(String aMsg){
    System.out.println(aMsg);
  }

  <span class="comment">/** Si las invocaciones pueden superponerse, puede especificar más de un hilo.*/</span> 
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">final</span> <span class="keyword">int</span> NUM_THREADS = <span
			class="literal">1</span>;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">final</span> <span class="keyword">boolean</span> DONT_INTERRUPT_IF_RUNNING = <span
			class="keyword">false</span>;
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">final</span> <span class="keyword">class</span> SoundAlarmTask <span
			class="keyword">implements</span> Runnable {
    <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> run() {
      ++fCount;
      log(<span class="literal">"bip "</span> + fCount);
    }
    <span class="keyword">private</span> <span class="keyword">int</span> fCount;
  }
  
  <span class="keyword">private</span> <span class="keyword">final</span> <span
			class="keyword">class</span> StopAlarmTask <span class="keyword">implements</span> Runnable {
    StopAlarmTask(ScheduledFuture&lt;?&gt; aSchedFuture){
      fSchedFuture = aSchedFuture;
    }
    <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> run() {
      log(<span class="literal">"Parando la alarma."</span>);
      fSchedFuture.cancel(DONT_INTERRUPT_IF_RUNNING);
      <span class="comment">/* 
       Tenga en cuenta que esta Tarea también realiza la limpieza, pidiendo al 
       planificador que se apague correctamente.
      */</span>
      fScheduler.shutdown();
    }
    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; fSchedFuture;
  }
} 
    </pre>
    <p></p>
    <p>
      <b>Ejemplo 2</b><br />
    </p>
    <p>
      Este ejemplo usa las clases más antiguas, 
      <code><a href="https://docs.oracle.com/javase/10/docs/api/java/util/Timer.html">Timer</a></code> y 
      <code><a href="https://docs.oracle.com/javase/10/docs/api/java/util/TimerTask.html">TimerTask</a></code>.
    </p>
    <p>
      Aquí se realiza una tarea una vez al día a las 4 de la mañana, empezando mañana por la mañana.<br />
    </p>
    <pre>
<span class="keyword">import</span> java.util.Timer;
<span class="keyword">import</span> java.util.TimerTask;
<span class="keyword">import</span> java.util.Calendar;
<span class="keyword">import</span> java.util.GregorianCalendar;
<span class="keyword">import</span> java.util.Date;

<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> FetchMail <span class="keyword">extends</span> TimerTask {

  <span class="comment">/** Construye y usa un TimerTask y un Timer. */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
			class="keyword">void</span> main (String... arguments ) {
    TimerTask fetchMail = <span class="keyword">new</span> FetchMail();
    <span class="comment">//realiza la tarea una vez al día a las 4 a.m., empezando mañana por la mañana
</span>    <span class="comment">//(otros estilos son también posibles)
</span>    Timer timer = <span class="keyword">new</span> Timer();
    timer.scheduleAtFixedRate(fetchMail, getTomorrowMorning4am(), fONCE_PER_DAY);
  }

  <span class="comment">/**
  * Implementa el método abstracto run de TimerTask.
  */</span>
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> run(){
    <span class="comment">//toy implementation
</span>    System.out.println(<span class="literal">"Obteniendo correo..."</span>);
  }

  <span class="comment">// PRIVADO
</span>
  <span class="comment">//expresado en milisegundos
</span>  <span class="keyword">private</span> <span class="keyword">final</span> <span
			class="keyword">static</span> <span class="keyword">long</span> fONCE_PER_DAY = <span
			class="literal">1000</span>*<span class="literal">60</span>*<span
			class="literal">60</span>*<span class="literal">24</span>;

  <span class="keyword">private</span> <span class="keyword">final</span> <span
			class="keyword">static</span> <span class="keyword">int</span> fONE_DAY = <span
			class="literal">1</span>;
  <span class="keyword">private</span> <span class="keyword">final</span> <span
			class="keyword">static</span> <span class="keyword">int</span> fFOUR_AM = <span
			class="literal">4</span>;
  <span class="keyword">private</span> <span class="keyword">final</span> <span
			class="keyword">static</span> <span class="keyword">int</span> fZERO_MINUTES = <span
			class="literal">0</span>;

  <span class="keyword">private</span> <span class="keyword">static</span> Date getTomorrowMorning4am(){
    Calendar tomorrow = <span class="keyword">new</span> GregorianCalendar();
    tomorrow.add(Calendar.DATE, fONE_DAY);
    Calendar result = <span class="keyword">new</span> GregorianCalendar(
      tomorrow.get(Calendar.YEAR),
      tomorrow.get(Calendar.MONTH),
      tomorrow.get(Calendar.DATE),
      fFOUR_AM,
      fZERO_MINUTES
    );
    <span class="keyword">return</span> result.getTime();
  }
}
 
    </pre>
    <br />
    <p></p>
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\swing\swing_160.html">Temporizador</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>