<!DOCTYPE html>
<!-- saved from url=(0055)http://www.javapractices.com/topic/TopicAction.do?Id=49 -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Sincronize el acceso a los campos mutables</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Búsqueda" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Sincronize el acceso a los campos mutables</div>
    <br />
    En un entorno multiproceso, acceder a datos mutables (datos que pueden cambiar) debe ser siempre coordinado entre los lectores 
    y los escritores. La tarea de asegurarse de que los lectores y escritores no se interfieran entre ellos de formas no deseables 
    se llama <em>sincronización</em>. La sincronización se puede hacer con un objeto de bloque explícito, pero un estilo más común 
    es usar los <i>bloqueos intrínsecos</i> implicados por la palabra clave <code>synchronized</code>.
    <p>
      Por ejemplo, en un entorno multiproceso, todos los métodos <code>get</code> y <code>set</code> para campos mutables deben 
      ser habitualemnte métodos <code>synchronized</code>. Esto incluye a los campos de tipos primitivos.
    </p>
    <p>
      La mayoría de las clases no necesitan ser diseñadas para operar en un entorno multiproceso, y pueden ignorar estas 
      consideraciones.
    </p>
    <p>
      Si un objeto necesita existir en un entorno multiproceso, sin embargo, entonces se debe tener mucho cuidado para asegurar que 
      esté correctamente diseñado.
    </p>
    <p>
      Sin un objeto es <a href="../patrones/patrones_29.html">inmutable</a>, entonces es automáticamente
      <a href="hilos_48.html">seguro en multiproceso</a>. Si es mutable, se deben tomar unos 
      pasos extra para asegurar la seguridad en multiproceso: cada uso de cada campo mutable debe ser sincronizado de alguna forma 
      (usualmente con el uso de la palabra clave <code>synchronized</code>).
    </p>
    <p>
      Aquí, <i>campo mutable</i> simplemente significa que un campo podría cambiar de cualquier forma, después de la construcción 
      inicial del objeto. (Los objetos no se comparten nunca entre subprocesos hasta después de que el objeto se ha creado 
      completamente). Por ejemplo, 
    </p>
    <ul>
      <li>un campo de <code>int</code> cambia su valor alguna vez después que se completa el constructor</li>
      <li>
        un campo de <code>Date</code> que cambia de estado alguna vez después de que termina el constructor, para representar una 
        fecha diferente de la original
      </li>
      <li>cualquier campo del objeto que se "apunte" a un nuevo objeto, alguna vez después de que el constructor se completa</li>
    </ul>
    Recuerde que todas las variables <i>locales</i> declaradas en el cuerpo de un método no son compartidas nunca entre subprocesos, 
    y por lo tanto no tienen consideraciones de seguridad multiproceso.
    
    <p>
      Es un error pensar que todos los tipos primitivos mutables excepto <code>long</code> y <code>double</code> no necesitan acceso 
      <code>synchronized</code>.
    </p>
    <p>
      <b>Ejemplo</b>
    </p>
    <p>
      Tenga en cuenta que incluso el <code>get</code> del campo <code>int</code> es un método <code>synchronized</code>.<br />
    </p>
    <pre>
<span class="keyword">import</span> java.util.Date;

<span class="comment">/**
* Esta clase es mutable, pero segura para subprocesos: el llamante nunca 
* necesita realizar sincronización externa, excepto cuando múltiples llamadas
* necesitan ser tratadas como una única unidad.
*
* Esta clase ilustra los tres posibles casos para los campos:
*&lt;ul&gt;
* &lt;li&gt; un primitivo (int)
* &lt;li&gt; un objeto inmutable (String)
* &lt;li&gt; un objeto mutable (Date)
*&lt;/ul&gt;
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> MutablePlanet {

  <span class="keyword">public</span> MutablePlanet(<span
			class="keyword">int</span> aId, String aName, Date aDateOfDiscovery) {
     fId = aId;
     fName = aName;
     <span class="comment">//Hace una copia privada de aDateOfDiscovery.
</span>     <span class="comment">//Esta es la única forma de mantener el campo fDateOfDiscovery
</span>     <span class="comment">//privado, y blinda esta clase de cualquier cambio al 
</span>     <span class="comment">//objeto original aDateOfDiscovery que podría ser 
</span>     <span class="comment">//realizado por el llamador.
</span>     fDateOfDiscovery = <span class="keyword">new</span> Date(aDateOfDiscovery.getTime());
  }

  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span
			class="keyword">int</span> getId() {
     <span class="keyword">return</span> fId;
  }
  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span
			class="keyword">void</span> setId(<span class="keyword">int</span> aNewId) {
    fId = aNewId;
  }

  <span class="keyword">public</span> <span class="keyword">synchronized</span> String getName() {
    <span class="keyword">return</span> fName;
  }
  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span
			class="keyword">void</span> setName(String aNewName) {
    fName = aNewName;
  }

  <span class="comment">/**
  * Devuelve una copia defensiva del campo.
  * El llamador de este método puede hacer lo que quierea con el 
  * objeto Date devuelto, sin afectar los aspectos internos de esta 
  * clase de ninguna forma.
  */</span>
  <span class="keyword">public</span> <span class="keyword">synchronized</span> Date getDateOfDiscovery() {
    <span class="keyword">return</span> <span class="keyword">new</span> Date(fDateOfDiscovery.getTime());
  }
  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span
			class="keyword">void</span> setDateOfDiscovery(Date aNewDiscoveryDate) {
    <span class="comment">//cambia el estado del campo Data mutable
</span>    fDateOfDiscovery.setTime(aNewDiscoveryDate.getTime());
  }

  <span class="comment">// PRIVADO
</span>
  <span class="comment">/**
  * Un campo primitivo.
  */</span>
  <span class="keyword">private</span> <span class="keyword">int</span> fId;

  <span class="comment">/**
  * Un campo de objeto inmutable.
  * Las Strings nunca alteran su estado después de la construcción.
  */</span>
  <span class="keyword">private</span> String fName;

  <span class="comment">/**
  * Un campo de objeto mutable.
  * El estado de un Date puede cambiar después de la construcción.
  */</span>
  <span class="keyword">private</span> Date fDateOfDiscovery;
}
 
    </pre>
    <br />
    <p></p>
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\patrones\patrones_29.html">Objetos inmutables</a><br />
      <a href="..\hilos\hilos_35.html">Recuerde los tipos de bloqueos intrínsecos</a><br />
      <a href="..\hilos\hilos_48.html">Documente la seguridad del hilo</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>