<!DOCTYPE html>
<!-- saved from url=(0055)http://www.javapractices.com/topic/TopicAction.do?Id=45 -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java,
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Implementar Serializable</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Search" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Implementar Serializable</div>
    <br />
    <span class="highlight">Do not implement 
      <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/Serializable.html">Serializable</a></code> lightly, since it 
      restricts future flexibility, and publicly exposes class implementation details which are usually private.
    </span> As well, implementing <code>Serializable</code> correctly is not trivial.
    <p>
      The <code>serialVersionUID</code> is a universal version identifier for a
      <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/Serializable.html">Serializable</a></code> class. 
      Deserialization uses this number to ensure that a loaded class corresponds exactly to a serialized object. If no match is 
      found, then an 
      <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/InvalidClassException.html">InvalidClassException</a></code>
      is thrown.
    </p>
    <p>
      Guidelines for <code>serialVersionUID</code>:
    </p>
    <ul>
      <li>
        always include it as a field, for example: <pre>private static final long serialVersionUID = 7526472295622776147L;</pre>
      </li>
      <li>include this field even in the first version of the class, as a reminder of its importance</li>
      <li>
        don't change the value of this field in future versions, unless you are knowingly making changes to the class which will 
        render it incompatible with old serialized objects
      </li>
      <li>
        new versions of <code>Serializable</code> classes may or may not be able to read old serialized objects; it depends upon the 
        nature of the change; provide a pointer to Oracle's 
        <a href="http://docs.oracle.com/javase/8/docs/platform/serialization/spec/version.html#6678">guidelines</a> for what 
        constitutes a compatible change, as a convenience to future maintainers
      </li>
    </ul>
    <p>
      Modern IDE's can generate a value of <code>serialVersionUID</code> for you. In addition, the JDK includes the
      <code>serialver</code> tool for generating these values. Here are the docs for both 
      <a href="http://docs.oracle.com/javase/8/docs/technotes/tools/windows/serialver.html">Win</a> and 
      <a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/serialver.html">Unix</a>. (The class name you pass to this 
      tool doesn't include the <code>.class</code> extension.)
    </p>
    <p>
      <code>readObject</code> and <code>writeObject</code>:
    </p>
    <ul>
      <li><code>readObject</code> implementations always start by calling default methods</li>
      <li>
        deserialization must be treated as any constructor: validate the object state at the end of deserializing - this implies 
        that <code>readObject</code> should almost always be implemented in <code>Serializable</code> classes, such that this 
        validation is performed.
      </li>
      <li>
        deserialization must be treated as any constructor: if constructors make defensive copies for mutable object fields, so 
        must <code>readObject</code>
      </li>
      <li>
        when serializing a <code>Collection</code>, store the number of objects in the <code>Collection</code> as well, and use this 
        number to read them back in upon deserialization; avoid tricks using <code>null</code>
      </li>
    </ul>
    Other points:
    <ul>
      <li>use javadoc's <code>@serial</code> tag to denote 
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/Serializable.html">Serializable</a></code> fields
      </li>
      <li>the <code>.ser</code> extension is conventionally used for files representing serialized objects</li>
      <li>no <code>static</code> or <code>transient</code> fields undergo default serialization</li>
      <li>extendable classes should not be <code>Serializable</code>, unless necessary</li>
      <li>inner classes should rarely, if ever, implement <code>Serializable</code></li>
      <li>
        container classes should usually follow the style of <code>Hashtable</code>, which implements <code>Serializable</code> by 
        storing keys and values, as opposed to a large hash table data structure
      </li>
    </ul>
    <b>Example</b>
    <br />
    <pre>
		<span class="keyword">import</span> java.io.Serializable;
<span class="keyword">import</span> java.text.StringCharacterIterator;
<span class="keyword">import</span> java.util.*;
<span class="keyword">import</span> java.io.*;

<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> SavingsAccount <span
            class="keyword">implements</span> Serializable {

   <span class="comment">/**
   * This constructor requires all fields to be passed as parameters.
   *
   * @param aFirstName contains only letters, spaces, and apostrophes.
   * @param aLastName contains only letters, spaces, and apostrophes.
   * @param aAccountNumber is non-negative.
   * @param aDateOpened has a non-negative number of milliseconds.
   */</span>
   <span class="keyword">public</span> SavingsAccount(
     String aFirstName, String aLastName, <span class="keyword">int</span> aAccountNumber, Date aDateOpened
   ){
     setFirstName(aFirstName);
     setLastName(aLastName);
     setAccountNumber(aAccountNumber);
     <span class="comment">//make a defensive copy of the mutable Date passed to the constructor
</span>     setDateOpened(<span class="keyword">new</span> Date(aDateOpened.getTime()));
     <span class="comment">//there is no need here to call validateState.
</span>   }

   <span class="keyword">public</span> SavingsAccount(){
     <span class="keyword">this</span>(<span class="literal">"FirstName"</span>, <span
            class="literal">"LastName"</span>, <span class="literal">0</span>, <span
            class="keyword">new</span> Date(System.currentTimeMillis()));
   }

   <span class="keyword">public</span> String getFirstName(){
     <span class="keyword">return</span> fFirstName;
   }

   <span class="keyword">public</span> String getLastName(){
     <span class="keyword">return</span> fLastName;
   }

   <span class="keyword">public</span> <span class="keyword">int</span> getAccountNumber(){
     <span class="keyword">return</span> fAccountNumber;
   }

   <span class="comment">/**
   * Returns a defensive copy of the field.
   * The caller may change the state of the returned object in any way,
   * without affecting the internals of this class.
   */</span>
   <span class="keyword">public</span> Date getDateOpened() {
     <span class="keyword">return</span> <span class="keyword">new</span> Date(fDateOpened.getTime());
   }

   <span class="comment">/**
   * Names must contain only letters, spaces, and apostrophes.
   * Validate before setting field to new value.
   *
   * @throws IllegalArgumentException if the new value is not acceptable.
   */</span>
   <span class="keyword">public</span> <span class="keyword">void</span> setFirstName(String aNewFirstName) {
     validateName(aNewFirstName);
     fFirstName = aNewFirstName;
   }

   <span class="comment">/**
   * Names must contain only letters, spaces, and apostrophes.
   * Validate before setting field to new value.
   *
   * @throws IllegalArgumentException if the new value is not acceptable.
   */</span>
   <span class="keyword">public</span> <span class="keyword">void</span> setLastName (String aNewLastName) {
     validateName(aNewLastName);
     fLastName = aNewLastName;
   }

   <span class="comment">/**
   * Validate before setting field to new value.
   *
   * @throws IllegalArgumentException if the new value is not acceptable.
   */</span>
   <span class="keyword">public</span> <span class="keyword">void</span> setAccountNumber(<span
            class="keyword">int</span> aNewAccountNumber){
     validateAccountNumber(aNewAccountNumber);
     fAccountNumber = aNewAccountNumber;
   }

   <span class="keyword">public</span> <span class="keyword">void</span> setDateOpened(Date aNewDate){
     <span class="comment">//make a defensive copy of the mutable date object
</span>     Date newDate = <span class="keyword">new</span> Date(aNewDate.getTime());
     validateDateOpened(newDate);
     fDateOpened = newDate;
   }

   <span class="comment">// PRIVATE
</span>
   <span class="comment">/**
   * The client's first name.
   * @serial
   */</span>
   <span class="keyword">private</span> String fFirstName;

   <span class="comment">/**
   * The client's last name.
   * @serial
   */</span>
   <span class="keyword">private</span> String fLastName;

   <span class="comment">/**
   * The client's account number.
   * @serial
   */</span>
   <span class="keyword">private</span> <span class="keyword">int</span> fAccountNumber;

   <span class="comment">/**
   * The date the account was opened.
   * @serial
   */</span>
   <span class="keyword">private</span> Date fDateOpened;

   <span class="comment">/**
   * Determines if a de-serialized file is compatible with this class.
   *
   * Maintainers must change this value if and only if the new version
   * of this class is not compatible with old versions. See Sun docs
   * for &lt;a href=http://java.sun.com/products/jdk/1.1/docs/guide
   * /serialization/spec/version.doc.html&gt; details. &lt;/a&gt;
   *
   * Not necessary to include in first version of the class, but
   * included here as a reminder of its importance.
   */</span>
   <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span
            class="literal">7526471155622776147L</span>;

   <span class="comment">/**
   * Verify that all fields of this object take permissible values; that is,
   * this method defines the class invariant.
   *
   * In this style of implementation, both the entire state of the object
   * and its individual fields can be validated without repeating or
   * duplicating code.
   * Each condition is defined in one place. Checks on the entire
   * object are performed at the end of object construction, and at
   * the end of de-serialization. Checks on individual fields are
   * performed at the start of the corresponding setXXX method.
   * As well, this style replaces the if's and throwing
   * of exceptions at the start of a setXXX, with a simple call to validateXXX.
   * Validation is separated from the regular path of execution,
   * which leads to improved legibility.
   *
   * @throws IllegalArgumentException if any field takes an unpermitted value.
   */</span>
   <span class="keyword">private</span> <span class="keyword">void</span> validateState() {
     validateAccountNumber(fAccountNumber);
     validateName(fFirstName);
     validateName(fLastName);
     validateDateOpened(fDateOpened);
   }

   <span class="comment">/**
   * Ensure names contain only letters, spaces, and apostrophes.
   *
   * @throws IllegalArgumentException if field takes an unpermitted value.
   */</span>
   <span class="keyword">private</span> <span class="keyword">void</span> validateName(String aName){
     <span class="keyword">boolean</span> nameHasContent = (aName != <span
            class="keyword">null</span>) &amp;&amp; (!aName.equals(<span
            class="literal">""</span>));
     <span class="keyword">if</span> (!nameHasContent){
       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span
            class="literal">"Names must be non-null and non-empty."</span>);
     }
     StringCharacterIterator iterator = <span class="keyword">new</span> StringCharacterIterator(aName);
     <span class="keyword">char</span> character = iterator.current();
     <span class="keyword">while</span> (character != StringCharacterIterator.DONE){
       <span class="keyword">boolean</span> isValidChar =
         (Character.isLetter(character) ||
         Character.isSpaceChar(character) ||
         character ==<span class="literal">'\''</span>
       );
       <span class="keyword">if</span> (isValidChar) {
         <span class="comment">//do nothing
</span>       }
       <span class="keyword">else</span> {
         String message = <span class="literal">"Names can contain only letters, spaces, and apostrophes."</span>;
         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(message);
       }
       character = iterator.next();
     }
  }

  <span class="comment">/**
  * AccountNumber must be non-negative.
  * @throws IllegalArgumentException if field takes an unpermitted value.
  */</span>
   <span class="keyword">private</span> <span class="keyword">void</span> validateAccountNumber(<span
            class="keyword">int</span> aAccountNumber){
     <span class="keyword">if</span> (aAccountNumber &lt; <span
            class="literal">0</span>) {
       String message = <span class="literal">"Account Number must be greater than or equal to 0."</span>;
       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(message);
     }
   }

  <span class="comment">/**
  * DateOpened must be after 1970.
  * @throws IllegalArgumentException if field takes an unpermitted value.
  */</span>
   <span class="keyword">private</span> <span class="keyword">void</span> validateDateOpened(Date aDateOpened) {
     <span class="keyword">if</span>(aDateOpened.getTime() &lt; <span
            class="literal">0</span>) {
       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span
            class="literal">"Date Opened must be after 1970."</span>);
     }
   }

   <span class="comment">/**
   * Always treat de-serialization as a full-blown constructor, by
   * validating the final state of the de-serialized object.
   */</span>
   <span class="keyword">private</span> <span class="keyword">void</span> readObject(
     ObjectInputStream aInputStream
   ) <span class="keyword">throws</span> ClassNotFoundException, IOException {
     <span class="comment">//always perform the default de-serialization first
</span>     aInputStream.defaultReadObject();

     <span class="comment">//make defensive copy of the mutable Date field
</span>     fDateOpened = <span class="keyword">new</span> Date(fDateOpened.getTime());

     <span class="comment">//ensure that object state has not been corrupted or tampered with maliciously
</span>     validateState();
  }

    <span class="comment">/**
    * This is the default implementation of writeObject.
    * Customise if necessary.
    */</span>
    <span class="keyword">private</span> <span class="keyword">void</span> writeObject(
      ObjectOutputStream aOutputStream
    ) <span class="keyword">throws</span> IOException {
      <span class="comment">//perform the default serialization for all non-transient, non-static fields
</span>      aOutputStream.defaultWriteObject();
    }
} 
    </pre>
    <br />
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\patrones\patrones_1.html">Enumeraciones seguras</a><br />
      <a href="..\patrones\patrones_46.html">Singleton</a><br />
      <a href="..\serializacion\serializacion_70.html">Serialización y generación de subclases</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>