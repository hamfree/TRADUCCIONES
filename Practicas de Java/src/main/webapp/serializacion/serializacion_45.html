<!DOCTYPE html>
<!-- saved from url=(0055)http://www.javapractices.com/topic/TopicAction.do?Id=45 -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java,
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Implementar Serializable</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Búsqueda" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Implementar Serializable</div>
    <br />
    <span class="highlight">No implemente 
      <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/Serializable.html">Serializable</a></code> a la ligera, ya 
      que restringe la flexibilidad futura, y públicamente expone los detalles de la implementación de la clase que son 
      habitualmente privados.
    </span> Además, implementar <code>Serializable</code> correctamente no es trivial.
    <p>
      El <code>serialVersionUID</code> es un identificador de versión universal para una clase 
      <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/Serializable.html">Serializable</a></code>. La 
      deserialización usa este número para asegurar que una clase cargada corresponde exactamente a un objeto serializado. Si no 
      se encuentrra coincidencia, entonces se lanza una 
      <code>
        <a href="https://docs.oracle.com/javase/10/docs/api/java/io/InvalidClassException.html">InvalidClassException</a></code>.
    </p>
    <p>
      Guías para <code>serialVersionUID</code>:
    </p>
    <ul>
      <li>
        siempre inclúyalo como un campo, por ejemplo: <pre>private static final long serialVersionUID = 7526472295622776147L;</pre>
      </li>
      <li>incluya este campo incluso en la primera versión de la clase, como un recordatorio de su importancia</li>
      <li>
        no cambie el valor de este campo en versiones futuras, a menos que esté realizando cambios a sabiendas en la clase que 
        la harán incompatible con los objetos serializados antiguos
      </li>
      <li>
        nuevas versiones de clases <code>Serializable</code> pueden o no pueden ser capaces de leer viejos objetos serializados; 
        depende de la naturaleza del cambio; proporcionar un puntero a las 
        <a href="http://docs.oracle.com/javase/8/docs/platform/serialization/spec/version.html#6678">pautas</a> de Oracle sobre lo 
        que constituye un cambio compatible, como una conveniencia para futuros mantenedores
      </li>
    </ul>
    <p>
      Los EID modernos pueden generar un valor de <code>serialVersionUID</code> por usted. Además, el KDJ incluye la herramienta 
      <code>serialver</code> para generar estos valores. Aquí están los documentos tanto para 
      <a href="http://docs.oracle.com/javase/8/docs/technotes/tools/windows/serialver.html">Windows</a> como 
      <a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/serialver.html">Unix</a>. (El nombre de clase que pasa a 
      esta herramienta no incluye la extensión <code>.class</code>).
    </p>
    <p>
      <code>readObject</code> y <code>writeObject</code>:
    </p>
    <ul>
      <li>las implementaciones de <code>readObject</code> siempre empiezan llamando a los métodos predeterminados</li>
      <li>
        La deserialiación debe ser tratada como cualquier constructor: valide el estado del objeto al final de la deserialización - 
        esto implica que <code>readObject</code> casi siempre debería implementarse en clases <code>Serializable</code>, de modo que 
        esta validación se realize.
      </li>
      <li>
        la deserialización debe ser tratada como cualquier constructor: si los constructores hacen copias defensivas para los 
        campos de objetos mutables, también debe <code>readObject</code>
        
      </li>
      <li>
        cuando serialize una <code>Collection</code>, almacene el número de objetos en la <code>Collection</code> también, y use 
        este número para leerlos de vuelta en cada deserialización; evite trucos usando <code>null</code>
      </li>
    </ul>
    Otros puntos:
    <ul>
      <li>use la etiqueta <code>@serial</code> de javadoc para denotar campos 
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/Serializable.html">Serializable</a></code>
      </li>
      <li>la extensión <code>.ser</code> se usa convecionalmente para ficheros que representan objetos serializados</li>
      <li>ningún campo <code>static</code> o <code>transient</code> se somete a una serialización predeterminada</li>
      <li>las clases extensibles no deben ser <code>Serializable</code>, a menos que sea necesario</li>
      <li>las clases internas rara vez, o nunca, deben implementar <code>Serializable</code></li>
      <li>
        las clases contenedoreas deben seguir usualmente el estilo de <code>Hashtable</code>, que implementa 
        <code>Serializable</code> almacenando claves y valores, a diferencia de una gran estructura de datos de tabla hash
      </li>
    </ul>
    <b>Ejemplo</b>
    <br />
    <pre>
<span class="keyword">import</span> java.io.Serializable;
<span class="keyword">import</span> java.text.StringCharacterIterator;
<span class="keyword">import</span> java.util.*;
<span class="keyword">import</span> java.io.*;

<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> SavingsAccount <span
            class="keyword">implements</span> Serializable {

   <span class="comment">/**
   * Este constructor requiere que se pasen todos los campos como parámetros.
   *
   * @param aFirstName contiene solo letras, espacios, y apóstrofes.
   * @param aLastName contains solo letras, espcios, y apostrofes.
   * @param aAccountNumber es no negativo.
   * @param aDateOpened tiene un número no negativo de milisegundos.
   */</span>
   <span class="keyword">public</span> SavingsAccount(
     String aFirstName, String aLastName, <span class="keyword">int</span> aAccountNumber, Date aDateOpened
   ){
     setFirstName(aFirstName);
     setLastName(aLastName);
     setAccountNumber(aAccountNumber);
     <span class="comment">//hace una copia defensiva del Date mutable pasado al constructor
</span>     setDateOpened(<span class="keyword">new</span> Date(aDateOpened.getTime()));
     <span class="comment">//no hay necesidad aquí de llamar a validateState.
</span>   }

   <span class="keyword">public</span> SavingsAccount(){
     <span class="keyword">this</span>(<span class="literal">"FirstName"</span>, <span
            class="literal">"LastName"</span>, <span class="literal">0</span>, <span
            class="keyword">new</span> Date(System.currentTimeMillis()));
   }

   <span class="keyword">public</span> String getFirstName(){
     <span class="keyword">return</span> fFirstName;
   }

   <span class="keyword">public</span> String getLastName(){
     <span class="keyword">return</span> fLastName;
   }

   <span class="keyword">public</span> <span class="keyword">int</span> getAccountNumber(){
     <span class="keyword">return</span> fAccountNumber;
   }

   <span class="comment">/**
   * Devuelve una copia defensiva del campo.
   * El llamador puede cambiar el estado del objeto devuelto en cualquier forma,
   * sin afectar el interior de esta clase.
   */</span>
   <span class="keyword">public</span> Date getDateOpened() {
     <span class="keyword">return</span> <span class="keyword">new</span> Date(fDateOpened.getTime());
   }

   <span class="comment">/**
   * Los nombres deben contener solo letras, espacios, y apóstrofes.
   * Validar antes de establecer el campo al nuevo valor.
   *
   * @throws IllegalArgumentException si el nuevo valor no es aceptable.
   */</span>
   <span class="keyword">public</span> <span class="keyword">void</span> setFirstName(String aNewFirstName) {
     validateName(aNewFirstName);
     fFirstName = aNewFirstName;
   }

   <span class="comment">/**
   * Los nombres deben contener solo letras, espacios, y apóstrofes.
   * Validar antes de establecer el campo al nuevo valor.
   *
   * @throws IllegalArgumentException si el nuevo valor no es aceptable.
   */</span>
   <span class="keyword">public</span> <span class="keyword">void</span> setLastName (String aNewLastName) {
     validateName(aNewLastName);
     fLastName = aNewLastName;
   }

   <span class="comment">/**
   * Validar antes de establecer el campo al nuevo valor.
   *
   * @throws IllegalArgumentException si el nuevo valor no es aceptable.
   */</span>
   <span class="keyword">public</span> <span class="keyword">void</span> setAccountNumber(<span
            class="keyword">int</span> aNewAccountNumber){
     validateAccountNumber(aNewAccountNumber);
     fAccountNumber = aNewAccountNumber;
   }

   <span class="keyword">public</span> <span class="keyword">void</span> setDateOpened(Date aNewDate){
     <span class="comment">//make a defensive copy of the mutable date object
</span>     Date newDate = <span class="keyword">new</span> Date(aNewDate.getTime());
     validateDateOpened(newDate);
     fDateOpened = newDate;
   }

   <span class="comment">// PRIVADO
</span>
   <span class="comment">/**
   * El nombre del cliente.
   * @serial
   */</span>
   <span class="keyword">private</span> String fFirstName;

   <span class="comment">/**
   * El apellido del cliente.
   * @serial
   */</span>
   <span class="keyword">private</span> String fLastName;

   <span class="comment">/**
   * El número de cuenta del cliente.
   * @serial
   */</span>
   <span class="keyword">private</span> <span class="keyword">int</span> fAccountNumber;

   <span class="comment">/**
   * La fecha en la que la cuenta fue abierta.
   * @serial
   */</span>
   <span class="keyword">private</span> Date fDateOpened;

   <span class="comment">/**
   * Determina si un fichero deserializado es compatible con esta clase.
   *
   * Los mantenedores deben cambiar este valor si y solo si la nueva versión
   * de esta clase no es compatible con versiones viejas. Vea los documentos de Sun 
   * para &lt;a href=http://java.sun.com/products/jdk/1.1/docs/guide
   * /serialization/spec/version.doc.html&gt; los detalles. &lt;/a&gt;
   *
   * No es necesario incluir en la primera versión de la clase, pero 
   * incluído aquí como un recordatorio de su importancia.
   */</span>
   <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span
            class="literal">7526471155622776147L</span>;

   <span class="comment">/**
   * Verifica que todos los campos de este objeto toman valores permisibles; esto es, 
   * este método define la clase invariante.
   *
   * En este estilo de implementación, el estado entero del objeto 
   * y sus campos individuales pueden ser validados sin repetir o 
   * duplicar código.
   * Cada condición se define en un lugar. Las comprobaciones de todo el objeto 
   * se realizan al final de la construcción del objeto 
   * y al final de la deserialización. Las comprobaciones de los campos individuales se 
   * realizan al comienzo del método setXXX correspondiente.
   * Además, este estilo reemplaza los if y el lanzamiento 
   * de excepciones al comienzo de un setXXX, con una simple llamada a validateXXX.
   * La validación está separada de la ruta regular de ejecución, 
   * lo que conduje a una mejor legibilidad.
   *
   * @throws IllegalArgumentException si cualquier campo toma un valor no permitido.
   */</span>
   <span class="keyword">private</span> <span class="keyword">void</span> validateState() {
     validateAccountNumber(fAccountNumber);
     validateName(fFirstName);
     validateName(fLastName);
     validateDateOpened(fDateOpened);
   }

   <span class="comment">/**
   * Se asegura que los nombres contienen solo letras, espacioes, y apóstrofes.
   *
   * @throws IllegalArgumentException si el campo toma un valor no permitido.
   */</span>
   <span class="keyword">private</span> <span class="keyword">void</span> validateName(String aName){
     <span class="keyword">boolean</span> nameHasContent = (aName != <span
            class="keyword">null</span>) &amp;&amp; (!aName.equals(<span
            class="literal">""</span>));
     <span class="keyword">if</span> (!nameHasContent){
       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span
            class="literal">"Los nombres no deben ser nulos ni estar vacíos."</span>);
     }
     StringCharacterIterator iterator = <span class="keyword">new</span> StringCharacterIterator(aName);
     <span class="keyword">char</span> character = iterator.current();
     <span class="keyword">while</span> (character != StringCharacterIterator.DONE){
       <span class="keyword">boolean</span> isValidChar =
         (Character.isLetter(character) ||
         Character.isSpaceChar(character) ||
         character ==<span class="literal">'\''</span>
       );
       <span class="keyword">if</span> (isValidChar) {
         <span class="comment">//no hace nada
</span>       }
       <span class="keyword">else</span> {
         String message = <span class="literal">"Los nombres solo pueden contener letras, espacios y apóstrofos."</span>;
         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(message);
       }
       character = iterator.next();
     }
  }

  <span class="comment">/**
  * AccountNumber debe ser no negativo.
  * @throws IllegalArgumentException si el campo toma un valor no permitido.
  */</span>
   <span class="keyword">private</span> <span class="keyword">void</span> validateAccountNumber(<span
            class="keyword">int</span> aAccountNumber){
     <span class="keyword">if</span> (aAccountNumber &lt; <span
            class="literal">0</span>) {
       String message = <span class="literal">"El número de cuenta debe ser mayor o igual a 0."</span>;
       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(message);
     }
   }

  <span class="comment">/**
  * DateOpened debe ser después de 1970.
  * @throws IllegalArgumentException si el campo toma un valor no permitido.
  */</span>
   <span class="keyword">private</span> <span class="keyword">void</span> validateDateOpened(Date aDateOpened) {
     <span class="keyword">if</span>(aDateOpened.getTime() &lt; <span
            class="literal">0</span>) {
       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span
            class="literal">"La fecha de apertura debe ser posterior a 1970."</span>);
     }
   }

   <span class="comment">/**
   * Siempre trata la deserialización como un constructor en toda regla, 
   * validando el estado final del objeto deserializado.
   */</span>
   <span class="keyword">private</span> <span class="keyword">void</span> readObject(
     ObjectInputStream aInputStream
   ) <span class="keyword">throws</span> ClassNotFoundException, IOException {
     <span class="comment">//siempre realiza la deserialización predeterminada primero
</span>     aInputStream.defaultReadObject();

     <span class="comment">//hace una copia defensiva del campo mutable Date
</span>     fDateOpened = <span class="keyword">new</span> Date(fDateOpened.getTime());

     <span class="comment">//se asegura que el estado del objeto no ha sido corrompido o manipulado maliciosamente
</span>     validateState();
  }

    <span class="comment">/**
    * Esta es la implementación predeterminada de writeObject.
    * Personalizar si es necesario.
    */</span>
    <span class="keyword">private</span> <span class="keyword">void</span> writeObject(
      ObjectOutputStream aOutputStream
    ) <span class="keyword">throws</span> IOException {
      <span class="comment">//realizar la serialización predeterminada para todos los campos no transitorios y no estáticos
</span>      aOutputStream.defaultWriteObject();
    }
} 
    </pre>
    <br />
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\patrones\patrones_1.html">Enumeraciones seguras</a><br />
      <a href="..\patrones\patrones_46.html">Singleton</a><br />
      <a href="..\serializacion\serializacion_70.html">Serialización y generación de subclases</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>