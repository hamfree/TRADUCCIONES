<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Tenga cuidado de los trucos habituales</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
    <style>
      TD {
        border: 1px inset;
      }
    </style>
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Búsqueda" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">Tenga cuidado de los trucos habituales</div>
    <br />
    <h3>Ataques de Inyección de SQL</h3>
    Los <a href="http://www.owasp.org/index.php/SQL_Injection">ataques de inyección de SQL</a> Utilice entradas de usuario inusuales 
    y elaboradas para hacer que se ejecuten sentencias SQL no deseadas. Una aplicación es vulnerable a tales ataques siempre que 
    construya sentencias SQL directamente a partir de la entrada sin procesar del usuario. Si una aplicación construye las 
    sentencias SQL a partir de la entrada del usuario utilizando <code>PreparedStatement</code>
    <a href="../bbdd/bbdd_212.html"><i>correctamente</i></a>, entonces estará protegida de los ataques de inyección de SQL. Si, por 
    por otro lado, usa <code>Statement</code> para construir el SQL dinámicamente, o usa 
    <code>PreparedStatement</code> <i>incorrectamente</i> entonces <em>no</em> estará protegida de tales ataques.
    <h3>Ataques de Secuencias de Comandos Entre Sitios (XSS en inglés)</h3>
    HTML permite la creación de scripts. La creación de scripts necesita algo de cuidado extra, ya que permite que toda clase de 
    código se ejecute en el cliente, donde tiene acceso al entorno privado del usuario.
    <span class="highlight">Si usted no tiene cuidado, es <em>muy fácil</em> crear aplicaciones web que permitan a los usuarios 
      introducir scripts maliciosos como datos regulares, dentro de formularios o URLs. Cuando tal entrada maliciosa es después 
      obtenida de la base de datos y presentada en una vista, está disponible para su ejecución por parte del navegador.</span>
    <p>
      Tenga en cuenta que tales scripts se ejecutarán en <em>cualquier</em> navegador que presente los datos, no solo en el 
      navegador del delincuente informático que realizó la introducción del script. Cuando el script malicioso se ejecuta en el 
      navegador de la víctima inocente, obtiene acceso a información sensible, y la envía de vuelta al delicuente informático. A 
      esto se le llama un ataque de 
      <a href="http://www.owasp.org/index.php/Cross_Site_Scripting">Secuencia de Comandos Entre Sitios</a> (XSS).
    </p>
    <p>
      Para prevenir los ataques XSS, pregúntese dos cuestiones:
    </p>
    <ul>
      <li>¿puede este control de formulario aceptar un script como entrada?</li>
      <li>si es así, ¿como será deshabilitado el script cuando la entrada de usuario finalmente se represente en una página?</li>
    </ul>
    Tomemos este formulario simulado como ejemplo (el <code>POST</code>ing de este formulario no hace nada):
    <p></p>
    <form method="GET" action="servlets_217.html">
      <table style="margin: 0 auto;">
        <tbody>
          <tr>
            <td>Título de la Película:</td>
            <td><input name="Title" type="text"></td>
          </tr>
          <tr>
            <td>Década de la Película:</td>
            <td><select>
                <option selected="selected">2000</option>
                <option>1990</option>
                <option>1980</option>
                <option>1970</option>
                <option>1960</option>
                <option>1950</option>
                <option>1940</option>
                <option>1930</option>
                <option>1920</option>
              </select></td>
          </tr>
          <tr>
            <td colspan="2"><input value="Enviar" type="submit"></td>
          </tr>
          <tr>
            <td colspan="2"></td>
          </tr>
        </tbody>
      </table>
    </form>
    <p></p>
    <p>
      Cuando el usuario POSTs (publica) este formulario, los datos siempre deben ser validados por el servidor con la mayor firmeza 
      posible. Por ejemplo, la <code>Década de la Película</code> debe comprobarse contra un conjunto fijo de valores, para 
      asegurarse de que el formulario no ha sido alterado por un usuario malicioso. Si la <code>Década de la Película</code> está 
      realmente comprobada de tal manera, entonces no es posible que el usuario ingrese un script arbitrario como valor para la 
      década. <em>Si se realizan comprobaciones tan rigurosas</em>, no se necesitan precauciones especiales contra los ataques XSS.
    </p>
    <p>
      El <code>Título de la Película</code> es una historia diferente, sin embargo. Dado que es una entrada de usuario de forma 
      libre, no es posible restringir estrictamente el <code>Título de la Película</code>. El servidor no puede realizar 
      comprobaciones estrictas de su contenido, dado que no hay 'lista blanca' de valores permitidos.
    </p>
    <p>
      En este caso, el usuario puede ingresar un script. <span class="highlight">Para prevenir que se active el script cuando se 
        presente en una página como datos normales, se debe tener especial cuidado: cualquier carácter especial en la entrada de 
        usuario de forma libre debe ser escapado.</span> El Proyecto de Seguridad de la Web Abierta recomienda que escape estos 12 
      caracteres:
    </p>
    <p></p>
    <table style="margin: 0 auto; border-spacing: 1px;">
      <tbody>
        <tr>
          <th>Carácter</th>
          <th>Codificación</th>
        </tr>
        <tr>
          <td>&lt;</td>
          <td>&amp;lt;</td>
        </tr>
        <tr>
          <td>&gt;</td>
          <td>&amp;gt;</td>
        </tr>
        <tr>
          <td>&amp;</td>
          <td>&amp;amp;</td>
        </tr>
        <tr>
          <td>"</td>
          <td>&amp;quot;</td>
        </tr>
        <tr>
          <td>'</td>
          <td>&amp;#039;</td>
        </tr>
        <tr>
          <td>(</td>
          <td>&amp;#040;</td>
        </tr>
        <tr>
          <td>)</td>
          <td>&amp;#041;</td>
        </tr>
        <tr>
          <td>#</td>
          <td>&amp;#035;</td>
        </tr>
        <tr>
          <td>%</td>
          <td>&amp;#037;</td>
        </tr>
        <tr>
          <td>;</td>
          <td>&amp;#059;</td>
        </tr>
        <tr>
          <td>+</td>
          <td>&amp;#043;</td>
        </tr>
        <tr>
          <td>-</td>
          <td>&amp;#045;</td>
        </tr>
      </tbody>
    </table>
    <p></p>
    <p>
      El escapado se puede realizar en varios lugares:
    </p>
    <ul>
      <li>en la vista, cuando los datos finalmente se procesan</li>
      <li>en el Modelo de Objetos</li>
      <li>en la base de datos</li>
    </ul>
    <p>
      La herramienta <a href="http://www.web4j.com/UserGuide.jsp#XSS">WEB4J</a>, por ejemplo, recomienda realizar el escapado en el 
      Modelo de Objetos, usando su clase <code>SafeText</code> para modelar la entrada de libre forma del usuario en vez de 
      <code>String</code>.
    </p>
    <p>
      En cualquier caso, recuerde que los datos <a href="../servlets/servlets_201.html"> no deben ser escapados más de una vez</a>.
    </p>
    <p>
      Tenga en cuenta también que la etiqueta de JSTL <code>&lt;c:out&gt;</code> realiza el escapado solo para <em>XML</em> 
      (5 caracteres), y no para <em>HTML</em> (12 caracteres). Además, tenga en cuenta que el Lenguaje de Expresión JSP no realiza 
      el escapado en absoluto.
    </p>
    <h3>Ataques de Falsificación de Solicitudes Entre Sitios (CSRF en inglés)</h3>
    La idea fundamental en un ataque (CSRF) de 
    <a href="http://www.owasp.org/index.php/Cross-Site_Request_Forgery">Falsificación de Solicitud Entre Sitios</a> 
    es el de secuestrar la sesión de una víctima para realizar una tarea maliciosa. Dado que la sesión está disponible para el 
    delincuente, este puede realizar tareas que de otro modo no serían posibles.
    <p>
      Por ejemplo, considere una simple operación de cierre de sesión. En muchos sitios, el cierre de sesión se implmente con un 
      simple <em>link</em> (<code>GET</code>), y no un <code>POSTed form</code>. Un delincuente informático podría cerrar la sesión 
      de dicho sitio <em>simplemente enviándole un correo electrónico</em>. Aquí tiene el escenario:
    </p>
    <ul>
      <li>inicia sesión legítimamente en el sitio de destino</li>
      <li>el delicuente informático le envía un correo electrónico conteniendo una etiqueta <code>IMG</code> falsa cuyo atributo 
        <code>'src'</code> apunta al enlace de cierre de sesión
      </li>
      <li>usted recibe el correo electrónico y lo abre en algún cliente (mientras aún está conectado al sitio de destino)</li>
      <li>su cliente de correo analiza automáticamente el contenido del correo</li>
      <li>
        Cuando el cliente de correo encuentra la etiqueta <code>IMG</code>, extrae el destino <code>src</code> y 
        <em>envía una petición HTTP</em> <code>GET</code> <em>a través de la red</em>, aparentemente para buscar la 'imagen'
      </li>
      <li>¡bingo! ahora está desconectado, con solo abrir un correo electrónico</li>
    </ul>
    (Por esto es por lo que muchos clientes de correo suprimen la visualización de imágenes).
    <p>
      Defenderse contra los ataquets CSRF no es tan simple como defenderse contra los ataques XSS. Por lo general, las defensas 
      toman esta forma:
    </p>
    <ul>
      <li>
        <em>para operaciones que tienen efectos secundarios</em> de cualquier clase (ediciones en bases de datos, cierres de 
        sesión), usan un formulario con <code>method='POST'</code>
      </li>
      <li>
        <em>para operaciones que no tienen efectos secundarios</em> (listados, informes, operaciones de búsqueda), usan un 
        formulario con <code>method='GET'</code> o un enlace
      </li>
      <li>
        para cada usuario que inicia sesión, crear un token aleatorio difícil de adivinar y lo guarda en la sesión. Este token 
        (llamado también <i>nonce</i>, o, en español, un número que solo puede usarse una vez, muy utilizado en criptografía) se 
        inyecta como un parámetro oculto en cada formulario servidor por su aplicación. Para cada formulario <code>POST</code>ed, 
        el servidor verifica que está presente un parámetro oculto, y que es el valor esperado para la sesión actual. Todo esto 
        tiene la intención de responder a una simple pregunta: <em>'¿Este formulario publicado (POSTED) realmente vino originalmente 
          del servidor legítimo o de algún tercero desconocido?'</em>
      </li>
      <li>
        especifica el <code>content-type</code> de las respuesta como una cabecera HTTP. Cuando se usan tokens de formulario, el 
        <code>content-type</code> le permite saber a las herramientas que está sirviendo HTML - si usted está sirviendo texto plano 
        o XML (que no contiene un formulario), entonces no hay necesidad de inyectar tokens de formulario.
      </li>
    </ul>
    Su marco de trabajo de aplicaciones web debe asistirle a defenderse contra los ataquest CSRF. Con los servlets, es habitual 
    proporcionar un Filtro para generar y validar el token especial del formulario.
    <br />
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También:</div>
    <div id="see-also" class="main-body">
      <a href="../servlets/servlets_191.html">Administrar las sesiones de cerca</a><br />
      <a href="../servlets/servlets_201.html">Tenga cuidado de los ampersands doblemente escapados</a><br /> 
      <a href="../bbdd/bbdd_212.html">Prefiera PreparedStatement</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>