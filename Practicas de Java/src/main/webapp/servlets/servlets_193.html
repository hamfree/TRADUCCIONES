<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Practices-&gt;Struts parece mediocre</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Search" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">Struts parece mediocre</div>
    <br />
    El marco de trabajo frontal heredado <a href="https://struts.apache.org/struts1eol-announcement.html">Struts 1</a> fue una de 
    las primeras herramientas para aplicaciones web de java en ser publicada, y a la vez fue ampliamente usada.
    <p>
      (Llamar a Struts un "marco de aplicación" es inexacto. Struts asiste al desarrollador en la construcción solo del frontal de 
      una aplicación. Nada para la capa de modelo o la capa de base de datos. No es un marco de trabajo completo).
    </p>
    <p>
      Se puede argumentar con cierta fuerza que Struts 1 es una herramienta mediocre. Aquí hay algunas razones de por qué.
    </p>
    <p>
      <b>No hay políticas para traducir las peticiones de parámetros en objetos java comunes.</b>
    </p>
    <p>
      Todas las aplicaciones web de java necesitan traducir las peticiones crudas de valores de parámetro en elementos comunes 
      tales como un <code>Integer</code>, <code>Date</code>, y <code>BigDecimal</code>. Sin embargo, <i>Struts 1 no proporciona 
      soporte para esta tarea</i>. No define políticas predeterminadas razonables, ni anima al usuario a definir dichas políticas de 
      ninguna manera.
    </p>
    <p>
      <b>ActionForms son una estructura masiva paralela al modelo "real".</b>
    </p>
    <p>
      Las clases <code>ActionForm</code> no están pensadas como modelo real. Están pensadas como un buffer de validación preliminar 
      entre la petición cruda HTTP y la clase del modelo "real". (Por ejemplo, una <code>ActionForm</code> podría validar que una 
      petición de parámetro se pueda analizar en un <code>Integer</code>, mientras que la clase de modelo relacionada puede validar 
      que el <code>Integer</code> está dentro del rango <code>1..10</code>). <code>ActionForm</code>s incluye solo elementos 
      <code>String</code> y <code>boolean</code>, y nada más. Ya que <code>ActionForm</code>s y las clases de modelo existen como 
      un par, esto crea <i>un paralelismo masivo innecesario</i>.
    </p>
    <p>
      Este punto está íntimamente relacionado con el primero. Si las políticas definidas centralmente para traducir los parámetros 
      de petición en 
      <code>Integer</code>, <code>Date</code>, <code>BigDecimal</code>, y así, existieron, entonces los objetos del modelo podrían 
      construirse a partir de parámetros de solicitud más o menos directamente.
    </p>
    <p>
      Además, aunque Struts 1 requiere que los objetos del modelo se construyan a partir de <code>ActionForm</code>s relacionados, 
      no brinda apoyo directo al programador para realizar esta tarea.
    </p>
    <p>
      <b>La validación de datos se separa del Modelo de Objetos.</b>
    </p>
    <p>
      Una idea fundamental en la programación de objetos es unir los datos con las acciones relacionadas. Las aplicaciones de 
      negocio habituales son excelentes para ilustrar esta idea, ya que los datos de negocio usualmente tienen muchas 
      <em>validaciones</em> relacionadas. Así, el Modelo de Objetos debe habitualmente encapsular tanto los datos como las 
      validaciones. En Struts 1, sin embargo, la validación de datos está completamente <em>separada</em> del Modelo de Objetos. 
      ¿Porqué? ¿Por qué los creadores de Struts 1 han perdido de vista una idea tan fundamental y básica en la programación de 
      objetos? No parece tener ninguna justificación.
    </p>
    <p>
      <b>Los formularios HTML estándar no se usan.</b>
    </p>
    <p>
      En Struts 1, los formularios suelen diferir ampliamente del HTML estándar, y está usualmente implementada con un específico 
      conjunto de etiquetas personalizadas. Esto no es ni necesario ni deseable. No es necesario ya que otras herramientas han 
      demostrado que los formularios rellenados dinámicamente pueden simplemente reutilizar los formularios estándar HTML como 
      parte de su implementación. No es deseable ya que el autor de la página no puede reutilizar su conocimiento del HTML estándar, 
      pero se ve obligado a aprender un nuevo conjunto de etiquetas personalizadas específicas de Struts 1. Esto no es productivo.
    </p>
    <p>
      <b>Las acciones deben ser seguras para los subprocesos.</b>
    </p>
    <p>
      Las <code>Action</code>s son siempre almacenadas en caché y reutilizadas por Struts 1. Esto es tanto una optimización de 
      rendmiento como una restricción, ya que esto requiere que las <code>Action</code>s sean seguras para utilizar en un entorno 
      multiproceso.
    </p>
    <p>
      Como una optimización de rendimiento, esta política es de dudosa calidad. Los rastros de pila de un contenedor web son 
      grandes. Si una <code>Action</code> es "sólo otro objeto", es de muy poco beneficio guardarla en caché y reusarla. Por otro 
      lado, los diseños en los que una <code>Action</code> mantiene una referencia a un objeto costoso (tal como una conexión a la 
      base de datos) son a menudo inferiores.
    </p>
    <p>
      Como una restricción, Joshua Bloch explica claramente en 
      <i><a href="http://www.amazon.com/exec/obidos/ASIN/0134685997/ref=nosim/javapractices-20">Java Efectivo</a></i> que asegurar 
      que una clase sea utilizable en un entorno multiproceso no es una tarea no trivial. Forzar que todas las implementaciones de 
      <code>Action</code> sean seguras en entornos multiproceso parece un requerimiento oneroso que tiene un beneficio dudoso. Por 
      ejemplo, en una <code>Action</code> de Struts 1, los datos compartidos entre métodos no pueden ser almacenados en un campo; 
      más bien, debe pasarse como parámetro.
    </p>
    <p>
      <b>Struts 1 es una implementación nada impresionante del patrón Comando.</b>
    </p>
    <p>
      El método <code>execute</code> tiene cuatro argumentos, que deben siempre ser pasados, independientemente de si el argumento 
      es realmente relevante para una acción en particular. En el libro <i>Patrones de Diseño</i>, el número de argumentos al 
      método <code>execute</code> es exactamente cero. Hay una buena razón para esto, y se ilustra por casi cada patrón de diseño 
      en el libro de la Banda de los Cuatro: los métodos centrales de cualquier diseño están libres de detalles de implementación. 
      Los datos necesitados por la implementación de una abstracción casi siempre se pasan a un <i>constructor</i>. Esto mantiene 
      las abstracciones limpias, y coloca los datos específicos a la implementación en un lugar donde la herencia y el polimorfismo 
      no aplican (el constructor).
    </p>
    <p>
      Además, Struts 1 siempre requiere que se realize una conversión en una <code>Action</code>, para obtener acceso a una 
      <code>ActionForm</code> específica. Las conversiones son algo a evitar a menos que sean absolutamente necesario, ya que 
      tienden a provocar errores en tiempo de ejecución.
    </p>
    <p>
      La herramienta <a href="../servlets/servlets_188.html">web4j</a> fue construida debido a la fuerte insatisfacción con el 
      marco de trabajo frontal de Struts 1.<br />
    </p>
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También:</div>
    <div id="see-also" class="main-body">
      <a href="../servlets/servlets_138.html">Analizar parámetros en objetos de dominio</a><br /> 
      <a href="../patrones/patrones_139.html">Objetos Command</a><br />
      <a href="../servlets/servlets_177.html">Rellene de antemano los formularios</a><br /> 
      <a href="../servlets/servlets_188.html">WEB4J, Un Marco de trabajo de Aplicaciones WEB </a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>