<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Enumeraciones seguras</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Búsqueda" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">Enumeraciones seguras</div>
    <br />
    Las enumeraciones son conjuntos de elementos relacionados estrechamente, por ejemplo:
    <ul>
      <li>direcciones cardinales - norte, sur, este, oeste</li>
      <li>géneros de novelas - misterio, clásico, fantasía, romántica, ciencia ficción</li>
      <li>sabores de helado - chocolate, vainilla, frambuesa, arce</li>
    </ul>
    Las <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/language/enums.html">Enumeraciones de tipo seguro</a> (también 
    llamada "tipos enum", o simplemente "enums") fueron agregadas al lenguaje Java en el KDJ 1.5, y representan un tipo especial 
    de clase. Si el KDJ 1.5 no está disponible, las enumeraciones de tipo seguro pueden ser aún 
    <a href="#Legacy">implementadas como una clase regular de Java</a>.
    <p>
      Las enumeraciones de tipo seguro deben usarse libremente. En particular, son una alternativa robusta a las constantes simples 
      <code>String</code> o <code>int</code> usadas en muchas IPAs más antiguas que representan conjuntos de elementos relacionados.
    </p>
    <p>
      Recordatorios:
    </p>
    <ul>
      <li>
        las enumeraciones son subclases implícitamente <code>final</code> de 
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Enum.html">java.lang.Enum</a></code>
      </li>
      <li>si una enumeración es un miembro de una clase, esta es implícitamente <code>static</code></li>
      <li><code>new</code> no se puede usar nunca con una enumeración, incluso con el propio tipo enum</li>
      <li>
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Enum.html#name()">name</a></code> and 
        <code>
          <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Enum.html#valueOf(java.lang.Class,java.lang.String)">valueOf</a>
        </code> simplemente usan el texto de las constantes de enumeración, mientras que <code>toString</code> puede ser 
        sobreescrito para proporcionar cualquier contenido, si se desea
      </li>
      <li>
        para constantes de enumeración, <code>equals</code> and <code>==</code> equivalen a lo mismo, y pueden ser utilizados 
        indistintamente
      </li>
      <li>las constantes de enumeración son implícitamente <code>public static final</code></li>
      <li>
        el orden de aparición de las constantes de enumeración se llama "orden natural", y define el orden utilizado por otros 
        elementos también: 
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Enum.html#compareTo(E)">compareTo</a></code>, el orden 
        de iteración de <code>values</code> , 
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/util/EnumSet.html">EnumSet</a></code>, 
        <code>EnumSet.range</code>.
      </li>
      <li>
        las enumración tienen un mecanismo integrado de 
        <a href="http://docs.oracle.com/javase/6/docs/platform/serialization/spec/serial-arch.html#6469">serialization</a> 
        que no puede ser sobreescrito. El mecanismo usa los métodos 
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Enum.html#name()">name</a></code> y
        <code>
          <a
            href="https://docs.oracle.com/javase/10/docs/api/java/lang/Enum.html#valueOf(java.lang.Class,java.lang.String)">valueOf</a>
        </code>.
      </li>
    </ul>
    Advertencia:
    <p>
      Al igual que con cualquier clase, es fácil proporcionar métodos en un tipo de enumeración que cambian el estado de una 
      constante de enumeración. Por lo tanto, el término "constante de enumeración" es bastante engañoso. Lo que es constante es la 
      <i>identidad</i> del elemento enum, no su estado. Quizás un término mejor hubiera sido "elemento de enumeración" en lugar de 
      "constante de enumeración".
    </p>
    <p>
      Los constructores para un tipo de enumeración deben ser declarados como <code>private</code>. El compilador permite 
      declaraciones no <code>private</code> para los constructores, pero esto parece engañoso para el lector, ya que 
      <code>new</code> nunca se puede usar con tipos de enumeración.
    </p>
    <p>
      Aquí tiene algunso ejemplos simples de definición y uso de enumeraciones: <br />
    </p>
    <pre>
<span class="keyword">import</span> java.util.EnumSet;

<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> EnumExamples {

  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> <span class="keyword">void</span> main(String... aArgs){
    log(<span class="literal">"Ejercicio de enumeraciones ..."</span>);
    exerEnumsMiscellaneous();
    exerMutableEnum();
    exerEnumRange();
    exerBitFlags();
    exerEnumToStringAndValueOf();
    log(<span class="literal">"Hecho."</span>);
  }

  <span class="comment">// PRIVADO //
</span>  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> log(Object aText){
    System.out.println(String.valueOf(aText));
  }

  <span class="comment">/** Ejemplo 1 - lista simple de constantes de enumeración.  */</span>
  <span class="keyword">enum</span> Quark {
    <span class="comment">/*
    * Estos se denominan "constantes de enumeración".
    * Un tipo de enumeración no tiene más instancias que aquellas definidas por sus 
    * constantes de enumeración. Estas son implícitamente "public static final".
    * Cada constante de enumeración corresponde a una llamada a un constructor.
    * Cuando no se adjuntan argumentos a una constante de enumeración, entonces se usa el constructor sin argumentos 
    * para crear el objeto correspondiente.
    */</span>
    UP,
    DOWN,
    CHARM,
    STRANGE,
    BOTTOM,
    TOP
  }
  
  <span class="comment">//no compila ya que Quark es "implícitamente final":
</span>  <span class="comment">//private static class Quarky extends Quark {}
</span>
  <span class="comment">/**
  * Ejemplo 2 - agregando un constructor a una enumeración.
  *
  * Si no se agrega un constructor, después es creado por el sistema 
  * el usual constructor por defecto, y las declaraciones de las 
  * constantes de enumeración corresponderán a llamar a este constructor por defecto.
  */</span>
  <span class="keyword">public</span> <span class="keyword">enum</span> Lepton {
    <span class="comment">//cada constante implícitamente llama a un constructor :
</span>    ELECTRON(-<span class="literal">1</span>, <span class="literal">1.0E-31</span>),
    NEUTRINO(<span class="literal">0</span>, <span class="literal">0.0</span>);
    
    <span class="comment">/* 
    * Este constructor es privado.
    * Es legal declarar un constructor no privado, pero no es legal
    * usar tal constructor fuera de la enumeración.
    * Nunca puede usar "new" con ninguna enumeración, incluso dentro de la propia 
    * clase de enumeración.
    */</span>
    <span class="keyword">private</span> Lepton(<span class="keyword">int</span> aCharge, <span
            class="keyword">double</span> aMass){
      <span class="comment">//no pudde llamar al constructor de super aquí
</span>      <span class="comment">//las llamadas a "este" constructor son permitidas
</span>      fCharge = aCharge;
      fMass = aMass;
    }
    <span class="keyword">final</span> <span class="keyword">int</span> getCharge() {
      <span class="keyword">return</span> fCharge;
    }
    <span class="keyword">final</span> <span class="keyword">double</span> getMass() {
      <span class="keyword">return</span> fMass;
    }
    <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">int</span> fCharge;
    <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">double</span> fMass;
  }

  <span class="comment">/**
  * Ejemplo 3 - agregando métodos a una enumeración.
  *
  * Aquí, "static" puede omitirse, ya que los tipos de enumeración que son miembros de la clase 
  * son implícitamente estáticos. 
  */</span>
  <span class="keyword">static</span> <span class="keyword">enum</span> Direction {
    NORTH,
    SOUTH,
    EAST,
    WEST; <span class="comment">//el punto y coma es solo necesario cuando se extiende el comportamiento
</span>    
    <span class="comment">//las anulaciones y las adiciones van aquí, debajo de las constantes de enumeración
</span>
    <span class="keyword">@Override</span> <span class="keyword">public</span> String toString(){
      <span class="comment">/*
      * Se puede llamar a name() o super.toString() aquí.
      * name() es final, y siempre devuelve el nombre exacto tal como se especificó en la 
      * declaración; toString() no es final, y está destinada para la presentación 
      * al usuario. Parece mejor llamar a name() aquí.
      */</span>
      <span class="keyword">return</span> <span class="literal">"Direction: "</span> + name();
    }
    <span class="comment">/** An added method.  */</span>
    <span class="keyword">public</span> <span class="keyword">boolean</span> isCold() {
      <span class="comment">//solo NORTH es 'frío'
</span>      <span class="keyword">return</span>  <span class="keyword">this</span> == NORTH;
    }
  }

  <span class="comment">/**
  * Ejemplo  4 - agregando un método que cambia el estado de las constantes de enumeración.
  */</span>
  <span class="keyword">private</span> <span class="keyword">enum</span> Flavor {
    CHOCOLATE(<span class="literal">100</span>),
    VANILLA(<span class="literal">120</span>),
    STRAWBERRY(<span class="literal">80</span>);
    
    <span class="keyword">void</span> setCalories(<span class="keyword">int</span> aCalories){
      <span class="comment">//cambia el estado de la 'constante' de enumeración
</span>      fCalories = aCalories;
    }
    <span class="keyword">int</span> getCalories(){
      <span class="keyword">return</span> fCalories;
    }
    <span class="keyword">private</span> Flavor(<span class="keyword">int</span> aCalories){
      fCalories = aCalories;
    }
    <span class="keyword">private</span> <span class="keyword">int</span> fCalories;
  }
  
  <span class="comment">/*
  * Lo que sigue son diversos métodos que ejercitan las enumeraciones anteriores.
  */</span>

  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> exerEnumsMiscellaneous(){
    <span class="comment">//el método toString por defecto usa el identificador
</span>    log(<span class="literal">"toString: "</span> + Quark.BOTTOM);

    <span class="comment">//equals y  == equivalen a lo mismo 
</span>    <span class="keyword">if</span> ( Quark.UP == Quark.UP ) {
      log(<span class="literal">"UP == UP"</span>);
    }

    <span class="keyword">if</span> ( Quark.UP.equals(Quark.UP) ) {
      log(<span class="literal">"UP.equals(UP)"</span>);
    }

    <span class="comment">//el orden de compareTo order se define por el orden de aparición en la definición de 
</span>    <span class="comment">//la enumeración
</span>    <span class="keyword">if</span> ( Quark.UP.compareTo(Quark.DOWN) &lt; <span
            class="literal">0</span> ) {
      <span class="comment">//se elije esta rama
</span>      log(<span class="literal">"UP antes que DOWN"</span>);
    }
    <span class="keyword">else</span> <span class="keyword">if</span> ( Quark.UP.compareTo(Quark.DOWN) &gt; <span
            class="literal">0</span> ) {
      log(<span class="literal">"DOWN antes que UP"</span>);
    }
    <span class="keyword">else</span> {
      log(<span class="literal">"UP igualq que DOWN"</span>);
    }

    <span class="comment">//values() devuelve Quark[], no una List&lt;Quark&gt;
</span>    log(<span class="literal">"Valores de Quark : "</span> + Quark.values());
    <span class="comment">//el orden de los valores coincide con el orden de aparición:
</span>    <span class="keyword">for</span> ( Quark quark : Quark.values() ){
      log(<span class="literal">"Elemento en Quark.values() : "</span> + quark);
    }

    log(<span class="literal">"toString : "</span> + Direction.NORTH);
    <span class="keyword">if</span> ( Direction.EAST.isCold() ){
      log(<span class="literal">"El Este es frío"</span>);
    }
    <span class="keyword">else</span> {
      log(<span class="literal">"El Este no es frío."</span>);
    }

    log(<span class="literal">"Carga del Electrón: "</span> + Lepton.ELECTRON.getCharge());

    <span class="comment">//analizando el texto en una constante de enumeración :
</span>    Lepton lepton = Enum.valueOf(Lepton.<span class="keyword">class</span>, <span
            class="literal">"ELECTRON"</span>);
    log(<span class="literal">"Mas del Leptón: "</span> + lepton.getMass());

    <span class="comment">//lanza una IllegalArgumentException si el tipo de enumeración no conoce el texto:
</span>    <span class="keyword">try</span> {
      Lepton anotherLepton = Enum.valueOf(Lepton.<span class="keyword">class</span>, <span
            class="literal">"Protón"</span>);
    }
    <span class="keyword">catch</span> (IllegalArgumentException ex){
      log(<span class="literal">"El Protón no es un Leptón."</span>);
    }

    <span class="comment">//Estilo más compacto para analizar texto:
</span>    Lepton thirdLepton = Lepton.valueOf(<span class="literal">"NEUTRINO"</span>);
    log(<span class="literal">"Carga del Neutrino : "</span> + thirdLepton.getCharge() );
  }
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> exerMutableEnum(){
    Flavor.VANILLA.setCalories(<span class="literal">75</span>); <span
            class="comment">//cambia el estado de la "constante" de enumeración
</span>    log(<span class="literal">"Calorías en la Vainilla: "</span> + Flavor.VANILLA.getCalories());
  }
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> exerEnumRange(){
    <span class="keyword">for</span> (Direction direction : EnumSet.range(Direction.NORTH, Direction.SOUTH)){
      log(<span class="literal">"NORTH-SOUTH: "</span> + direction);
    }
  }

  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> exerBitFlags(){
    EnumSet&lt;Direction&gt; directions = EnumSet.of(Direction.EAST, Direction.NORTH);
    <span class="keyword">for</span>(Direction direction : directions) {
      log(direction);
    }
  }

  <span class="comment">/**
  * El método valueOf method usa name(), no toString(). No hay necesidad 
  * de sincronizar valueOf con toString.
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> exerEnumToStringAndValueOf(){
    Direction dir = Direction.valueOf(<span class="literal">"EAST"</span>); <span
            class="comment">//exitoso
</span>    log(<span class="literal">"Direction toString : "</span> + dir);
    dir = Direction.valueOf(<span class="literal">"Direction: EAST"</span>); <span
            class="comment">//falla
</span>  }
}
 
    </pre>
    Aquí tiene un ejemplo simple de uso de <code>EnumSet</code>:
    <br />
    <pre>
<span class="keyword">import</span> java.util.*;

<span class="keyword">public</span> <span class="keyword">class</span> CommonLanguage {
  
  <span class="keyword">enum</span> Lang {ENGLISH, FRENCH, URDU, JAPANESE}

  <span class="comment">/** Encuentra los idiomas en común entre dos personas. */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> main(String... aArgs){
    EnumSet&lt;Lang&gt; ariane = EnumSet.of(Lang.FRENCH, Lang.ENGLISH);
    EnumSet&lt;Lang&gt; noriaki = EnumSet.of(Lang.JAPANESE, Lang.ENGLISH);
    log( <span class="literal">"Idiomas en común: "</span> + commonLangsFor(ariane, noriaki) );
  }
  
  <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Lang&gt; commonLangsFor(Set&lt;Lang&gt; aThisSet, Set&lt;Lang&gt; aThatSet){
    Set&lt;Lang&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();
    <span class="keyword">for</span>(Lang lang: aThisSet){
      <span class="keyword">if</span>( aThatSet.contains(lang) ) {
        result.add(lang);
      }
    }
    <span class="keyword">return</span> result;
  }
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> log(Object aMessage){
    System.out.println(String.valueOf(aMessage));
  }
}  
    </pre>
    <p></p>
    <p>
      <a id="Legacy"></a><b>Creando enumeraciones de tipo seguro en versiones más antiguas de Java</b>
    </p>
    <p>
      (Esta discusión sigue de cerca las técnicas descritas en la primera edición de
      <i><a href="http://www.amazon.com/exec/obidos/ASIN/0134685997/ref=nosim/javapractices-20">Java Efectivo</a></i>.)
    </p>
    <p>
      Anteriormente al KDJ 1.5, las enumeraciones de tipo seguro pueden ser implementadas como una clase regular de Java. Vienen en 
      varios estilos, correspondientes a las capacidades que incluyen:
    </p> 
    <ul>
      <li>una <code>List</code> de <code>VALUES</code>, para iterar sobre todos los valores de la enumeración</li>
      <li>implementan un método <code>valueOf</code> paara analizar el texto dentro de un elemento de la enumeración</li>
      <li>implementan  <code>Comparable</code></li>
      <li>implementan  <code>Serializable</code></li>
    </ul>
    Exportar una <code>List</code> de <code>VALUES</code> es altamente recomendado. Da a los usuarios un <code>Iterator</code> para 
    recorre todos los valores posibles. La alternativa (codificación fija de valores particulares de la enumeración) se romperá 
    cuando esos valores cambien o sean extendidos para incluir nuevos valores.
    <p>
      La comparación de dos objetos que pertenecen a una enumeración es la misma en todos los estilos:
    </p>
    <ul>
      <li>el método <code>Object.equals</code> nunca se sobreescribe</li>
      <li>se puede usar tanto <code>equals</code> como <code>==</code> para realizar comparaciones, ya que equivalen a lo mismo</li>
    </ul>
    <b>Ejemplo 1</b>
    <p>
      <code>VerySimpleSuit</code> es una enumeración de tipos seguros mínima. Es casi tan simple como definir un conjunto de 
      <code>String</code>s o <code>int</code>s relacionados, aparte del constructor vacío y privado. <br />
    </p>
    <pre>
<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> VerySimpleSuit {

  <span class="comment">/**
  * Los elementos de la enumeración se construyen una vez tras la carga de la clase 
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> VerySimpleSuit CLUBS = <span
            class="keyword">new</span> VerySimpleSuit();
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> VerySimpleSuit DIAMONDS = <span
            class="keyword">new</span> VerySimpleSuit();
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> VerySimpleSuit HEARTS = <span
            class="keyword">new</span> VerySimpleSuit();
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> VerySimpleSuit SPADES = <span
            class="keyword">new</span> VerySimpleSuit();

  <span class="comment">/**
  * El constructor privado previene la construcción fuera de esta clase.
  */</span>
  <span class="keyword">private</span> VerySimpleSuit() {
    <span class="comment">//vacío
</span>  }
}
 
    </pre>
    <br />
    <b>Ejemplo 2</b>
    <p></p>
    <p>
      <code>SimpleSuit</code> es otro estilo simple de implementar una enumeración de tipos seguros, que incluye una implementación 
      de <code>toString</code>: <br />
    </p>
    <pre>
<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> SimpleSuit {

  <span class="comment">/**
  * Los elementos de la enumeración se construyen una vez tras la carga de la clase 
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> SimpleSuit CLUBS = <span
            class="keyword">new</span> SimpleSuit (<span class="literal">"Clubs"</span>);
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> SimpleSuit DIAMONDS = <span
            class="keyword">new</span> SimpleSuit (<span class="literal">"Diamonds"</span>);
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> SimpleSuit HEARTS = <span
            class="keyword">new</span> SimpleSuit (<span class="literal">"Hearts"</span>);
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> SimpleSuit SPADES = <span
            class="keyword">new</span> SimpleSuit (<span class="literal">"Spades"</span>);

  <span class="keyword">public</span> String toString() {
    <span class="keyword">return</span> fName;
  }

  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> <span class="keyword">final</span> String fName;

  <span class="comment">/**
  * El constructor privado previene la construcción fuera de esta clase.
  */</span>
  <span class="keyword">private</span> SimpleSuit(String aName) {
    fName = aName;
  }
}
 
    </pre>
    <br />
    <b>Ejemplo 3</b>
    <p></p>
    <p>
      <code>Suit</code> agrega estas características:
    </p>
    <ul>
      <li>un método <code>valueOf</code> para analizar texto dentro de un elemento de la enumeración</li>
      <li>exporta una <code>List</code> de <code>VALUES</code></li>
      <li>implementa <code>Comparable</code></li>
    </ul>
    <br />
    <pre>
<span class="keyword">import</span> java.util.*;

<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> Suit <span class="keyword">implements</span> Comparable {

  <span class="comment">/**
  * Los elementos de la enumeración se construyen una vez tras la carga de la clase 
  * El orden de aparición aquí determina el orden de compareTo.
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> Suit CLUBS = <span
            class="keyword">new</span> Suit (<span class="literal">"Clubs"</span>);
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> Suit DIAMONDS = <span
            class="keyword">new</span> Suit (<span class="literal">"Diamonds"</span>);
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> Suit HEARTS = <span
            class="keyword">new</span> Suit (<span class="literal">"Hearts"</span>);
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> Suit SPADES = <span
            class="keyword">new</span> Suit (<span class="literal">"Spades"</span>);

  <span class="keyword">public</span> String toString() {
    <span class="keyword">return</span> fName;
  }

  <span class="comment">/**
  * Analiza el texto dentro de un elemento de esta enumeración.
  *
  * @param aText toma unos de los valores 'Clubs',
  * 'Diamonds', 'Hearts', 'Spades'.
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> Suit valueOf(String aText){
    Iterator iter = VALUES.iterator();
    <span class="keyword">while</span> (iter.hasNext()) {
      Suit suit = (Suit)iter.next();
      <span class="keyword">if</span> ( aText.equals(suit.toString()) ){
        <span class="keyword">return</span> suit;
      }
    }
    <span class="comment">//este método es inusual en que IllegalArgumentException es
</span>    <span class="comment">//posiblemente lanzado no al principio, sino al final.
</span>    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(
      <span class="literal">"No se puede analizar en un elemento de Suit: '"</span> + aText + <span
            class="literal">"'"</span>
    );
  }

  <span class="keyword">public</span> <span class="keyword">int</span> compareTo(Object that) {
    <span class="keyword">return</span> fOrdinal - ( (Suit)that ).fOrdinal;
  }

  <span class="keyword">private</span> <span class="keyword">final</span> String fName;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">int</span> fNextOrdinal = <span
            class="literal">0</span>;
  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">int</span> fOrdinal = fNextOrdinal++;

  <span class="comment">/**
  * El constructor privado previene la construcción fuera de esta clase.
  */</span>
  <span class="keyword">private</span> Suit(String aName) {
    fName = aName;
  }

  <span class="comment">/**
  * Estas dos líneas es todo lo que se necesita para exportar una List de VALUES.
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> Suit[] fValues = {CLUBS, DIAMONDS, HEARTS, SPADES};
  <span class="comment">//Los VALUES deben ubicarse aquí; de lo contrario, una referencia hacia adelante ilegal
</span>  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> List VALUES = Collections.unmodifiableList(Arrays.asList(fValues));
}
 
    </pre>
    <br />
    <b>Ejemplo 4</b>
    <p>
      La enumeración <code>AccountType</code>:
    </p>
    <ul>
      <li>exporta un método <code>valueOf</code> para analizar texto dentro de un elemento de la enumeración</li>
      <li>exporta una <code>List</code> de <code>VALUES</code></li>
      <li>implementa <code>Comparable</code></li>
      <li>implementa <code>Serializable</code></li>
    </ul>
    <br />
    <pre>
<span class="comment">/**
* El único elemento que se serializa es un identificador ordinal. Así, 
* cualquier valor de enumeración agregado en el futuro debe ser construído DESPUÉS de 
* los objetos ya existentes, de otra forma se romperá la serialización.
*/</span>
<span class="keyword">import</span> java.io.*;
<span class="keyword">import</span> java.util.*;

<span class="keyword">public</span> <span class="keyword">class</span> AccountType <span
            class="keyword">implements</span> Serializable, Comparable {

  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> AccountType CASH =  <span
            class="keyword">new</span> AccountType(<span class="literal">"Cash"</span>);
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> AccountType MARGIN = <span
            class="keyword">new</span> AccountType(<span class="literal">"Margin"</span>);
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> AccountType RSP =  <span
            class="keyword">new</span> AccountType(<span class="literal">"RSP"</span>);
  <span class="comment">//LOS VALORES FUTUROS SE DEBEN CONSTRUIR AQUÍ, DESPUÉS DE TODOS LOS DEMÁS
</span>
  <span class="keyword">public</span> String toString() {
    <span class="keyword">return</span> fName;
  }

  <span class="comment">/**
  * Analiza el texto dentro de un elemento de esta enumeración
  *
  * @param toma uno de los valores 'Cash', 'Margin', 'RSP'.
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> AccountType valueOf(String aText){
    Iterator iter = VALUES.iterator();
    <span class="keyword">while</span> (iter.hasNext()){
      AccountType account = (AccountType)iter.next();
      <span class="keyword">if</span> ( aText.equals(account.toString()) ){
        <span class="keyword">return</span> account;
      }
    }
    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(
      <span class="literal">"No se puede analizar en un elemento de enumeración: '"</span> + aText + <span
            class="literal">"'"</span>
    );
  }

  <span class="keyword">public</span> <span class="keyword">int</span> compareTo(Object aObject) {
    <span class="keyword">return</span> fOrdinal - ((AccountType)aObject).fOrdinal;
  }

  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> <span class="keyword">transient</span> <span
            class="keyword">final</span> String fName;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">int</span> fNextOrdinal = <span
            class="literal">1</span>;
  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">int</span> fOrdinal = fNextOrdinal++;

  <span class="keyword">private</span> AccountType (String aName) {
    fName = aName;
  }

  <span class="comment">//exporta VALUES con estos dos elementos
</span>  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> AccountType[] fValues = {CASH, MARGIN, RSP};
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> List VALUES = Collections.unmodifiableList(Arrays.asList(fValues));

  <span class="comment">//Implementa Serializable con estos dos elementos
</span>  <span class="keyword">private</span> Object readResolve() <span
            class="keyword">throws</span> ObjectStreamException {
    <span class="keyword">return</span> fValues[fOrdinal];
  }
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span
            class="literal">64616131365L</span>;
} 
    </pre>
    <br />
    <p></p>
    <div class="topic-section" id="see-also-title">
      Vea También :
    </div>
    <div id="see-also" class="main-body">
      <a href="../practicascomunes/practicascomunes_186.html">Use enumeraciones para restringir los argumentos</a><br /> 
      <a href="../tareascomunes/tareascomunes_225.html">Modernizar código viejo</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>