<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Factoría Abstracta</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Búsqueda" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">Factoría Abstracta</div>
    <br />
    Usar referencias a interfaces en vez de referencias a clases concretas es una forma importante de 
    <a href="../practicascomunes/practicascomunes_123.html">minimizar los efectos dominantes</a>. El usuario de una referencia de 
    interfaz está siempre protegido de los cambios de la implementación subyacente.
    <p>
      El patrón Factoría Abstracta es un ejemplo de esta técnica. Los usuario de una Factoría Abstracta pueden crear familias de 
      objetos relacionados sin ningún conocimiento de sus clases concretas.
      (<em>
        Una aplicación de negocios típica habitualmente no necesitaría usar esta técnica, al memos con se aplica a los Objetos de 
        Acceso a Datos.
      </em>)

    </p>
    <p>
      <b>Ejemplo</b>
    </p>
    <p>
      Una Factoría Abstracta es una parte mayor del esquema <em>completo</em> de un 
      <a href="../bbdd/bbdd_66.html">Objeto de Acceso a Datos</a> (DAO). Aquí, la idea es permitir a la capa de negocio interactuar 
      con la capa de datos casi enteramente a través de referencias de interfaz. La capa de negocio permanece ignorante de las 
      clases concretas que implementan el almacenamiento.
    </p>
    <p>
      Hay dos familias distintas de elementos aquí:
    </p>
    <ul>
      <li>las diversas implementaciones del almacén de datos (en este caso, archivos de texto o una base de datos relacional)</li>
      <li>los diversos objetos comerciales que necesitan persistencia (en este caso, <code>User</code> y <code>Device</code>)</li>
    </ul>
    Tomemos el ejemplo de almacenar objetos <code>Device</code>. Pueden ser almacenados en un archivo de texto o en una base de 
    datos relacional. Ya que el código llamante necesita permanecer ignorante de cual se usa, es natural, por supuesto, definir una 
    interfaz que refleje esto, junto con las dos implementaciones concretas correspondientes:
    <br />
    <pre>
<span class="keyword">package</span> myapp;

<span class="keyword">public</span> <span class="keyword">interface</span> DeviceDAO {

  Device fetch(String aId) <span class="keyword">throws</span> DataAccessException;
  
  <span class="keyword">void</span> add(Device aDevice) <span
			class="keyword">throws</span> DataAccessException;
  
  <span class="keyword">void</span> change(Device aDevice) <span
			class="keyword">throws</span> DataAccessException;
  
  <span class="keyword">void</span> delete(Device aDevice) <span
			class="keyword">throws</span> DataAccessException;
} 
    </pre>
    ...con una implementación para un sistema de ficheros:
    <br />
    <pre>
<span class="keyword">package</span> myapp;

<span class="keyword">final</span> <span class="keyword">class</span> DeviceDAOFileSys <span
			class="keyword">implements</span> DeviceDAO {
  
  <span class="comment">/*
   * Al constructor se le pasará habitualmente cualquier dato de configuración requerido.
   */</span>
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> add(Device aDevice) <span class="keyword">throws</span> DataAccessException {
    <span class="comment">//omitido...
</span>  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> change(Device aDevice) <span
			class="keyword">throws</span> DataAccessException {
    <span class="comment">//omitido...
</span>  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> delete(Device aDevice) <span
			class="keyword">throws</span> DataAccessException {
    <span class="comment">//omitido...
</span>  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> Device fetch(String aId) <span
			class="keyword">throws</span> DataAccessException {
    <span class="comment">//omitido...
</span>    <span class="keyword">return</span> <span class="keyword">null</span>;
  }

} 
    </pre>
    ...y una implementación para una base de datos relacional:
    <br />
    <pre>
<span class="keyword">package</span> myapp;

<span class="keyword">final</span> <span class="keyword">class</span> DeviceDAORelational <span
			class="keyword">implements</span> DeviceDAO {
  
  <span class="comment">/*
   * Al constructor se le pasará habitualmente cualquier dato de configuración requerido.
   */</span>
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> add(Device aDevice) <span class="keyword">throws</span> DataAccessException {
    <span class="comment">//omitido...
</span>  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> change(Device aDevice) <span
			class="keyword">throws</span> DataAccessException {
    <span class="comment">//omitido...
</span>  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> delete(Device aDevice) <span
			class="keyword">throws</span> DataAccessException {
    <span class="comment">//omitido...
</span>  }
  
  <span class="keyword">@Override</span> <span class="keyword">public</span> Device fetch(String aId) <span
			class="keyword">throws</span> DataAccessException {
    <span class="comment">//omitido...
</span>    <span class="keyword">return</span> <span class="keyword">null</span>;
  }
  
} 
    </pre>
    (Los detalles de estas clases se omiten, para que pueda ver mejor la estructura).
    <p>
      A continuación, la aplicación llamante necesita una forma de interactuar con la base de datos, sin saber sobre las 
      implementaciones concretas. Esto se hace usando una clase factoría: <br />
    </p>
    <pre>
<span class="keyword">package</span> myapp;

<span class="comment">/**
 Devuelve todas las instancias DAO.
  
 Lee un elemento de configuración (definido por su programa) para decidir
 qué familia de objetos DAO debería devolver, para el programa que se está ejecutando
 actualmente, o basado en ficheros o basado en base de datos.
  
 El mecanismo de configuración puede ser una propiedad del Sistema, un archivo de propiedades, un 
 archivo XML, etc. La configuración es a menudo leída cuando se inicializa el sistema, 
 quizás unsando un inicializador estático.
*/</span>
<span class="keyword">final</span> <span class="keyword">class</span> DAOFactory {
  
  <span class="comment">/* algunos implementarían todos los métodos aquí como métodos estáticos */</span>
  
  DeviceDAO getDeviceDAO(){
    <span class="comment">//omitido:
</span>    <span class="keyword">return</span> <span class="keyword">null</span>;
  }

  UserDAO getUserDAO(){
    <span class="comment">//omitido:
</span>    <span class="keyword">return</span> <span class="keyword">null</span>;
  }
  
} 
    </pre>
    <br />
    <pre>
<span class="keyword">package</span> myapp;

<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> Application {
  
  <span class="comment">/**
   Este código de llamada desconoce por completo el almacén de datos subyacente. 
   Podría ser un archivo de texto o una base de datos relacional.
  */</span>
  <span class="keyword">void</span> addNewDevice(Device aDevice){
    DAOFactory factory = <span class="keyword">new</span> DAOFactory();
    <span class="keyword">try</span> {
      factory.getDeviceDAO().add(aDevice);
    }
    <span class="keyword">catch</span> (DataAccessException ex) {
      ex.printStackTrace();
    }
  }

}
 
    </pre>
    Para acumular aún más interfaces, una variación de lo anterior es hacer una abstracción o la propia factoría: la factoria se 
    define como una interfaz, con métodos similares a los anteriores. Luego, se definen dos implementaciones concretas de la 
    interfaz de factoría, una para cada tipo de almacén de datos.
    <br />
    <pre>
<span class="keyword">package</span> myapp;

<span class="keyword">public</span> <span class="keyword">interface</span> Factory {
  
  DeviceDAO getDeviceDAO();
  
  UserDAO getUserDAO();
}
 
    </pre>
    <br />
    <pre>
<span class="keyword">package</span> myapp;

<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> FactoryBuilder {
  
  <span class="comment">/** devuelve una implementación específica de Factory */</span>
  Factory getFactory(){
    <span class="comment">//omitido
</span>    <span class="keyword">return</span> <span class="keyword">null</span>;
  }

}
 
    </pre>
    <br />
    <p></p>
    <p></p>
    <div class="topic-section" id="see-also-title">
      Vea También:
    </div>
    <div id="see-also" class="main-body">
      <a href="../patrones/patrones_21.html">Métodos de la Factoría</a><br /> 
      <a href="../bbdd/bbdd_66.html">Objetos de acceso a Datos</a><br /> 
      <a href="../bbdd/bbdd_77.html">Encapsulado de la excepción de Datos</a><br /> 
      <a href="../constructores/constructors_113.html">Construir un Objeto usando el nombre de la clase</a><br /> 
      <a href="../practicascomunes/practicascomunes_123.html">Minimizar los efectos dominantes</a><br /> 
      <a href="../servlets/servlets_138.html">Analizar parámetros en objetos de dominio</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>