<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Factoría de Complemento</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Búsqueda" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">
      Factoría de Complemento
    </div>
    <br />
    Es a menudo útil ser capaz de rápida y facilmente cambiar una implementación de una característica dada con otra. Esto es 
    especialmente útil cuando escribe pruebas unitarias para su código, pero la técnica no está estrictamente limitada a las 
    pruebas unitarias.
    <p>
      Una <em>factoría de complementos</em> es una forma de intercambiar implementaciones rápidamente. La idea general es:
    </p>
    <ul>
      <li>definir una interfaz Java para los métodos cuya implementación quiere ser capaz de intercambiar.</li>
      <li>definir 2 o más implementaciones concretas de esa interfaz.</li>
      <li>
        crear un método correspondiente en una clase de factoría de complemento para devolver una de estas implementaciones, según
        lo definido por algún ajuste de configuración.
      </li>
    </ul>
    <p>
      Usando una configuración de alguna clase (a menudo simplemente un archivo de texto), la factoría de complemento sabe qué 
      implementación concreta se supone que devuelve a su llamador.
    </p>
    <p>
      Es importante para su aplicación tratar la Factoría de Complementos como la <i>única fuente</i> para las implementaciones de 
      las interfaces correspondientes. Esto es, el resto de su aplicación no se supone que tengan conocimiento <i>directo</i> de 
      las implementaciones concretas. La Factoría de Complementos está destinada a mantener ese conocimiento en secreto.
    </p>
    <p>
      Una factoría de complementos puede tener una variedad de métodos definidos, cada uno devolviendo una implementación de una 
      interfaz específica.
    </p>
    <p>
      Un tema recurrente en la programación de objetos es <b>permitir que el código antiguo llame al código nuevo</b>. Una Fábrica 
      de Complementos es simplemente otra variación de ese tema importante.
    </p>
    <p>
      <b>Ejemplo</b>
    </p>
    <p>
      Como un ejemplo, tomemos la idea de un <a href="../practicascomunes/practicascomunes_234.html">reloj del sistema falso</a>. En       este caso, quiere que el tiempo actual sea definido de forma centralizada, en un lugar. También quiere ser capaz de 
      intercambiar de varias formas de definir la hora actual, ya sea para pruebas o por otras razones.
    </p>
    <p>
      Aquí está la interfaz: <br />
    </p>
    <pre>
<span class="keyword">package</span> myapp;

<span class="comment">/**
 Devuelve la hora en milisegundos de la época de Java.
 Cuando se combina con una TimeZone, dicho valor en milisegundos puede ser 
 utilizado para crear un valor de fecha y tiempo.
  
 Variación: uno podría decidir devolver un objeto de fecha-tiempo directamente, 
 en vez de un valor en milisegundos.
*/</span>
<span class="keyword">public</span> <span class="keyword">interface</span> TimeSource {
  
  <span class="keyword">long</span> currentTimeMillis();
  
}
 
    </pre>
    <p></p>
    <p>
      Aquí tiene un ejemplo de una implementación particular concreta de la interfaz precedente:<br />
    </p>
    <pre>
<span class="keyword">package</span> hirondelle.jp.util;

<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> TimeSourceOneDayAdvance <span
            class="keyword">implements</span> TimeSource {
  
  <span class="keyword">public</span> <span class="keyword">long</span> currentTimeMillis() {
    <span class="keyword">return</span> System.currentTimeMillis() + MILLISECS_PER_DAY;
  }
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> <span class="keyword">int</span> MILLISECS_PER_DAY = <span
            class="literal">1000</span>*<span class="literal">60</span>*<span
            class="literal">60</span>*<span class="literal">24</span>;
}
 
    </pre>
    Aquí tiene un llamador que usa una implementación concreta, si saber de la clase subyacente:<br />
    <pre>
<span class="keyword">package</span> myapp;

<span class="comment">/**
Usa una implementación concreta de una interfaz, sin estar directamente enlazada a 
la clase de implementación.

La implementación concreta es conocida sólo por la clase PluginFactory.
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> UseFakeSystemClock {
  
  <span class="keyword">public</span> <span class="keyword">void</span> doSomethingThatDependsOnTime(){
    TimeSource timesource = PluginFactory.getTimeSource();
    <span class="keyword">long</span> currentTime = timesource.currentTimeMillis();
    System.out.println(<span class="literal">"Valor actual en milisegundos: "</span> + currentTime);
  }

}
 
    </pre>
    Finalmente, aquí hay un boceto de la factoría de complementos en sí. Tenga en cuenta que puede agregar más métodos a esta clase,
    cada uno correspondiente a una interfaz diferente.<br />
    <pre>
<span class="keyword">package</span> myapp;

<span class="keyword">import</span> java.util.LinkedHashMap;
<span class="keyword">import</span> java.util.Map;

<span class="comment">/** Devuelve implementaciones concretas para interfaces específicas y conocidas. */</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> PluginFactory {
  
  <span class="comment">/**
   Lee en los datos de configuración que asocian los nombres de las interfaces a los nombres de 
   las clases de implementación concretas correspondientes. Se llama desde el inicio, 
   antes de que el resto del programa necesite implementaciones.
   
   &lt;P&gt;Ejemplo de una posible entrada en dicho archivo de configuración :
   myapp.TimeSource = myapp.TimeSourceOneDayAdvance
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> init(){
    <span class="comment">//omitido
</span>    <span class="comment">//quizás un se lee un archivo de propiedades, quizás se usa alguna otra fuente 
</span>  }
  
  <span class="comment">/*
  * Otra variación: permitir al llamador intercambiar entre diferentes clases de implementación
  * en tiempo de ejecución, después de llamar a init. Esto permite al código de prueba intercambiar entre varias 
  * implementaciones.
  */</span>
  
  <span class="comment">/**
   Devuelve la implementación concreta de la interfaz TimeSource.
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> TimeSource getTimeSource() {
    String implClassName = fImplementations.get(<span class="literal">"myapp.TimeSource"</span>);
    TimeSource result = (TimeSource)buildObject(implClassName);
    <span class="keyword">return</span> result;
  }
  
  <span class="comment">// PRIVADO
</span>  
  <span class="comment">/**
   Asocia el nombre de una interfaz al nombre de una clase de implementación
   concreta correspondiente.
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> Map&lt;String, String&gt; fImplementations = <span
            class="keyword">new</span> LinkedHashMap&lt;&gt;();
  
  <span class="keyword">private</span> <span class="keyword">static</span> Object buildObject(String aClassName){
    Object result = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
      <span class="comment">//tenga en cuenta que, con este estilo, ¡la implementación debe tener un 
</span>      <span class="comment">//constructor sin argumentos!
</span>      Class implClass = Class.forName(aClassName);
      result = implClass.newInstance();
    }
    <span class="keyword">catch</span> (ClassNotFoundException ex) {
      <span class="comment">//omitido
</span>    }
    <span class="keyword">catch</span> (InstantiationException ex) {
      <span class="comment">//omitido
</span>    }
    <span class="keyword">catch</span> (IllegalAccessException ex) {
      <span class="comment">//omitido
</span>    }
    <span class="keyword">return</span> result;
  }
}
 
    </pre>
    <br />
    <p></p>
    <p></p>
    <div class="topic-section" id="see-also-title">
      Vea También :
    </div>
    <div id="see-also" class="main-body">
      <a href="../constructores/constructors_113.html">Construir un Objeto usando el nombre de la clase</a><br /> 
      <a href="../practicascomunes/practicascomunes_234.html">Usar un reloj de sistema falso</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>