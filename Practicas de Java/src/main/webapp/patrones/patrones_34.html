<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Inicialización perezosa</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Búsqueda" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">
      Inicialización perezosa
    </div>
    <br />
    La inicialización perezosa es una optimización de rendimiento. Se usa cuando los datos se consideran "costosos" por algún 
    motivo. Por ejemplo:
    <ul>
      <li>
        si el valor <code>hashCode</code> para un objeto podría no ser en realida necesitado por su llamador, calcula siempre el 
        <code>hashCode</code> para todas las instancias del objeto puede parecer innecesario.
      </li>
      <li>
        ya que acceder a un sistema de ficheros o red es relativamente lento, dichas operaciones deben posponerse hasta que sean 
        absolutamente necesarias.
      </li>
    </ul>
    La inicialización perezosa tiene dos objetivos:
    <ul>
      <li><i>demorar</i> una operación expensiva hasta que sea absolutamnete necesaria</li>
      <li><i>almacenar</i> el resultado de esa operación expensiva, de forma que no necesitará repetirlo de nuevo</li>
    </ul>
    <p>
      Como es habitual, el tamaño de cualquier aumento de rendimiento, si lo hay, depende en gran medida del problema y, en muchos 
      casos, puede no ser significativo. Al igual que con cualquier optimización, esta técnica debe usarse solo si existe un 
      beneficio claro y significativo.
    </p>
    <p>
      Para evitar una <code>NullPointerException</code>, una clase debe 
      <a href="../practicascomunes/practicascomunes_92.html">autoencapsular</a> los campos que tienen inicialización perezosa. Es 
      decir, una clase no puede referirse <em>directamente</em> a dichos campos, pero debe accederlos a través de un método.
    </p>
    <p>
      El método <a href="../objetos/objects_28.html">hashCode</a> de un Objeto de Modelo 
      <a href="patrones_29.html">immutable</a> es un candidato común para la inicialización perezosa.
    </p>
    <p>
      <b>Ejemplo 1</b>
    </p>
    <p>
      En este ejemplo, hay dos campos con inicialización perezosa - <code>fHashCode</code> y <code>fAwards</code>.<br />
    </p>
    <pre>
<span class="keyword">import</span> java.util.*;

<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> Athlete {

  <span class="keyword">public</span> Athlete(<span class="keyword">int</span> aId){
    <span class="comment">//una implementación de juguete:
</span>    fId = aId;
    fName = <span class="literal">"Roger Bannister"</span>;
    <span class="comment">//fAwards no se establece aquí!
</span>  }

  <span class="comment">//..omitido
</span>
  <span class="comment">/**
   La inicialización perezosa se usa aquí; esto asume que los premios
   puede no ser siempre del interés del llamador, 
   y que, por alguna razón, resulta especialmente caro 
   conseguir la Lista de Awards.
  */</span>
  <span class="keyword">public</span> List&lt;String&gt; getAwards(){
    <span class="keyword">if</span> (fAwards == <span class="keyword">null</span>) {
      <span class="comment">//el campo fAwards aun no ha sido rellenado
</span>      <span class="comment">//Aquí una implementación de juguete
</span>      List&lt;String&gt; awards = <span class="keyword">new</span> ArrayList&lt;&gt;();
      awards.add(<span class="literal">"Medalla de Oro de 2006"</span>);
      awards.add(<span class="literal">"Medalla de Bronce 1998"</span>);
      fAwards = awards;
    }
    <span class="keyword">return</span> fAwards;
  }

  <span class="comment">/**
   Este estilo se aplica solo si el objeto es inmutable.
   
   Otra alternativa es calcular el hashCode una vez, cuando el 
   objeto es inicialmente construído (de nuevo, aplicada solo cuando el objeto es 
   inmutable).
  */</span>
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">int</span> hashCode(){
    <span class="keyword">if</span> (fHashCode == <span class="literal">0</span>) {
     fHashCode = HashCodeUtil.SEED;
     fHashCode = HashCodeUtil.hash(fHashCode, fId);
     fHashCode = HashCodeUtil.hash(fHashCode, fName);
     <span class="comment">//autoencapsulado: fAwards no se referencia directamente, 
</span>     <span class="comment">//ya que puede ser nulo:
</span>     fHashCode = HashCodeUtil.hash(fHashCode, getAwards());
    }
    <span class="keyword">return</span> fHashCode;
  }

  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> <span class="keyword">int</span> fId;
  <span class="keyword">private</span> String fName;
  <span class="keyword">private</span> List&lt;String&gt; fAwards;
  <span class="keyword">private</span> <span class="keyword">int</span> fHashCode;
} 
    </pre>
    <p></p>
    <p>
      <b>Ejemplo 2</b>
    </p>
    <p>
      Aquí, la búsqueda de las impresoras disponibles para un PC de escritorio se trata como una operación expensiva.<br />
    </p>
    <pre>
<span class="keyword">import</span> java.util.Arrays;
<span class="keyword">import</span> java.util.List;

<span class="keyword">import</span> javax.print.DocFlavor;
<span class="keyword">import</span> javax.print.PrintService;
<span class="keyword">import</span> javax.print.PrintServiceLookup;
<span class="keyword">import</span> javax.print.attribute.HashPrintRequestAttributeSet;
<span class="keyword">import</span> javax.print.attribute.PrintRequestAttributeSet;
<span class="keyword">import</span> javax.print.attribute.standard.OrientationRequested;
<span class="keyword">import</span> javax.print.attribute.standard.Sides;

<span class="comment">/** Los servicios de impresión disponibles a un cliente de escritorio. */</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> Printers {

  <span class="comment">/** Imprime algún texto plano (quizás internamente convertido a PDF). */</span>
  <span class="keyword">void</span> printSomething(String aText, PrintService aPrinter) {
    <span class="comment">//...omitido
</span>  }

  <span class="comment">/** Devuelve la lista de impresoras que puede imprimir PDFs (a doble cara, retrato).*/</span>
  List&lt;PrintService&gt; listAvailablePrinters(){
    <span class="keyword">if</span>(fAvailablePrinters == <span
			class="keyword">null</span>){
      <span class="comment">//a doble cara, retrato, para los archivos PDF.
</span>      PrintRequestAttributeSet attrs = <span class="keyword">new</span> HashPrintRequestAttributeSet();
      attrs.add(Sides.DUPLEX);
      attrs.add(OrientationRequested.PORTRAIT);
      <span class="comment">//¡Operación costosa! Esto puede tomar varios segundo en algunos entornos:
</span>      fAvailablePrinters = Arrays.asList(
        PrintServiceLookup.lookupPrintServices(DocFlavor.INPUT_STREAM.PDF, attrs)
      );
    }
    <span class="keyword">return</span> fAvailablePrinters;
  }
  
  <span class="comment">// PRIVADO
</span>  
  <span class="comment">/**
   Se busca una vez, la primera vez que se necesita y luego se almacena con una
   referencia estática. Si era una referencia no estática, entonces
   la lista de impresoras disponibles no se buscaría una sola vez,
   pero tal vez muchas veces (una vez por cada objeto "Printers", y no una vez por
   la clase cargada 'Printers').
   
   Autoencapsulado :
   Si esta implementación de la clase necesita referenciar este elemento, debe hacerlo 
   indirectamente, llamando a listAvailablePrinters().  
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;PrintService&gt; fAvailablePrinters;
  
}  
    </pre>
    <br />
    <b>Ejemplo 3</b>
    <p></p>
    <p>
      La inicialización perezosa es particularmente útil para los IGUs que toman mucho tiempo en construirse.
    </p>
    <p>
      Hay varias políticas para la construcción de IGU que puede seguir un diseño:
    </p>
    <ul>
      <li>siempre construir: construir la ventana muchas veces, cuando sea necesario, y no almacena en caché el resultado.</li>
      <li>
        compilación de primera solicitud: construye la ventana una vez, cuando se solicita por primera vez. Almacena el resultado 
        en caché para cualquier solicitud adicional, en caso de que ocurra.
      </li>
      <li>
        compilación en segundo plano: construye la ventana una vez, en un hilo de trabajo de baja prioridad, cuando se inicializa 
        el sistema. Almacene en caché el resultado de cualquier solicitud, en caso de que ocurra.
      </li>
    </ul>
    Aquí tiene un ejemplo del estilo de la primera petición, en el cual el campo <code>fEditor</code> tiene inicialización perezosa 
    (vea el método <code>actionPerformed</code>).<br />
    <pre>
<span class="keyword">package</span> hirondelle.stocks.preferences;

<span class="keyword">import</span> java.awt.event.*;
<span class="keyword">import</span> javax.swing.*;
<span class="keyword">import</span> java.util.*;
<span class="keyword">import</span> java.util.logging.*;

<span class="keyword">import</span> hirondelle.stocks.util.Args;
<span class="keyword">import</span> hirondelle.stocks.util.ui.StandardEditor;
<span class="keyword">import</span> hirondelle.stocks.util.ui.UiUtil;
<span class="keyword">import</span> hirondelle.stocks.preferences.PreferencesEditor;
<span class="keyword">import</span> hirondelle.stocks.util.Util;

<span class="comment">/**
* Presenta el diálogo para permitir la actualización de preferencias de usuario.
*
* &lt;P&gt;Las preferencias relacionadas se agrupan juntas y colocadas en 
* un panel único de un &lt;tt&gt;JTabbedPane&lt;/tt&gt;, que corresponda a una 
* implementación de {@link PreferencesEditor}. Los valores son pre-rellenados con 
* los valores actuales de las preferencias. Si es así, se proporciona un botón 
* &lt;tt&gt;Restaurar los valores predeterminados&lt;/tt&gt; para ese conjunto 
* de preferencias relacionadas.
*
*&lt;P&gt;Las preferencias no se cambian hasta que se presione el botón &lt;tt&gt;OK&lt;/tt&gt;. 
* Excepción: las preferencias de rastreo toma efecto inmediatamente, sin la necesidad de 
* pulsar &lt;tt&gt;OK&lt;/tt&gt;.
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
			class="keyword">class</span> EditUserPreferencesAction <span
			class="keyword">extends</span> AbstractAction {

  <span class="comment">/**
  * Constructor.
  *  
  * @param aFrame ventana padre a la cual este diálogo se adjunta.
  * @param aPrefEditors contiene las implementaciones de {@link PreferencesEditor}, 
  * cada una de las cuales se coloca en un panel de un &lt;tt&gt;JTabbedPane&lt;/tt&gt;.
  */</span>
  <span class="keyword">public</span> EditUserPreferencesAction (JFrame aFrame, List&lt;PreferencesEditor&gt; aPrefEditors) {
    <span class="keyword">super</span>(<span class="literal">"Preferencias..."</span>, UiUtil.getEmptyIcon()); 
    Args.checkForNull(aFrame);
    Args.checkForNull(aPrefEditors);
    fFrame = aFrame;
    putValue(SHORT_DESCRIPTION, <span class="literal">"Actualizar las preferencias del usuario"</span>);
    putValue(LONG_DESCRIPTION, <span class="literal">"Permite al usuario ingresar sus preferencias."</span>);
    putValue(MNEMONIC_KEY, <span class="keyword">new</span> Integer(KeyEvent.VK_P));    
    fPrefEditors = aPrefEditors;
  }

  <span class="comment">/** Visualiza las preferencias de usuario del diálogo.  */</span>
  <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> actionPerformed(ActionEvent event) {
    fLogger.info(<span class="literal">"Mostrar el cuadro de diálogo de preferencias del usuario."</span>);
    <span class="comment">//construcción perezosa: fEditor se crea una sola vez, cuando esta acción
</span>    <span class="comment">//se invoca explícitamente
</span>    <span class="keyword">if</span> (fEditor == <span class="keyword">null</span>) {
      fEditor = <span class="keyword">new</span> Editor(<span
			class="literal">"Editar preferencias"</span>, fFrame);
    }
    fEditor.showDialog();
  }
  
  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> JFrame fFrame;
  <span class="keyword">private</span> java.util.List&lt;PreferencesEditor&gt; fPrefEditors;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
			class="keyword">final</span> Logger fLogger = Util.getLogger(EditUserPreferencesAction.<span
			class="keyword">class</span>);  
  
  <span class="comment">/**
  * Especificar esto como un campo siempre para la creación "perezosa" y uso del IGU, el cual es 
  * de particular importancia para un diálogo de preferencias, ya que suelen ser de peso pesado, 
  * y tienen un gran número de componentes.
  */</span>
  <span class="keyword">private</span> Editor fEditor;
  
  <span class="comment">/**
  * Devuelve un IGU para editar todas las preferencias, pre-rellenado con los valores 
  * actuales.
  */</span>
  <span class="keyword">private</span> JComponent getPrefEditors(){
    JTabbedPane content = <span class="keyword">new</span> JTabbedPane();
    content.setTabPlacement(JTabbedPane.LEFT);
    <span class="keyword">int</span> idx = <span class="literal">0</span>;
    <span class="keyword">for</span>(PreferencesEditor prefEditor: fPrefEditors) {
      JComponent editorGui = prefEditor.getUI();
      editorGui.setBorder(UiUtil.getStandardBorder());
      content.addTab(prefEditor.getTitle() , editorGui);
      content.setMnemonicAt(idx, prefEditor.getMnemonic());
      ++idx;
    }
    <span class="keyword">return</span> content;
  }
  
  <span class="comment">/** Se llama solo cuando el usuario presiona el botón Aceptar.  */</span>
  <span class="keyword">private</span> <span class="keyword">void</span> saveSettings(){
    fLogger.fine(<span class="literal">"El usuario seleccionó Aceptar. Actualizar las preferencias de la tabla."</span>);
    <span class="keyword">for</span>(PreferencesEditor prefEditor: fPrefEditors) {
      prefEditor.savePreferences();
    }
  }
  
  <span class="comment">/**
  * Un ejemplo de una clase anidada que está anidada porque está adjuntada solo 
  * a la clase que la contiene, y no puede actuar como una superclase ya que la herencia 
  * múltiple de una implementación no es posible. 
  * 
  * La implementación de esta clase anidada se mantiene corta llamando a métodos
  * de la clase envolvente.
  */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span
			class="keyword">class</span> Editor <span class="keyword">extends</span> StandardEditor { 
    Editor(String aTitle, JFrame aParent){
      <span class="keyword">super</span>(aTitle, aParent, StandardEditor.CloseAction.HIDE);
    }
    <span class="keyword">@Override</span> <span class="keyword">public</span> JComponent getEditorUI () {
      JPanel content = <span class="keyword">new</span> JPanel();
      content.setLayout(<span class="keyword">new</span> BoxLayout(content, BoxLayout.Y_AXIS));
      content.add(getPrefEditors());
      <span class="comment">//content.setMinimumSize(new Dimension(300,300));
</span>      <span class="keyword">return</span> content;
    }
    <span class="keyword">@Override</span> <span class="keyword">public</span> <span
			class="keyword">void</span> okAction() {
      saveSettings();
      dispose();
    }
  }  
}
 
    </pre>
    <br />
    <p></p>
    <div class="topic-section" id="see-also-title">
      Vea También :
    </div>
    <div id="see-also" class="main-body">
      <a href="../constructores/constructors_11.html">Constructores en general</a><br /> 
      <a href="../objetos/objects_28.html">Implementar hashCode</a><br /> 
      <a href="../practicascomunes/practicascomunes_92.html">Campos autoencapsulados</a><br /> 
      <a href="../swing/swing_150.html">Diálogos Estandarizados</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>