<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Velocidad de tiempo de ejecución</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Búsqueda" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">Velocidad de tiempo de ejecución</div>
    <br />
    Aquí tiene un ejemplo de una clase de utilidad <code>Stopwatch</code> que puede proporcionar tiempos para cualquier sección de 
    código.
    <p>
      Es importante tener en cuenta que 
      <code>
        System.<a
          href="https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#currentTimeMillis%28%29">currentTimeMillis</a>
      </code> tiene baja resolución, en el orden de los 10 ms en la mayoría de los sistemas. Para medir la velocidad de ejecución 
      del código, es habitualmente mejor usar 
      <code>
        System.<a
          href="https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#nanoTime%28%29">nanoTime</a>
      </code> en su lugar. De acuerdo a este excelente 
      <a href="https://blogs.oracle.com/dholmes/entry/inside_the_hotspot_vm_clocks">artículo</a> de David Holmes, la resolución 
      típica de <code>nanoTime</code> está en el orden de los microsegundos.
    </p>
    <p>
      Dado que se producirán variaciones de forma natural entre las invocaciones, debe tomar el valor medio de varias medidas 
      diferentes.
    </p>
    <p>
      Herramientas de creación de perfiles como 
      <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/visualvm/">Visual VM</a> son otra opción también. Los 
      perfiladores a menudo se incluyen en los IDE.
    </p>
    <p>
      Tenga en cuenta que el micro-benchmarking preciso en Java es un
      <a href="http://stackoverflow.com/questions/504103/how-do-i-write-a-correct-micro-benchmark-in-java">negocio complicado</a>, 
      principalmente debido a la compilación justo a tiempo (el compilador HotSpot):
    </p>
    <ul>
      <li>la presencia o ausencia de código compilado influirá en gran medida en los tiempos.</li>
      <li>Si necesita cronometrar solo la versión compilada, deberá asegurarse de que el código se haya preparado correctamente.</li>
      <li>para otro punto de datos, simplemente puede apagar el compilador HotSpot por completo, usando
        <code>
          <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/windows/java.html#nonstandard"
             title="Non-standard options for java.">java -Xint</a></code>. Vea el tema 
        <a href="../tareascomunes/tareascomunes_3.html">Copiar una Matriz</a> para una ilustración.
      </li>
    </ul>
    <p>
      Aquí tiene un ejemplo de ejecución de la clase <code>Stopwatch</code>:
    </p>
    <pre>
The reading for StringBuilder is: 3.611 ms
The reading is high: 193.484 ms</pre>
    <br />
    <pre>
<span class="keyword">import</span> java.math.BigDecimal;

<span class="comment">/** 
 Calcula el tiempo de ejecución de cualquier bloque de código.
 
 &lt;P&gt;Esta implementación mide la duración usando &lt;tt&gt;System.nanoTime&lt;/tt&gt;.
 
 &lt;P&gt;En la mayoría de los sistemas &lt;tt&gt;System.currentTimeMillis&lt;/tt&gt; tiene una resolución de tiempo 
 de aproximadamente 10 ms, lo cuale es bastante pobre para la medición del código, por lo que 
 aquí se evita.
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> Stopwatch {

  <span class="comment">/**
   Un ejemplo del uso de esta clase para 
   medir la ejecución de un código simple de manipulación de String.
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> main(String... arguments) {
    Stopwatch stopwatch = <span class="keyword">new</span> Stopwatch();

    stopwatch.start();

    <span class="comment">//hace cosas
</span>    StringBuilder messageOne = <span class="keyword">new</span> StringBuilder();
    <span class="keyword">int</span> numIterations = <span
            class="literal">5000</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span
            class="literal">0</span>; idx &lt; numIterations; ++idx){
      messageOne.append(<span class="literal">"blah"</span>);
    }

    stopwatch.stop();
    <span class="comment">//Tenga en cuenta que no es necesario llamar a un método para obtener la duración,
</span>    <span class="comment">//ya que toString es automático aquí 
</span>    System.out.println(<span class="literal">"TLa lectura de StringBuilder es: "</span> + stopwatch);

    <span class="comment">//reutiliza el mismo cronómetro para medir una implementación alternativa
</span>    <span class="comment">//Tenga en cuenta que no es necesario llamar a un método de reinicio.
</span>    stopwatch.start();

    <span class="comment">//hace cosas de nuevo
</span>    String messageTwo = <span class="keyword">null</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span
            class="literal">0</span>; idx &lt; numIterations; ++idx){
      messageTwo = messageTwo + <span class="literal">"blah"</span>;
    }

    stopwatch.stop();
    <span class="comment">//realiza una comparación numérica
</span>    <span class="keyword">if</span> ( stopwatch.toValue() &gt; <span
            class="literal">5</span> ) {
      System.out.println(<span class="literal">"La lectura es alta: "</span> + stopwatch);
    }
    <span class="keyword">else</span> {
      System.out.println(<span class="literal">"La lectura es baja: "</span> + stopwatch);
    }
  }

  <span class="comment">/**
   Pone en marcha el cronómetro.
   @throws IllegalStateException si el cronómetro ya está funcionando.
  */</span>
  <span class="keyword">public</span> <span class="keyword">void</span> start(){
    <span class="keyword">if</span> (fIsRunning) {
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span
            class="literal">"Debe detenerse antes de llamar a comenzar de nuevo."</span>);
    }
    <span class="comment">//restablece el inicio y la parada
</span>    fStart = System.nanoTime();
    fStop = <span class="literal">0</span>;
    fIsRunning = <span class="keyword">true</span>;
    fHasBeenUsedOnce = <span class="keyword">true</span>;
  }

  <span class="comment">/**
   Para el cronómetro.
   @throws IllegalStateException si el cronómetro aún no está funcionando.
  */</span>
  <span class="keyword">public</span> <span class="keyword">void</span> stop() {
    <span class="keyword">if</span> (!fIsRunning) {
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span
            class="literal">"No se puede detener si no se está ejecutando actualmente."</span>);
    }
    fStop = System.nanoTime();
    fIsRunning = <span class="keyword">false</span>;
  }

  <span class="comment">/**
   Expresa la "lectura" en el cronómetro.
    
   &lt;P&gt;Ejemplo: &lt;tt&gt;123.456 ms&lt;/tt&gt;. La resolución de las mediciones en la mayoría de sistemas 
   está en el orden de unos pocos microsegundos, así que este estilo de presentación es habitualmente
   apropiado para reflejar la precisión real de la mayoría de los temporizadores. 
  
   &lt;P&gt;Ref: https://blogs.oracle.com/dholmes/entry/inside_the_hotspot_vm_clocks
     
   @throws IllegalStateException si el Stopwatch nunca se ha utilizado,
    o si el cronómetro aún está funcionando.
  */</span>
  <span class="keyword">@Override</span> <span class="keyword">public</span> String toString() {
    validateIsReadable();
    StringBuilder result = <span class="keyword">new</span> StringBuilder();
    BigDecimal value = <span class="keyword">new</span> BigDecimal(toValue());<span
            class="comment">//la escala es cero
</span>    <span class="comment">//microsegundos, con 3 decimales:
</span>    value = value.divide(MILLION, <span class="literal">3</span>, BigDecimal.ROUND_HALF_EVEN);
    result.append(value);
    result.append(<span class="literal">" ms"</span>);
    <span class="keyword">return</span> result.toString();
  }

  <span class="comment">/**
   Expresa la "lectura" del cronómetro como un tipo numérico, en nanosegundos.
  
   @throws IllegalStateException si el Stopwatch nunca se ha utilizado,
    o si el cronómetro aún está funcionando.
  */</span>
  <span class="keyword">public</span> <span class="keyword">long</span> toValue() {
    validateIsReadable();
    <span class="keyword">return</span>  fStop - fStart;
  }
  
  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> <span class="keyword">long</span> fStart;
  <span class="keyword">private</span> <span class="keyword">long</span> fStop;

  <span class="keyword">private</span> <span class="keyword">boolean</span> fIsRunning;
  <span class="keyword">private</span> <span class="keyword">boolean</span> fHasBeenUsedOnce;
  
  <span class="comment">/** Convierte de nanos a microsegundos. */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> BigDecimal MILLION = <span
            class="keyword">new</span> BigDecimal(<span class="literal">"1000000"</span>);
  
  <span class="comment">/**
   Throws IllegalStateException si el reloj no ha sido iniciado nunca, 
   o si el reloj está aún funcionando.
  */</span>
  <span class="keyword">private</span> <span class="keyword">void</span> validateIsReadable() {
    <span class="keyword">if</span> (fIsRunning) {
      String message = <span class="literal">"No se puede leer un cronómetro que aún está funcionando."</span>;
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(message);
    }
    <span class="keyword">if</span> (!fHasBeenUsedOnce) {
      String message = <span class="literal">"No se puede leer un cronómetro que nunca se ha iniciado."</span>;
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(message);
    }
  }
} 
    </pre>
    <br />
    <p></p>
    <div class="topic-section" id="see-also-title">
      Vea También :
    </div>
    <div id="see-also" class="main-body">
      <a href="../tareascomunes/tareascomunes_3.html">Copiar una matriz</a> <br /> 
      <a href="../practicascomunes/practicascomunes_4.html">La concatenación de String no escala</a> <br /> 
      <a href="../tareascomunes/tareascomunes_36.html">Mide el rendimiento de la aplicación</a> <br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>