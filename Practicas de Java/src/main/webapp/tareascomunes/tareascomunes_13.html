<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Representar dinero</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Búsqueda" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">Representar dinero</div>
    <br />
    Representar dinero:
    <ul>
      <li>
        use <code><a href="https://docs.oracle.com/javase/10/docs/api/java/math/BigDecimal.html">BigDecimal</a></code>, 
        <code>int</code>, o <code>long</code> (<code>BigDecimal</code> es el valor predeterminado recomendado)
      </li>
      <li>las formas <code>int</code> y <code>long</code> representan centavos (o el equivalente, por supuesto)</li>
      <li><code>BigDecimal</code> es un poco más incómodo de usar, pero tiene modos de redondeo integrados</li>
      <li>
        <code>double</code> o <code>float</code> 
        <a href="http://www.javapractices.com/topic/TopicAction.do?Id=213">no se recomiendan</a>, ya que siempre llevan pequeñas 
        diferencias de redondeo
      </li>
      <li>
        la clase <code><a href="https://docs.oracle.com/javase/10/docs/api/java/util/Currency.html">Currency</a></code> encapsula 
        identificadores estándar para las monedas del mundo
      </li>
    </ul>
    Número de dígitos:
    <ul>
      <li><code>&lt;=9</code>: use <code>BigDecimal</code>, <code>int</code>, or <code>long</code></li>
      <li><code>&lt;=18</code>: use <code>BigDecimal</code>, o <code>long</code></li>
      <li><code>&gt;18</code>: use <code>BigDecimal</code> (otra razón para usar <code>BigDecimal</code> por defecto)</li>
    </ul>
    Recordatorios para <code>BigDecimal</code>:
    <ul>
      <li>
        el constructor recomendado es <code>BigDecimal(String)</code>,no <code>BigDecimal(double)</code> - vea el 
        <a href="https://docs.oracle.com/javase/10/docs/api/java/math/BigDecimal.html#BigDecimal(double)">javadoc</a>
      </li>
      <li>
        los objetos <code>BigDecimal</code> son inmutables - las operaciones siempre devuelven nuevos objetos, y nunca modifican el 
        estado de los objetos existentes
      </li>
      <li>
        el estilo <a href="https://docs.oracle.com/javase/10/docs/api/java/math/BigDecimal.html#ROUND_HALF_EVEN">ROUND_HALF_EVEN</a> 
        de <a href="http://en.wikipedia.org/wiki/Rounding">redondeo</a> introduce el menor sesgo. También se denomina 
        <em>redondeo de banqueros</em> o <em>redondeo a par</em>.
      </li>
    </ul>
    <b>Ejemplo 1</b>
    <p>
      Ejemplo de uso de <code>BigDecimal</code> para realizar cálculos monetarios:<br />
    </p>
    <pre>
<span class="keyword">import</span> java.math.BigDecimal;
<span class="keyword">import</span> java.util.Currency;
<span class="keyword">import</span> java.util.Objects;

<span class="comment">/**
* Ejemplo de cálculos típicos con valores monetarios, implementados con
* &lt;tt&gt;BigDecimal&lt;/tt&gt;.
*
* &lt;P&gt;Este ejemplo es para una moneda que tiene dos decimales..
*
* Vea
* http://java.sun.com/j2se/1.5.0/docs/api/java/math/BigDecimal.html
*
* Observe en particular cómo la escala &lt;em&gt;predeterminada&lt;/em&gt; del resultado de una
* operación se calcula a partir de las escalas de los dos números de entrada
* &lt;ul&gt;
* &lt;li&gt; a + b : max[ scale(a), scale(b) ]
* &lt;li&gt; a - b : max[ scale(a), scale(b) ]
* &lt;li&gt; a * b : scale(a) + scale(b)
* &lt;li&gt; a / b : scale(a) - scale(b)
* &lt;/ul&gt;
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> MoneyCalculation {

  <span class="comment">/**
  * Esquema de prueba simple.
  *
  * Toma dos argumentos numéricos, que representan valores monetarios, en una forma
  * que se puede pasar con éxito al constructor de  &lt;tt&gt;BigDecimal(String)&lt;/tt&gt;
  * (&lt;tt&gt;25.00, 25.0, 25&lt;/tt&gt;, etc).
  *
  * Tenga en cuenta que se prefiere el constructor &lt;tt&gt;String&lt;/tt&gt; para 
  * &lt;tt&gt;BigDecimal&lt;/tt&gt;.
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> main(String... aArgs){
    BigDecimal amountOne = <span class="keyword">new</span> BigDecimal(aArgs[<span
            class="literal">0</span>]);
    BigDecimal amountTwo = <span class="keyword">new</span> BigDecimal(aArgs[<span
            class="literal">1</span>]);
    MoneyCalculation calc = <span class="keyword">new</span> MoneyCalculation(amountOne, amountTwo);
    calc.doCalculations();
  }

  <span class="keyword">public</span> MoneyCalculation(BigDecimal aAmountOne, BigDecimal aAmountTwo){
    fAmountOne = rounded(aAmountOne);
    fAmountTwo = rounded(aAmountTwo);
  }

  <span class="keyword">public</span> <span class="keyword">void</span> doCalculations() {
    log(<span class="literal">"Cantidad Uno: "</span> + fAmountOne);
    log(<span class="literal">"Cantidad Dos: "</span> + fAmountTwo);
    log(<span class="literal">"Suma : "</span> + getSum());
    log(<span class="literal">"Diferencia : "</span> + getDifference());
    log(<span class="literal">"Promedio : "</span> + getAverage());
    log(<span class="literal">"5.25% de la Cantidad Uno: "</span> + getPercentage());
    log(<span class="literal">"Cambio Porcentual de la Cantidad Uno a Dos: "</span> + getPercentageChange());
  }

  <span class="comment">// PRIVADO
</span>
  <span class="keyword">private</span> BigDecimal fAmountOne;
  <span class="keyword">private</span> BigDecimal fAmountTwo;

  <span class="comment">/**
  * Definido de forma centralizada, para permitir cambios sencillos en el modo de redondeo.
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">int</span> ROUNDING_MODE = BigDecimal.ROUND_HALF_EVEN;

  <span class="comment">/**
  * Número de decimales a retener. También denominado "escala".
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">int</span> DECIMALS = <span class="literal">2</span>;
  <span class="comment">//Un estilo alternativo para este valor:
</span>  <span class="comment">//private static int DECIMAL_PLACES =
</span>  <span class="comment">//  Currency.getInstance("USD").getDefaultFractionDigits()
</span>  <span class="comment">//;
</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">int</span> EXTRA_DECIMALS = <span
            class="literal">4</span>;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> BigDecimal TWO = <span
            class="keyword">new</span> BigDecimal(<span class="literal">"2"</span>);
  <span class="keyword">private</span> <span class="keyword">static</span> BigDecimal HUNDRED = <span
            class="keyword">new</span> BigDecimal(<span class="literal">"100"</span>);
  <span class="keyword">private</span> <span class="keyword">static</span> BigDecimal PERCENTAGE = <span
            class="keyword">new</span> BigDecimal(<span class="literal">"5.25"</span>);

  <span class="keyword">private</span> <span class="keyword">void</span> log(String aText){
    System.out.println(Objects.toString(aText));
  }

  <span class="keyword">private</span> BigDecimal getSum(){
    <span class="keyword">return</span> fAmountOne.add(fAmountTwo);
  }

  <span class="keyword">private</span> BigDecimal getDifference(){
    <span class="keyword">return</span> fAmountTwo.subtract(fAmountOne);
  }

  <span class="keyword">private</span> BigDecimal getAverage(){
    <span class="keyword">return</span> getSum().divide(TWO, ROUNDING_MODE);
  }

  <span class="keyword">private</span> BigDecimal getPercentage(){
    BigDecimal result = fAmountOne.multiply(PERCENTAGE);
    result = result.divide(HUNDRED, ROUNDING_MODE);
    <span class="keyword">return</span> rounded(result);
  }

  <span class="keyword">private</span> BigDecimal getPercentageChange(){
    BigDecimal fractionalChange = getDifference().divide(
      fAmountOne, EXTRA_DECIMALS, ROUNDING_MODE
    );
    <span class="keyword">return</span> rounded(fractionalChange.multiply(HUNDRED));
  }

  <span class="keyword">private</span> BigDecimal rounded(BigDecimal aNumber){
    <span class="keyword">return</span> aNumber.setScale(DECIMALS, ROUNDING_MODE);
  }
} 
    </pre>
    <br />
    Un ejemplo de ejecución da:
    <p></p>
    <p>
      <code>&gt;java -cp . MoneyCalculation 513.89 612.25</code><br />
      <code>Cantidad Uno: 513.89</code><br />
      <code>Cantidad Dos: 612.25</code><br />
      <code>Suma : 1126.14</code><br />
      <code>Diferencia : 98.36</code><br />
      <code>Promedio : 563.07</code><br />
      <code>5.25% de Cantidad Uno: 26.98</code><br />
      <code>Cambio Porcentual de la Cantidad Uno a Dos: 19.14</code>
    </p>
    <p>
      <b>Ejemplo 2</b>
    </p>
    <p>
      La falta de una clase <code>Money</code> real en las bibliotecas KDJ estándar es frustrante. Tal clase tendría algunas 
      ventajas interesantes:
    </p>
    <ul>
      <li>el nombre <code>Money</code> lee a un nivel más alto de abstracción que <code>BigDecimal</code></li>
      <li>las operaciones en <code>BigDecimal</code> se pueden ajustar para producir una forma más adecuada para uso práctico</li>
    </ul>
    A continuación, se muestra un ejemplo de una clase de <code>Money</code>.<br />
    <pre>
<span class="keyword">import</span> java.util.*;
<span class="keyword">import</span> java.io.Serializable;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.io.ObjectInputStream;
<span class="keyword">import</span> java.io.ObjectOutputStream;
<span class="keyword">import</span> java.math.BigDecimal;
<span class="keyword">import</span> <span class="keyword">static</span> java.math.BigDecimal.ZERO;
<span class="keyword">import</span> java.math.RoundingMode;

<span class="comment">/**
* Representa una cantidad de dinero en cualquier moneda.
*
* &lt;P&gt;Esta clase asume &lt;em&gt;moneda decimal&lt;/em&gt;, sin divisiones raras 
* como 1/5 y así sucesivamente. Los objetos &lt;tt&gt;Money&lt;/tt&gt; son inmutables. Al igual que {@link BigDecimal}, 
* muchas operaciones devuelven nuevos objetos &lt;tt&gt;Money&lt;/tt&gt;. Además, la mayoría de las operaciones 
* que involucran más de un objeto &lt;tt&gt;Money&lt;/tt&gt; arrojarán una 
* &lt;tt&gt;MismatchedCurrencyException&lt;/tt&gt; si las monedas no coinciden.
* 
* &lt;h2&gt;Lugares decimales y escala&lt;/h2&gt;
* Los importes monetarios se pueden almacenar en la base de datos de varias formas. Tomemos el
* ejemplo de los dólares. Puede aparecer en la base de datos de las siguientes formas:
* &lt;ul&gt;
*  &lt;li&gt;como &lt;tt&gt;123456.78&lt;/tt&gt;, con el número usual de lugares decimales
*    asociados con esa moneda.
*  &lt;li&gt;como &lt;tt&gt;123456&lt;/tt&gt;, sin ningún lugar decimal.
*  &lt;li&gt;como &lt;tt&gt;123&lt;/tt&gt;, en unidades de miles de dólares.
*  &lt;li&gt;en alguna otra unidad, como millones o miles de millones de dólares.
* &lt;/ul&gt;
* 
* &lt;P&gt;El número de lugares decimales o estilo de unidades se denomina 
* &lt;em&gt;escala&lt;/em&gt; mediante {@link java.math.BigDecimal}. Los constructores de esta clase 
* toman un &lt;tt&gt;BigDecimal&lt;/tt&gt;, por lo que debe comprenderlo usando la idea de escala.
*  
* &lt;P&gt;La escala puede ser negativa. Usando los ejemplos anteriores:
* &lt;table border='1' cellspacing='0' cellpadding='3'&gt;
*  &lt;tr&gt;&lt;th&gt;Número&lt;/th&gt;&lt;th&gt;Escala&lt;/th&gt;&lt;/tr&gt;
*  &lt;tr&gt;&lt;td&gt;123456.78&lt;/th&gt;&lt;th&gt;2&lt;/th&gt;&lt;/tr&gt;
*  &lt;tr&gt;&lt;td&gt;123456&lt;/th&gt;&lt;th&gt;0&lt;/th&gt;&lt;/tr&gt;
*  &lt;tr&gt;&lt;td&gt;123 (miles)&lt;/th&gt;&lt;th&gt;-3&lt;/th&gt;&lt;/tr&gt;
* &lt;/table&gt;
* 
* &lt;P&gt;Tenga en cuenta que la escala y el redondeo son dos cuestiones distintas.
* Además, el redondeo solo es necesario para operaciones de multiplicación y división.
* No se aplica a la suma y la resta.
* 
* &lt;h2&gt;Operaciones y Escala&lt;/h2&gt;
* &lt;P&gt;Las operaciones pueden ser realizadas sobre elementos que tienen &lt;em&gt;escalas diferentes&lt;/em&gt;. 
* Por ejemplo, estas operaciones son válidas (usando una notación simbólica &lt;em&gt;ad hoc&lt;/em&gt;): 
* &lt;PRE&gt;
* 10.plus(1.23) =&gt; 11.23
* 10.minus(1.23) =&gt; 8.77
* 10.gt(1.23) =&gt; true
* 10.eq(10.00) =&gt; true
* &lt;/PRE&gt; 
* Esto corresponde a las expectativas típicas de los usuarios.
* Una excepción importante a esta regla es que {@link #equals (Object)} es sensible
* a escala (mientras que {@link #eq (Money)} no lo es). Eso es, 
* &lt;PRE&gt;
*   10.equals(10.00) =&gt; false
* &lt;/PRE&gt;
*   
* &lt;h2&gt;Multiplicación, división y lugares decimales adicionales&lt;/h2&gt;
* &lt;P&gt;Las operaciones que involucran multiplicación y división son diferentes, ya que el resultado
* puede tener una escala que exceda la esperada para la moneda dada. Por ejemplo
* &lt;PRE&gt;($10.00).times(0.1256) =&gt; $1.256&lt;/PRE&gt;
* que tiene más de dos decimales. En tales casos, &lt;em&gt; esta clase siempre redondeará
* al número esperado de lugares decimales para esa moneda.&lt;/em&gt; 
* Esta es la política más simple y probablemente se ajuste a las expectativas de la mayoría
* de los usuarios finales.
* 
* &lt;P&gt;Esta clase toma un &lt;tt&gt;int&lt;/tt&gt; o un {@link BigDecimal} para sus métodos 
* de multiplicación y división. No tome &lt;tt&gt;float&lt;/tt&gt; o
* &lt;tt&gt;double&lt;/tt&gt; para estos métodos, ya que estos tipos no interactúan bien con 
* &lt;tt&gt;BigDecimal&lt;/tt&gt;. En su lugar, la clase &lt;tt&gt;BigDecimal&lt;/tt&gt; debe ser utilizada cuando el 
* factor o divisor es un no entero. Esto Establece sus 
* valores predeterminados deseados. Por lo general, se llamará una vez (y solo una vez) al inicio.
*  
* &lt;P&gt;Varios métodos de esta clase tienen nombres inusualmente concisos, como
* {@link #lt} y {@link #gt}. La intención es que tales nombres mejoren la
* legibilidad de expresiones matemáticas. Ejemplo : 
* &lt;PRE&gt; if ( amount.lt(hundred) ) {
*     cost = amount.times(price); 
*  }&lt;/PRE&gt;
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> Money <span class="keyword">implements</span> Comparable&lt;Money&gt;, Serializable {
  
  <span class="comment">/**
  * Lanzada cuando un conjunto de objetos &lt;tt&gt;Money&lt;/tt&gt; no tienen monedas coincidentes.
  * 
  * &lt;P&gt;Por ejemplo, sumar euros y dólares no tiene ningún sentido.
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">final</span> <span class="keyword">class</span> MismatchedCurrencyException <span
            class="keyword">extends</span> RuntimeException { 
    MismatchedCurrencyException(String aMessage){
      <span class="keyword">super</span>(aMessage);
    }
  }
  
  <span class="comment">/**
  * Establece valores predeterminados para la moneda y el estilo de redondeo.
  * 
  * &lt;em&gt;Su aplicación debe llamar a este método al inicio&lt;/em&gt;.
  * Este método generalmente debe llamarse solo una vez (al inicio).
  * 
  * &lt;P&gt;El estilo de redondeo recomendado es {@link RoundingMode # HALF_EVEN}, también llamado
  * &lt;em&gt;redondeo bancario&lt;/em&gt;; este estilo de redondeo introduce el menor sesgo.
  * 
  * &lt;P&gt;Establecer estos valores predeterminados le permite utilizar los constructores más concisos de esta clase,
  * que son mucho más convenientes. 
  *  
  * &lt;P&gt;(En un entorno de servlet, cada aplicación tiene su propio cargador de clases. Llamar a este 
  * método en una aplicación nunca afectará el funcionamiento de una segunda aplicación que se ejecuta en el mismo
  * contenedor de servlets. Son independientes).
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> init(Currency aDefaultCurrency, RoundingMode aDefaultRounding){
    DEFAULT_CURRENCY = aDefaultCurrency;
    DEFAULT_ROUNDING = aDefaultRounding;
  }

  <span class="comment">/**
  * Constructor completo.
  * 
  * @param aAmount es obligatorio, puede ser positivo o negativo. La cantidad de 
  * decimales en la cantidad no puede &lt;em&gt;exceder&lt;/em&gt; la cantidad máxima de 
  * decimales para la {@link Currency} dada. Es posible crear un 
  * objeto &lt;tt&gt;Money&lt;/tt&gt; en términos de 'miles de dólares', por ejemplo. 
  * Tal cantidad tendría una escala de -3. 
  * @param aCurrency es obligatorio.
  * @param aRoundingStyle es obligatorio, debe coincidir con un estilo de redondeo utilizado por 
  * {@link BigDecimal}.
  */</span>
  <span class="keyword">public</span> Money(BigDecimal aAmount, Currency aCurrency, RoundingMode aRoundingStyle){
    fAmount = aAmount;
    fCurrency = aCurrency;
    fRounding = aRoundingStyle;
    validateState();
  }
  
  <span class="comment">/**
  * Constructor tomando solo la cantidad de dinero.
  * 
  * &lt;P&gt;Tanto la moneda como el estilo de redondeo toman valores predeterminados.
  * @param aAmount es obligatorio, puede ser positivo o negativo.
  */</span>
  <span class="keyword">public</span> Money(BigDecimal aAmount){
    <span class="keyword">this</span>(aAmount, DEFAULT_CURRENCY, DEFAULT_ROUNDING);
  }
  
  <span class="comment">/**
  * Constructor que toma la cantidad de dinero y moneda.
  * 
  * &lt;P&gt;El estilo de redondeo toma un valor predeterminado.
  * @param aAmount es obligatorio, puede ser positivo o negativo.
  * @param aCurrency es obligatorio.
  */</span>
  <span class="keyword">public</span> Money(BigDecimal aAmount, Currency aCurrency){
    <span class="keyword">this</span>(aAmount, aCurrency, DEFAULT_ROUNDING);
  }
  
  <span class="comment">/** Devuelve la cantidad pasada al constructor. */</span>
  <span class="keyword">public</span> BigDecimal getAmount() { <span
            class="keyword">return</span> fAmount; }
  
  <span class="comment">/** Devuelve la moneda pasada al constructor o la moneda predeterminada. */</span>
  <span class="keyword">public</span> Currency getCurrency() { <span
            class="keyword">return</span> fCurrency; }
  
  <span class="comment">/** Devuelve el estilo de redondeo pasado al constructor o el estilo de redondeo predeterminado. */</span>
  <span class="keyword">public</span> RoundingMode getRoundingStyle() { <span
            class="keyword">return</span> fRounding; }
  
  <span class="comment">/**
  * Devuelve &lt;tt&gt;true&lt;/tt&gt; solo si &lt;tt&gt;aThat&lt;/tt&gt; &lt;tt&gt;Money&lt;/tt&gt; tiene la misma moneda 
  * que este &lt;tt&gt;Money&lt;/tt&gt;.
  */</span>
  <span class="keyword">public</span> <span class="keyword">boolean</span> isSameCurrencyAs(Money aThat){
    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;
     <span class="keyword">if</span> ( aThat != <span class="keyword">null</span> ) { 
       result = <span class="keyword">this</span>.fCurrency.equals(aThat.fCurrency);
     }
     <span class="keyword">return</span> result; 
  }
  
  <span class="comment">/** Devuelve &lt;tt&gt;true&lt;/tt&gt; solo si la cantidad es positiva. */</span>
  <span class="keyword">public</span> <span class="keyword">boolean</span> isPlus(){
    <span class="keyword">return</span> fAmount.compareTo(ZERO) &gt; <span
            class="literal">0</span>;
  }
  
  <span class="comment">/** Devuelve &lt;tt&gt;true&lt;/tt&gt; solo si la cantidad es negativa. */</span>
  <span class="keyword">public</span> <span class="keyword">boolean</span> isMinus(){
    <span class="keyword">return</span> fAmount.compareTo(ZERO) &lt;  <span
            class="literal">0</span>;
  }
  
  <span class="comment">/** Devuelve &lt;tt&gt;true&lt;/tt&gt; solo si la cantidad es cero. */</span>
  <span class="keyword">public</span> <span class="keyword">boolean</span> isZero(){
    <span class="keyword">return</span> fAmount.compareTo(ZERO) ==  <span
            class="literal">0</span>;
  }
  
  <span class="comment">/** 
  * Agrega &lt;tt&gt;aThat&lt;/tt&gt; &lt;tt&gt;Money&lt;/tt&gt; a este &lt;tt&gt;Money&lt;/tt&gt;.
  * Las monedas deben coincidir.  
  */</span>
  <span class="keyword">public</span> Money plus(Money aThat){
    checkCurrenciesMatch(aThat);
    <span class="keyword">return</span> <span class="keyword">new</span> Money(fAmount.add(aThat.fAmount), fCurrency, fRounding);
  }

  <span class="comment">/** 
  * Sustrae &lt;tt&gt;aThat&lt;/tt&gt; &lt;tt&gt;Money&lt;/tt&gt; de este &lt;tt&gt;Money&lt;/tt&gt;. 
  * Las monedas deben coincidir.  
  */</span>
  <span class="keyword">public</span> Money minus(Money aThat){
    checkCurrenciesMatch(aThat);
    <span class="keyword">return</span> <span class="keyword">new</span> Money(fAmount.subtract(aThat.fAmount), fCurrency, fRounding);
  }

  <span class="comment">/**
  * Suma una colección de objetos &lt;tt&gt;Money&lt;/tt&gt;.
  * Las monedas deben coincidir. Se le anima a utilizar las funciones de resumen de la base de datos
  * siempre que sea posible, en lugar de este método.
  * 
  * @param aMoneys colección de objetos &lt;tt&gt;Money&lt;/tt&gt;, todos de la misma moneda.
  * Si la colección está vacía, se devuelve un valor cero.
  * @param aCurrencyIfEmpty se usa solo cuando &lt;tt&gt;aMoneys&lt;/tt&gt; está vacío; de esa manera, este 
  * método puede devolver una cantidad cero en la moneda deseada. 
  */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> Money sum(Collection&lt;Money&gt; aMoneys, Currency aCurrencyIfEmpty){
    Money sum = <span class="keyword">new</span> Money(ZERO, aCurrencyIfEmpty);
    <span class="keyword">for</span>(Money money : aMoneys){
      sum = sum.plus(money);
    }
    <span class="keyword">return</span> sum;
  }
  
  <span class="comment">/** 
  * Igual que (insensible a la escala).
  * 
  * &lt;P&gt;Devuelve &lt;tt&gt;true&lt;/tt&gt; solo si las cantidades son iguales.
  * Las monedas deben coincidir. 
  * Este método &lt;em&gt;no&lt;/em&gt; es sinónimo del método &lt;tt&gt;equals&lt;/tt&gt;.
  */</span>
  <span class="keyword">public</span> <span class="keyword">boolean</span> eq(Money aThat) {
    checkCurrenciesMatch(aThat);
    <span class="keyword">return</span> compareAmount(aThat) == <span
            class="literal">0</span>;
  }

  <span class="comment">/** 
  * Mayor que.
  * 
  * &lt;P&gt;Devuelve &lt;tt&gt;true&lt;/tt&gt; solo si 'esta' cantidad es mayor que 
  * 'esa' cantidad. Las monedas deben coincidir. 
  */</span>
  <span class="keyword">public</span> <span class="keyword">boolean</span> gt(Money aThat) { 
    checkCurrenciesMatch(aThat);
    <span class="keyword">return</span> compareAmount(aThat) &gt; <span
            class="literal">0</span>;  
  }
  
  <span class="comment">/** 
  * Mayor que o igual a.
  * 
  * &lt;P&gt;Devuelve &lt;tt&gt;true&lt;/tt&gt; solo si 'esta' cantidad es 
  * mayor o igual que 'esa' cantidad. Las monedas deben coincidir. 
  */</span>
  <span class="keyword">public</span> <span class="keyword">boolean</span> gteq(Money aThat) { 
    checkCurrenciesMatch(aThat);
    <span class="keyword">return</span> compareAmount(aThat) &gt;= <span
            class="literal">0</span>;  
  }
  
  <span class="comment">/** 
  * Menor que.
  * 
  * &lt;P&gt;Devuelve &lt;tt&gt;true&lt;/tt&gt; solo si 'esta' cantidad es menor que 
  * 'esa' cantidad. Las monedas deben coincidir. 
  */</span>
  <span class="keyword">public</span> <span class="keyword">boolean</span> lt(Money aThat) { 
    checkCurrenciesMatch(aThat);
    <span class="keyword">return</span> compareAmount(aThat) &lt; <span
            class="literal">0</span>;  
  }
  
  <span class="comment">/** 
  * Menor o igual que.
  * 
  * &lt;P&gt;Devuelve &lt;tt&gt;true&lt;/tt&gt; solo si 'esta' cantidad es menor o igual que 
  * 'esa' cantidad. Las monedas deben coincidir. 
  */</span>
  <span class="keyword">public</span> <span class="keyword">boolean</span> lteq(Money aThat) { 
    checkCurrenciesMatch(aThat);
    <span class="keyword">return</span> compareAmount(aThat) &lt;= <span
            class="literal">0</span>;  
  }
  
  <span class="comment">/**
  * Multiplica este &lt;tt&gt;Money&lt;/tt&gt; por un factor integral.
  * 
  * La escala del &lt;tt&gt;Money&lt;/tt&gt; devuelto es igual a la escala de 'este' 
  * &lt;tt&gt;Money&lt;/tt&gt;.
  */</span>
  <span class="keyword">public</span> Money times(<span class="keyword">int</span> aFactor){  
    BigDecimal factor = <span class="keyword">new</span> BigDecimal(aFactor);
    BigDecimal newAmount = fAmount.multiply(factor);
    <span class="keyword">return</span> <span class="keyword">new</span> Money(newAmount, fCurrency, fRounding);
  }
  
  <span class="comment">/**
  * Multiplica este &lt;tt&gt;Money&lt;/tt&gt; por un factor no integral (que tiene un punto decimal).
  * 
  * &lt;P&gt;La escala del &lt;tt&gt;Money&lt;/tt&gt; devuelto es igual a la escala de 
  * 'este' &lt;tt&gt;Money&lt;/tt&gt;. 
  */</span>
  <span class="keyword">public</span> Money times(<span class="keyword">double</span> aFactor){
    BigDecimal newAmount = fAmount.multiply(asBigDecimal(aFactor));
    newAmount = newAmount.setScale(getNumDecimalsForCurrency(), fRounding);
    <span class="keyword">return</span>  <span class="keyword">new</span> Money(newAmount, fCurrency, fRounding);
  }
  
  <span class="comment">/**
  * Divide este &lt;tt&gt;Money&lt;/tt&gt; por un divisor integral.
  * 
  * &lt;P&gt;The scale of the returned &lt;tt&gt;Money&lt;/tt&gt; is equal to the scale of 
  * 'this' &lt;tt&gt;Money&lt;/tt&gt;. 
  */</span>
  <span class="keyword">public</span> Money div(<span class="keyword">int</span> aDivisor){
    BigDecimal divisor = <span class="keyword">new</span> BigDecimal(aDivisor);
    BigDecimal newAmount = fAmount.divide(divisor, fRounding);
    <span class="keyword">return</span> <span class="keyword">new</span> Money(newAmount, fCurrency, fRounding);
  }

  <span class="comment">/**
  * Divide este &lt;tt&gt;Money&lt;/tt&gt; por un divisor no integral.
  * 
  * &lt;P&gt;La escala del &lt;tt&gt;Money&lt;/tt&gt; devuelto es igual a la escala de 
  * 'este' &lt;tt&gt;Money&lt;/tt&gt;. 
  */</span>
  <span class="keyword">public</span> Money div(<span class="keyword">double</span> aDivisor){  
    BigDecimal newAmount = fAmount.divide(asBigDecimal(aDivisor), fRounding);
    <span class="keyword">return</span> <span class="keyword">new</span> Money(newAmount, fCurrency, fRounding);
  }

  <span class="comment">/** Devuelve el valor absoluto de la cantidad. */</span>
  <span class="keyword">public</span> Money abs(){
    <span class="keyword">return</span> isPlus() ? <span class="keyword">this</span> : times(-<span
            class="literal">1</span>);
  }
  
  <span class="comment">/** Devuelve la cantidad x (-1). */</span>
  <span class="keyword">public</span> Money negate(){ 
    <span class="keyword">return</span> times(-<span class="literal">1</span>); 
  }
  
  <span class="comment">/**
  * Devuelve 
  * {@link #getAmount()}.getPlainString() + space + {@link #getCurrency()}.getSymbol().
  * 
  * &lt;P&gt;El valor devuelto usa la &lt;em&gt;configuración regional&lt;/em&gt; predeterminada del tiempo de ejecución, y no 
  * siempre será adecuado para mostrarlo a un usuario final.
  */</span>
  <span class="keyword">public</span> String toString(){
    <span class="keyword">return</span> fAmount.toPlainString() + <span
            class="literal">" "</span> + fCurrency.getSymbol();
  }
  
  <span class="comment">/**
  * Como {@link BigDecimal#equals(java.lang.Object)}, este método &lt;tt&gt;equals&lt;/tt&gt; 
  * es también sensible a la escala.
  * 
  * Por ejemplo, &lt;tt&gt;10&lt;/tt&gt; &lt;em&gt;no&lt;/em&gt; es igual a &lt;tt&gt;10.00&lt;/tt&gt;
  * El método {@link #eq(Money)}, por otro lado, &lt;em&gt;not&lt;/em&gt; es 
  * sensible a la escala.
  */</span>
  <span class="keyword">public</span> <span class="keyword">boolean</span> equals(Object aThat){
    <span class="keyword">if</span> (<span class="keyword">this</span> == aThat) <span
            class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span> (! (aThat <span class="keyword">instanceof</span> Money) ) <span
            class="keyword">return</span> <span class="keyword">false</span>;
    Money that = (Money)aThat;
    <span class="comment">//el objeto fields no es nunca nulo :
</span>    <span class="keyword">boolean</span> result = (<span class="keyword">this</span>.fAmount.equals(that.fAmount) );
    result = result &amp;&amp; (<span class="keyword">this</span>.fCurrency.equals(that.fCurrency) );
    result = result &amp;&amp; (<span class="keyword">this</span>.fRounding == that.fRounding);
    <span class="keyword">return</span> result;
  }
  
  <span class="keyword">public</span> <span class="keyword">int</span> hashCode(){
    <span class="keyword">if</span> ( fHashCode == <span class="literal">0</span> ) {
      fHashCode = HASH_SEED;
      fHashCode = HASH_FACTOR * fHashCode + fAmount.hashCode(); 
      fHashCode = HASH_FACTOR * fHashCode + fCurrency.hashCode();
      fHashCode = HASH_FACTOR * fHashCode + fRounding.hashCode();
    }
    <span class="keyword">return</span> fHashCode;
  }
  
  <span class="keyword">public</span> <span class="keyword">int</span> compareTo(Money aThat) {
    <span class="keyword">final</span> <span class="keyword">int</span> EQUAL = <span
            class="literal">0</span>;
    
    <span class="keyword">if</span> ( <span class="keyword">this</span> == aThat ) <span
            class="keyword">return</span> EQUAL;

    <span class="comment">//el objeto fields no es nunca nulo :
</span>    <span class="keyword">int</span> comparison = <span class="keyword">this</span>.fAmount.compareTo(aThat.fAmount);
    <span class="keyword">if</span> ( comparison != EQUAL ) <span
            class="keyword">return</span> comparison;

    comparison = <span class="keyword">this</span>.fCurrency.getCurrencyCode().compareTo(
      aThat.fCurrency.getCurrencyCode()
    );
    <span class="keyword">if</span> ( comparison != EQUAL ) <span
            class="keyword">return</span> comparison;    

    
    comparison = <span class="keyword">this</span>.fRounding.compareTo(aThat.fRounding);
    <span class="keyword">if</span> ( comparison != EQUAL ) <span
            class="keyword">return</span> comparison;    
    
    <span class="keyword">return</span> EQUAL;
  }
  
  <span class="comment">// PRIVADO //
</span>  
  <span class="comment">/** 
  * La cantidad de dineroThe money amount. 
  * Nunca es nula. 
  * @serial 
  */</span>
  <span class="keyword">private</span> BigDecimal fAmount;
  
  <span class="comment">/** 
  * La moneda del dinero, tal como Dólares EEUU o Euros.
  * Nucan es nula. 
  * @serial 
  */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> Currency fCurrency;
  
  <span class="comment">/** 
  * El estilo de redondeo a usarse. 
  * Vea {@link BigDecimal}.
  * @serial  
  */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> RoundingMode fRounding;
  
  <span class="comment">/**
  * La moneda predeterminada a usarse si no se pasa una moneda al constructor. 
  */</span> 
  <span class="keyword">private</span> <span class="keyword">static</span> Currency DEFAULT_CURRENCY;
  
  <span class="comment">/**
  * El estilo predeterminado de redondeo a usarse si no se pasa una moneda al constructor.
  * Vea {@link BigDecimal}. 
  */</span> 
  <span class="keyword">private</span> <span class="keyword">static</span> RoundingMode DEFAULT_ROUNDING;
  
  <span class="comment">/** @serial */</span>
  <span class="keyword">private</span> <span class="keyword">int</span> fHashCode;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> <span class="keyword">int</span> HASH_SEED = <span
            class="literal">23</span>;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> <span class="keyword">int</span> HASH_FACTOR = <span
            class="literal">37</span>;
  
  <span class="comment">/**
  * Determina si un archivo deserializado es compatible con esta clase.
  *
  * Los mantenedores deben cambiar este valor si y solo si la nueva versión
  * de esta clase no es compatible con versiones antiguas. Ver documentos de Sun
  * para los detalles &lt;a href=http://java.sun.com/products/jdk/1.1/docs/guide
  * /serialization/spec/version.doc.html&gt;. &lt;/a&gt;
  *
  * No es necesrio incluirlo en la primera versión de la clase, pero 
  * está incluido aquí como un recordatorio de su importancia.
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span
            class="literal">7526471155622776147L</span>;

  <span class="comment">/**
  * Trate siempre la deserialización como un constructor en toda regla, 
  * validando el estado final del objeto deserializado.
  */</span>  
  <span class="keyword">private</span> <span class="keyword">void</span> readObject(
    ObjectInputStream aInputStream
  ) <span class="keyword">throws</span> ClassNotFoundException, IOException {
    <span class="comment">//siempre realiza la deserialización predeterminada primero
</span>    aInputStream.defaultReadObject();
    <span class="comment">//copia defensiva para campo de fecha mutable
</span>    <span class="comment">//BigDecimal no es técnicamente inmutable, ya que su no final
</span>    fAmount = <span class="keyword">new</span> BigDecimal( fAmount.toPlainString() );
    <span class="comment">//Asegúrese de que el estado del objeto no se haya corrompido o manipulado maliciosamente.
</span>    validateState();
  }

  <span class="keyword">private</span> <span class="keyword">void</span> writeObject(ObjectOutputStream aOutputStream) <span
            class="keyword">throws</span> IOException {
    <span class="comment">//realizar la serialización predeterminada para todos los campos no transitorios y no estáticos
</span>    aOutputStream.defaultWriteObject();
  }  

  <span class="keyword">private</span> <span class="keyword">void</span> validateState(){
    <span class="keyword">if</span>( fAmount == <span class="keyword">null</span> ) {
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span
            class="literal">"La cantidad no puede ser nula"</span>);
    }
    <span class="keyword">if</span>( fCurrency == <span class="keyword">null</span> ) {
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span
            class="literal">"La moneda no puede ser nula"</span>);
    }
    <span class="keyword">if</span> ( fAmount.scale() &gt; getNumDecimalsForCurrency() ) {
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(
        <span class="literal">"El número de decimales es "</span> + fAmount.scale() + <span
            class="literal">", pero la moneda solo lleva"</span> + 
        getNumDecimalsForCurrency() + <span class="literal">" decimales."</span>
      );    
    }
  }
  
  <span class="keyword">private</span> <span class="keyword">int</span> getNumDecimalsForCurrency(){
    <span class="keyword">return</span> fCurrency.getDefaultFractionDigits();
  }
  
  <span class="keyword">private</span> <span class="keyword">void</span> checkCurrenciesMatch(Money aThat){
    <span class="keyword">if</span> (! <span class="keyword">this</span>.fCurrency.equals(aThat.getCurrency())) {
       <span class="keyword">throw</span> <span class="keyword">new</span> MismatchedCurrencyException(
         aThat.getCurrency() + <span class="literal">" no coincide con la moneda esperada: "</span> + fCurrency
       ); 
    }
  }
  
  <span class="comment">/** Ignora la escala: 0 same as 0.00 */</span>
  <span class="keyword">private</span> <span class="keyword">int</span> compareAmount(Money aThat){
    <span class="keyword">return</span> <span class="keyword">this</span>.fAmount.compareTo(aThat.fAmount);
  }
  
  <span class="keyword">private</span> BigDecimal asBigDecimal(<span
            class="keyword">double</span> aDouble){
    String asString = Double.toString(aDouble);
    <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(asString);
  }
} 
    </pre>
    <br />
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\practicascomunes\practicascomunes_213.html">Tenga cuidado con los números de punto flotante</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>