<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Analizar el texto</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Búsqueda" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">Analizar el texto</div>
    <br />
    Hay varias formas de analizar texto. Las herramientas usuales son:
    <ul>
      <li>
        Métodos <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/String.html#split(java.lang.String)">String.split</a>.
        (¡Tenga cuidado! Estos métodos se implementan con una expresión regular. Si su delimitador usa caracteres que tienen un 
        significado especial para una expresión regular, entonces
        <b>
          necesitará 
          <a href="https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html#quote(java.lang.String)">escapar</a>
        </b> el delimitador).
      </li>
      <li>
        las clases <a href="https://docs.oracle.com/javase/10/docs/api/java/util/StringTokenizer.html">StringTokenizer</a> y
        <a href="https://docs.oracle.com/javase/10/docs/api/java/io/StreamTokenizer.html">StreamTokenizer</a>
      </li>
      <li>la clase <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Scanner.html">Scanner</a></li>
      <li>
        las clases <a href="https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html">Pattern</a> y
        <a href="https://docs.oracle.com/javase/10/docs/api/java/util/regex/Matcher.html">Matcher</a>, que implementan las 
        expresiones regulares
      </li>
      <li>para las tareas de análisis más complejas, puede usar herramientas tales como <a href="https://javacc.org/">JavaCC</a></li>
    </ul>
    <b>Ejemplo 1</b>
    <p>
      Este ejemplo usa <code>Scanner</code>. Aquí, se leen los contenidos de un archivo que contiene pares nombre-valor, y cada 
      línea se analiza en sus datos constituyentes. <br />
    </p>
    <pre>
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.nio.charset.Charset;
<span class="keyword">import</span> java.nio.charset.StandardCharsets;
<span class="keyword">import</span> java.nio.file.Path;
<span class="keyword">import</span> java.nio.file.Paths;
<span class="keyword">import</span> java.util.Objects;
<span class="keyword">import</span> java.util.Scanner;

<span class="comment">/** Asume la codificación UTF-8 encoding. KDJ 7+. */</span>
<span class="keyword">public</span> <span class="keyword">class</span> ReadWithScanner {

  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> main(String... aArgs) <span
            class="keyword">throws</span> IOException {
    ReadWithScanner parser = <span class="keyword">new</span> ReadWithScanner(<span
            class="literal">"C:\\Temp\\test.txt"</span>);
    parser.processLineByLine();
    log(<span class="literal">"Hecho."</span>);
  }
  
  <span class="comment">/**
   Constructor.
   @param aFileName nombre completo de un archivo existente y legible.
  */</span>
  <span class="keyword">public</span> ReadWithScanner(String aFileName){
    fFilePath = Paths.get(aFileName);
  }
  
  
  <span class="comment">/** Método plantila que llama {@link #processLine(String)}.  */</span>
  <span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">void</span> processLineByLine() <span
            class="keyword">throws</span> IOException {
    <span class="keyword">try</span> (Scanner scanner =  <span
            class="keyword">new</span> Scanner(fFilePath, ENCODING.name())){
      <span class="keyword">while</span> (scanner.hasNextLine()){
        processLine(scanner.nextLine());
      }      
    }
  }
  
  <span class="comment">/** 
   Metodo sobreescribible para procesar las líneas de diferentes formas.
    
   &lt;P&gt;Esta implementación simple predeterminada espera pares simples nombre-valor, separados por un 
   signo '='. Ejemplos de entradas válidas: 
   &lt;tt&gt;altura = 167cm&lt;/tt&gt;
   &lt;tt&gt;masa =  65kg&lt;/tt&gt;
   &lt;tt&gt;disposición =  "gruñón"&lt;/tt&gt;
   &lt;tt&gt;este es el nombre = este es el valor&lt;/tt&gt;
  */</span>
  <span class="keyword">protected</span> <span class="keyword">void</span> processLine(String aLine){
    <span class="comment">//usa un segundo Scanner para analizar el contenido de cada línea
</span>    <span class="keyword">try</span>(Scanner scanner = <span
            class="keyword">new</span> Scanner(aLine)){
      scanner.useDelimiter(<span class="literal">"="</span>);
      <span class="keyword">if</span> (scanner.hasNext()){
        <span class="comment">//asume que la línea tiene una cierta estructura
</span>        String name = scanner.next();
        String value = scanner.next();
        log(<span class="literal">"El Nombre es : "</span> + quote(name.trim()) + <span
            class="literal">", y el Valor es : "</span> + quote(value.trim()));
      }
      <span class="keyword">else</span> {
        log(<span class="literal">"Línea vacía o no válida. Incapaz de procesar."</span>);
      }
    }
  }
  
  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> <span class="keyword">final</span> Path fFilePath;
  <span class="keyword">private</span> <span class="keyword">final</span> <span
            class="keyword">static</span> Charset ENCODING = StandardCharsets.UTF_8;  
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> log(Object aObject){
    System.out.println(Objects.toString(aObject));
  }
  
  <span class="keyword">private</span> String quote(String aText){
    String QUOTE = <span class="literal">"'"</span>;
    <span class="keyword">return</span> QUOTE + aText + QUOTE;
  }
} 
    </pre>
    <br />
    Para un archivo que contiene:
    <p></p>
    <pre>
height = 167cm
mass =  65kg
disposition =  "grumpy"
this is the name = this is the value
    </pre>
    la salida de la clase de arriba es: 
    the output of the above class is:
    <pre>
El Nombre es : 'height', y el Valor es : '167cm'
El Nombre es : 'mass', y el Valor es : '65kg'
El Nombre es : 'disposition', y el Valor es : '"grumpy"'
El Nombre es : 'this is the name', y el Valor es : 'this is the value'
Hecho.
    </pre>
    <p>
      <b>Ejemplo 2</b>
    </p>
    <p>
      Este ejemplo usa <code>StringTokenizer</code>. Esta clase se usa para analizar el texto introducido en una caja de búsqueda 
      de una página web. Devuelve un <code>Set</code> de tokens que se usan para coincidencia de patrones. Aquí, cualquier texto 
      que aparezca entre comillas se trata como un token de búsqueda simple. El resto del texto es separado en tokens basados 
      simplemente en un espacio en blanco.
    </p>
    <p>
      Un ejemplo de ejecución:
    </p>
    <p>
      <code>&gt;java -cp . SearchBoxParser</code><br />
      <code>[mars, sun, milky way, venus]</code><br />
    </p>
    <pre>
<span class="keyword">import</span> java.util.*;

<span class="comment">/**
* El usuario introduce texto dentro de una caja de búsqueda. Esta clase se usa 
* para analizar ese texto en términos específicos de búsqueda (o tokens).
* Elimina las palabras comunes, y permite el entrecomillado del texto, usando 
* comillas dobles.
* JDK 7+.
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> SearchBoxParser {

  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> main(String... aArguments) {
    SearchBoxParser parser = <span class="keyword">new</span> SearchBoxParser(<span
            class="literal">"mars venus \"milky way\" sun"</span>);
    Set&lt;String&gt; tokens = parser.parseSearchText();
    <span class="comment">//muestra los tokens
</span>    System.out.println(tokens);
  }

  <span class="comment">/**
  * @param aSearchText es no nulo, pero puede no tener contenido,
  * y representa lo que el usuario ha introducido en una caja de búsqueda.
  */</span>
  <span class="keyword">public</span> SearchBoxParser(String aSearchText) {
    <span class="keyword">if</span> (aSearchText == <span
            class="keyword">null</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span
            class="literal">"El Texto de Búsqueda no puede ser nulo."</span>);
    }
    fSearchText = aSearchText;
  }

  <span class="comment">/**
  * Analice la entrada del cuadro de búsqueda del usuario en un conjunto de tokens de Strings.
  *
  * @return Un Set de Strings, uno por cada palabra en fSearchText; aquí "palabra"
  * se define como una sola palabra rodeada por espaciones, o como una serie de 
  * palabras rodeadas por comillas dobles, "como estas"; además, las palabras muy 
  * comunes (y, el, la, los, las, etc.) no califican como objetos de búsqueda posibles.
  */</span>
  <span class="keyword">public</span> Set&lt;String&gt; parseSearchText() {
    Set&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();

    <span class="keyword">boolean</span> returnTokens = <span
            class="keyword">true</span>;
    String currentDelims = fWHITESPACE_AND_QUOTES;
    StringTokenizer parser = <span class="keyword">new</span> StringTokenizer(
      fSearchText, currentDelims, returnTokens
    );

    String token = <span class="keyword">null</span>;
    <span class="keyword">while</span> (parser.hasMoreTokens()) {
      token = parser.nextToken(currentDelims);
      <span class="keyword">if</span> (!isDoubleQuote(token)){
        addNonTrivialWordToResult(token, result);
      }
      <span class="keyword">else</span> {
        currentDelims = flipDelimiters(currentDelims);
      }
    }
    <span class="keyword">return</span> result;
  }

  <span class="comment">// PRIVADO
</span>  <span class="keyword">private</span> String fSearchText;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> Set&lt;String&gt; fCOMMON_WORDS = <span
            class="keyword">new</span> LinkedHashSet&lt;&gt;();
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> String fDOUBLE_QUOTE = <span
            class="literal">"\""</span>;

  <span class="comment">//el analizador cambia entre estos dos conjuntos de delimitadores
</span>  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> String fWHITESPACE_AND_QUOTES = <span
            class="literal">" \t\r\n\""</span>;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> String fQUOTES_ONLY =<span
            class="literal">"\""</span>;

  <span class="comment">/**Palabras muy comunes que deben excluirse de las búsquedas.*/</span>
  <span class="keyword">static</span> {
    fCOMMON_WORDS.add(<span class="literal">"a"</span>);
    fCOMMON_WORDS.add(<span class="literal">"and"</span>);
    fCOMMON_WORDS.add(<span class="literal">"be"</span>);
    fCOMMON_WORDS.add(<span class="literal">"for"</span>);
    fCOMMON_WORDS.add(<span class="literal">"from"</span>);
    fCOMMON_WORDS.add(<span class="literal">"has"</span>);
    fCOMMON_WORDS.add(<span class="literal">"i"</span>);
    fCOMMON_WORDS.add(<span class="literal">"in"</span>);
    fCOMMON_WORDS.add(<span class="literal">"is"</span>);
    fCOMMON_WORDS.add(<span class="literal">"it"</span>);
    fCOMMON_WORDS.add(<span class="literal">"of"</span>);
    fCOMMON_WORDS.add(<span class="literal">"on"</span>);
    fCOMMON_WORDS.add(<span class="literal">"to"</span>);
    fCOMMON_WORDS.add(<span class="literal">"the"</span>);
  }

  <span class="comment">/**
  * Úselo para determinar si una palabra en particular ingresada en el
  * cuadro de búsqueda debe descartarse de la búsqueda.
  */</span>
  <span class="keyword">private</span> <span class="keyword">boolean</span> isCommonWord(String aSearchTokenCandidate){
    <span class="keyword">return</span> fCOMMON_WORDS.contains(aSearchTokenCandidate);
  }

  <span class="keyword">private</span> <span class="keyword">boolean</span> textHasContent(String aText){
    <span class="keyword">return</span> (aText != <span class="keyword">null</span>) &amp;&amp; (!aText.trim().equals(<span
            class="literal">""</span>));
  }

  <span class="keyword">private</span> <span class="keyword">void</span> addNonTrivialWordToResult(String aToken, Set&lt;String&gt; aResult){
    <span class="keyword">if</span> (textHasContent(aToken) &amp;&amp; !isCommonWord(aToken.trim())) {
      aResult.add(aToken.trim());
    }
  }

  <span class="keyword">private</span> <span class="keyword">boolean</span> isDoubleQuote(String aToken){
    <span class="keyword">return</span> aToken.equals(fDOUBLE_QUOTE);
  }

  <span class="keyword">private</span> String flipDelimiters(String aCurrentDelims){
    String result = <span class="keyword">null</span>;
    <span class="keyword">if</span> (aCurrentDelims.equals(fWHITESPACE_AND_QUOTES)){
      result = fQUOTES_ONLY;
    }
    <span class="keyword">else</span> {
      result = fWHITESPACE_AND_QUOTES;
    }
    <span class="keyword">return</span> result;
  }
} 
    </pre>
    <br />
    <b>Ejemplo 3</b>
    <p></p>
    <p>
      Este ejemplo demuestra el uso de expresiones regulares, analizando un tipo de nombre cualificado completamente en dos partes 
      - el paquete y el tipo de nombre "simple".<br />
    </p>
    <pre>
<span class="keyword">import</span> java.util.Objects;
<span class="keyword">import</span> java.util.regex.*;

<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> RegularExpressions {

  <span class="comment">/** El patrón se corresponde con el primer argumento. */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> main (String... aArguments) {
    matchParts(aArguments[<span class="literal">0</span>]);
    matchAll(aArguments[<span class="literal">0</span>]);
  }

  <span class="comment">/**
   El método Matcher.find intenta coincidir *partes* de la entrada 
   al patrón dado.
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> matchParts(String aText){
    log(fNEW_LINE + <span class="literal">"PARTES coincidentes:"</span>);
    <span class="comment">//tenga en cuenta la necesidad de la bandera de comentarios, 
</span>    <span class="comment">//ya que nuestra expresión regular contiene comentarios: 
</span>    Pattern pattern = Pattern.compile(fREGEXP, Pattern.COMMENTS);
    Matcher matcher = pattern.matcher(aText);
    <span class="keyword">while</span> (matcher.find()) {
      log(<span class="literal">"Número de grupos: "</span> + matcher.groupCount());
      log(<span class="literal">"Paquete: "</span> + matcher.group(<span
            class="literal">1</span>));
      log(<span class="literal">"Clase: "</span> + matcher.group(<span
            class="literal">2</span>));
    }
  }

  <span class="comment">/**
   El método Matcher.matches intenta hacer coincidir la entrada * completa * 
   con el patrón dado de una vez.
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> matchAll(String aText){
    log(fNEW_LINE + <span class="literal">"Coincide TODO:"</span>);
    Pattern pattern = Pattern.compile(fREGEXP, Pattern.COMMENTS);
    Matcher matcher = pattern.matcher(aText);
    <span class="keyword">if</span>(matcher.matches()) {
      log(<span class="literal">"Número de grupos: "</span> + matcher.groupCount());
      log(<span class="literal">"Paquete: "</span> + matcher.group(<span
            class="literal">1</span>));
      log(<span class="literal">"Clase: "</span> + matcher.group(<span
            class="literal">2</span>));
    }
    <span class="keyword">else</span> {
      log(<span class="literal">"La entrada no coincide con el patrón."</span>);
    }
  }

  <span class="comment">//PRIVADO
</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> String fNEW_LINE = System.getProperty(<span
            class="literal">"line.separator"</span>);
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> log(String aMessage){
    System.out.println(Objects.toString(aMessage));
  }

  <span class="comment">/**
   Una expresión regular comentada para nombres de tipos completamente calificados que siguen las convenciones de nomenclatura 
   comunes, por ejemplo, "com.myappBlah.Thing".
  
   Por tanto, el "punto + letra mayúscula" es suficiente para definir dónde
   terminan los nombres de los paquetes.
  
   Esta expresión regular usa dos grupos, uno para el paquete y otro 
   para la clase. Los grupos se definen entre paréntesis. Tenga en cuenta que ?: 
   definirá un grupo como "no contribuyente"; es decir, no contribuirá 
   a los valores de retorno del método &lt;tt&gt;grupo &lt;/tt&gt;.
   
   Como puede ver, las expresiones regulares suelen ser crípticas.
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> String fREGEXP =
    <span class="literal">"#Group1 - Prefijo de paquete sin último punto: "</span> + fNEW_LINE +
    <span class="literal">"( (?:\\w|\\.)+ ) \\."</span> + fNEW_LINE +
    <span class="literal">"#Group2 - El nombre de la clase comienza con mayúsculas: "</span> + fNEW_LINE +
    <span class="literal">"( [A-Z](?:\\w)+ )"</span>
  ;
} 
    </pre>
    <br />
    Algunas ejecuciones de ejemplo:
    <p></p>
    <p>
      <code>&gt;java -cp . RegularExpressions "java.java.Thing java.lang.Random"</code>
    </p>
    <p>
      <code>PARTES coincidentes:</code><br />
      <code>Número de grupos: 2</code><br />
      <code>Paquete: java.java</code><br />
      <code>Clase: Thing</code><br />
      <code>Número de grupos: 2</code><br />
      <code>Paquete: java.lang</code><br />
      <code>Clase: Random</code>
    </p>
    <p>
      <code>Coincide TODO:</code><br />
      <code>La entrada no coincide con el patrón.</code>
    </p>
    <p>
      <code>&gt;java -cp . RegularExpressions "java.java.Thing"</code>
    </p>
    <p>
      <code>PARTES coincidentes:</code><br />
      <code>Número de grupos: 2</code><br />
      <code>Paquete: java.java</code><br />
      <code>Clase: Thing</code>
    </p>
    <p>
      <code>Coincide TODO:</code><br />
      <code>Número de grupos: 2</code><br />
      <code>Paquete: java.java</code><br />
      <code>Clase: Thing</code>
    </p>
    <p>
      <code>&gt;java -cp . RegularExpressions "java.java.Thing"</code>
    </p>
    <p>
      <code>PARTES coincidentes:</code><br />
      <code>Número de grupos: 2</code><br />
      <code>Paquete: java.java</code><br />
      <code>Clase: Thing</code>
    </p>
    <p>
      <code>Coincide TODO:</code><br />
      <code>La entrada no coincide con el patrón.</code>
    </p>
    <p></p>
    <p></p>
    <div class="topic-section" id="see-also-title">
      Vea También :
    </div>
    <div id="see-also" class="main-body">
      <a href="../entradasalida/entradasalida_42.html">Leer y escribir ficheros de texto</a> <br /> 
      <a href="../tareascomunes/tareascomunes_103.html">Patrón de líneas de un archivo</a> <br /> 
      <a href="../practicascomunes/practicascomunes_104.html">Compile las expresiones regulares una vez</a> <br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>