<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Implementar tablas de códigos</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Búsqueda" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">Implementar tablas de códigos</div>
    <br />
    La mayoría de las aplicaciones usan <i>tablas de códigos</i>. Una definición razonable de una tabla de códigos podría ser:
    <p>
      <i>
        Una tabla de códigos es una lista de elementos estrechamente relacionados, cada uno de los cuales tiene una subestructura 
        mínima.
      </i>
    </p>
    <p>
      Ejemplos:
    </p>
    <ul>
      <li>una lista de países (u otra categoría geográfica)</li>
      <li>la lista de las tarjetas de crédito aceptadas por un sitio web - Mastercard, Visa, etc.</li>
      <li>el número de elementos mostrados al usuario en un resultado de búsqueda - 10, 50, 100</li>
    </ul>
    <p>
      Las tablas de códigos son a menudo presentados en listas desplegaables:
    </p>
    <p></p>
    <form action="TopicAction.do?Id=239" method="GET">
      <table style="border-spacing: 0px">
        <tbody>
          <tr>
            <td>Número de Resultados:</td>
            <td>
              <select name="NumResults">
                <option selected="selected">10</option>
                <option>50</option>
                <option>100</option>
              </select>
            </td>
          </tr>
          <tr>
            <td>Sabor de Helado:</td>
            <td>
              <select name="Flavor">
                <option value="1" selected="selected">Chocolate</option>
                <option value="2">Fresa</option>
                <option value="3">Vainilla</option>
              </select>
            </td>
          </tr>
        </tbody>
      </table>
    </form>
    <p>
      (Los botones de radio u otros estilos de presentación también pueden ser adecuados, según las necesidades de cada caso).
    </p>
    <p>
      <b>Estructura de la Tabla de Códigos</b><br /> 
      La mayoría de las aplicaciones usan una base de datos relacional. Las tablas de códigos habitulmente representan las clases 
      más simples de tablas que puede modelar en una base de datos. Aquí tiene algún ejemplo de tablas de códigos, como se define 
      por las sentencias SQL <code>CREATE TABLE</code>:
    </p>
    <p>
      Número de elementos que se muestran en un resultado de búsqueda:
    </p>
    <pre>
CREATE TABLE NumResults (  
  Id TINYINT UNSIGNED NOT NULL AUTO_INCREMENT,
  NumItems TINYINT UNSIGNED UNIQUE NOT NULL, 
  PRIMARY KEY (Id)
) TYPE=InnoDB;
    </pre>
    <p>
      Lista de países admitiidos por una aplicación:
    </p>
    <pre>
CREATE TABLE Country (
  Id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT,
  Text VARCHAR(50)UNIQUE NOT NULL,
  ShortText VARCHAR(2)UNIQUE NOT NULL,
  PRIMARY KEY (Id)
) TYPE=InnoDB;
    </pre>
    <p>
      La misma lista de países, pero con un campo agregado para controlar el orden de clasificación:
    </p>
    <pre>
CREATE TABLE Country (
  Id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT,
  OrderWith MEDIUMINT UNIQUE UNSIGNED NOT NULL,
  Text VARCHAR(50)UNIQUE NOT NULL,
  ShortText VARCHAR(2)UNIQUE NOT NULL,
  PRIMARY KEY (Id)
) TYPE=InnoDB;
    </pre>
    <p>
      <span class="highlight">A menudo es útil imaginar cada fila en una tabla de códigos como representando un conjunto de 
        <i>alias</i> para una sola idea.</span> Un alias puede ser más apropiado que otro, según el contexto en el que se utilice. 
      Por ejemplo, en un informe que intenta exprimir la mayor cantidad de información posible en páginas de ancho fijo, las 
      abreviaturas cortas suelen ser útiles. Al presentar una lista desplegable a un usuario final, puede ser más conveniente 
      mostrar una descripción más larga, en lugar de una abreviatura.
    </p>
    <p>
      Por lo tanto, puede decidir representar un elemento en una tabla de códigos utilizando lo que equivale a varios <i>alias</i> 
      para el mismo elemento:
    </p>
    <ul>
      <li>un id numérico</li>
      <li>el texto 'regular', habitualmente visto por el usuario</li>
      <li>una abreviatura corta utilizada cuando sea apropiado</li>
      <li>algún otro alias apropiado para un caso dado</li>
    </ul>
    <p>
      Para que esta idea tenga sentido, cada uno de los campos anteriores necesitarían una restricción <code>UNIQUE</code>, y cada 
      uno debería ser no nulo.
    </p>
    <p>
      <b>Evolución de la Tabla de Códigos</b><br />
      Como se muestra arriba, las tablas de códigos no tienen una estructura definitiva y específica. No estás encerrado en un 
      estilo específico. Una sola aplicación a menudo tiene muchas tablas de códigos, pero esas tablas de códigos no necesariamente 
      comparten exactamente la misma forma. Además, no es raro que una tabla de códigos comience su vida en una forma simple y 
      luego se convierta en algo más elaborado. En este sentido, las tablas de código son más o menos similares a los 
      <a href="http://www.javapractices.com/topic/TopicAction.do?Id=1">tipos de enumeración</a> de Java, que pueden empezar siendo 
      muy sencillo. Dado que las enumeraciones también son clases, puede agregarles más estructura más adelante, si es necesario.
    </p>
    <p>
      <b>Almacenamiento en Caché en Memoria</b><br /> 
      Las tablas de códigos a menudo representan datos relativamente estáticos. Dado que los datos no cambian con mucha frecuencia, 
      por lo general tiene sentido considerar leer todas las tablas de códigos una vez al inicio. Luego, cada vez que se necesita 
      una tabla de códigos, se hace referencia directamente a las representaciones en memoria de las tablas de códigos, en lugar de 
      volver repetidamente a la base de datos. Esto suele mejorar el rendimiento de la aplicación.
    </p>
    <p>
      <b>Uniones en Memoria</b><br /> 
      Si las tablas de códigos se almacenan en caché en la memoria después del inicio, a menudo podrá mover la lógica implementada 
      anteriormente por una operación de base de datos <code>JOIN</code> a operaciones en memoria en Java. (Esta es una excepción a 
      la regla de 
      <a href="http://www.javapractices.com/topic/TopicAction.do?Id=106">no realizar tareas de base de datos en código</a>). Hay dos
      ventajas de esto:
    </p>
    <ul>
      <li>probablemente mejorará el rendimiento.</li>
      <li>sus declaraciones SQL serán más simples, ya que los <code>JOIN</code>s pueden omitirse</li>
    </ul>
    Por ejemplo, considere una aplicación que modela un deporte de equipo, en la que a cada jugador de un equipo se le asigna una 
    <i>posición</i> específica de algún tipo (lanzador, lanzador, zaguero o lo que sea). En este caso, la tabla Equipo tiene una 
    clave externa en la tabla de códigos de posición. Para recuperar la lista de jugadores de un equipo, es posible que tenga una 
    unión explícita a la tabla de códigos de posición, como en:
    <pre>
SELECT 
 Name, Number, PositionName
FROM 
 Team JOIN Position ON PositionFK = Position.Id
WHERE
 Team.Id = ?
    </pre>
    Alternativamente, el JOIN podría descartarse a favor de devolver el identificador PositionFK 'sin procesar', en lugar del texto 
    PositionName, como en:
    <pre>
SELECT 
 Name, Number, PositionFK
FROM 
 Team
WHERE 
 Team.Id = ?</pre>
    <p>
      Por supuesto, el identificador de PositionFK debería traducirse a texto (en Javalandia) antes de presentar el resultado al 
      usuario.
    </p>
    <p>
      <b>Id Para el Código, Texto Para el Usuario</b><br /> 
      El hecho de que un elemento de la tabla de códigos es esencialmente una colección de aliases para una sola idea se puede 
      utilizar de la siguiente manera.
      The fact that a code table item is essentially a collection of aliases for a single
      idea can be put to use in the following way. En Javalandia, es mejor identificar elementos usando códigos estáticos, internos,
      en lugar del texto visible al usuario. Los formularios en las aplicaciones web son un buen ejemplo de esto:
    </p>
    <pre>
&lt;select name="Flavor"&gt;
  &lt;option value='1'&gt;Chocolate&lt;/option&gt;
  &lt;option value='2'&gt;Strawberry&lt;/option&gt;
  &lt;option value='3'&gt;Vanilla&lt;/option&gt;
&lt;/select&gt;
    </pre>
    Aquí, el texto ('Chocolate') se muestra al usuario en un menú desplegable, pero el valor enviado al servidor es en realidad una 
    identificación numérica ('1'), controlada por el <code>valor</code> atributo de la etiqueta <code>option</code>. Esto separa 
    dos cosas muy bien. El texto puede cambiar por muchas razones (cambiar la ortografía, agregar traducciones a otro idioma), pero 
    tales cambios no afectarán a Java, ya que en Javalandia se usan códigos numéricos, no el texto. (Algunos se oponen a exponer 
    las claves primarias de la base de datos al usuario final de esta manera. Pero en este caso, no parece hacer ningún daño).
    <p>
      <b>Ordenación</b><br /> 
      La clasificación de tablas de códigos puede ser complicada. Si el orden es alfabético, entonces es fácil de implementar. Sin 
      embargo, los tipos no siempre son alfabéticos. A veces dependen de reglas arbitrarias. Por ejemplo, si una aplicación se usa 
      solo en Australia, es posible que se requiera una lista de países que tienen Australia y Nueva Zelanda al principio. En tales 
      casos, una opción es definir una columna en la tabla de códigos subyacente que defina explícitamente el orden de 
      clasificación.
    </p>
    <p>
      El orden de clasificación también puede verse afectado por si una aplicación es multilingüe. Si una tabla de códigos está 
      ordenada alfabéticamente en cada idioma, entonces el orden de presentación al usuario generalmente no será el mismo en todos 
      los idiomas.
    </p>
    <p>
      <b>Tablas de códigos Monstruosas</b><br /> 
      Algunas aplicaciones colocan todas sus tablas de códigos en una única tabla de códigos "monstruo". La tabla de códigos 
      monstruo tiene dos claves primarias - una para identificar la tabla de códigos, y una para identificar el valor <i>dentro</i> 
      de la tabla de códigos. Este parece ser un diseño inferior:
    </p>
    <ul>
      <li>
        agrupa elementos que no están relacionados lógicamente entre sí. Casi siempre es un error 
        <i>anteponer los detalles de implementación al significado </i>. Eso es mala señal.
      </li>
      <li>
        las claves externas para las tablas de códigos ya no son posibles. Dado que las claves externas son el corazón y el alma de 
        una base de datos relacional, este es un gran inconveniente.
      </li>
      <li>
        dado que algunas claves externas están ausentes, la claridad de la estructura de una base de datos (y las declaraciones SQL 
        relacionadas) se reduce significativamente.
      </li>
      <li>
        cuando una sola tabla de códigos tiene necesidades especiales, por lo general no puede encajar en la estructura de la tabla 
        de códigos monstruosa.
      </li>
      <li>
        Las tablas de códigos no pueden evolucionar de forma independiente y aún permanecen en la tabla de códigos monstruosa.
      </li>
      <li>
        Las UNIONES a las tablas de códigos monstruosas generalmente se duplican. Lo que solía ser una combinación única se 
        convierte en 2 combinaciones: una combinación para definir la tabla de códigos y otra para definir el valor 
        <i>dentro</i> de la tabla de códigos.
      </li>
      <li>
        en sentencias SQL grandes, la gran cantidad de combinaciones puede volverse rápidamente molesta.
      </li>
    </ul>
    <br />
    <p></p>
    <div class="topic-section" id="see-also-title">
      Vea También :
    </div>
    <div id="see-also" class="main-body">
      <a href="..\bbdd\bbdd_106.html">No ejecute tareas básicas de SQL mediante código</a> <br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>