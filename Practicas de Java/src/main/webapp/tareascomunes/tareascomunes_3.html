<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Copiar una matriz</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Search" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">Copiar una matriz</div>
    <br />
    Hay varias formas de copiar una matriz:
    <ul>
      <li>
        use los diversos métodos <code>copyOf</code> y <code>copyOfRange</code> de la clase 
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/util/Arrays.html">Arrays</a></code> - probablmente el método 
        más simple 
      </li>
      <li>
        use <code>
          System.<a href="https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#arraycopy(java.lang.Object,int,java.lang.Object,int,int)">arraycopy</a></code> - útil cuando se copian partes de una matriz 
      </li>
      <li>
        llamar a su método <code>clone</code>, y hacer una conversión de tipo - el estilo más simple, pero solo se realiza un clon 
        superficial
      </li>
      <li>use un bucle <code>for</code> - más de una línea, y necesita un índice de bucle</li>
    </ul>
    <b>Ejemplo</b>
    <p>
      Esta clase de ejemplo demuestra:
    </p>
    <ul>
      <li>
        el rendimiento relativo de los diversos métodos (en muchos casos las diferencias en velocidad no serán de beneficio 
        práctico).
      </li>
      <li>
        cómo <code>clone</code> es una copia superficial y conduce a un almacenamiento independiente solo para matrices 
        unidimensionales primitivas.
      </li>
    </ul>
    <br />
    <pre>
<span class="keyword">import</span> java.util.*;

<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> ArrayCopier {

  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> main (String... aArguments) {
    String action = aArguments[<span class="literal">0</span>];
    <span class="keyword">int</span> numIterations = <span
            class="literal">0</span>;
    <span class="keyword">if</span> (aArguments.length == <span
            class="literal">2</span>) {
      numIterations = Integer.parseInt(aArguments[<span class="literal">1</span>]);
    }

    <span class="keyword">if</span> (<span class="literal">"performance"</span>.equals(action)) {
      demoPerformance(numIterations);
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (<span
            class="literal">"storage"</span>.equals(action)) {
      demoIndependanceOfStorage();
    }
  }

  <span class="comment">/**
  * Muestra el tiempo que se tarda en copiar una matriz de varias formas.
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> demoPerformance(<span
            class="keyword">int</span> aNumIterations){
    Stopwatch stopwatch = <span class="keyword">new</span> Stopwatch();
    <span class="keyword">int</span>[] numbers = {<span class="literal">1</span>,<span
            class="literal">2</span>,<span class="literal">3</span>,<span
            class="literal">4</span>,<span class="literal">5</span>,<span
            class="literal">6</span>,<span class="literal">7</span>,<span
            class="literal">8</span>,<span class="literal">9</span>,<span
            class="literal">10</span>};

    stopwatch.start();
    copyUsingClone(numbers, aNumIterations);
    stopwatch.stop();
    log(<span class="literal">"Usando clone: "</span> + stopwatch);

    stopwatch.start();
    copyUsingArraycopy(numbers, aNumIterations);
    stopwatch.stop();
    log(<span class="literal">"Usando System.arraycopy: "</span> + stopwatch);

    stopwatch.start();
    copyUsingArraysCopyOf(numbers, aNumIterations);
    stopwatch.stop();
    log(<span class="literal">"Usando Arrays.copyOf: "</span> + stopwatch);

    stopwatch.start();
    copyUsingForLoop(numbers, aNumIterations);
    stopwatch.stop();
    log(<span class="literal">"Usando bucle for: "</span> + stopwatch);
  }

  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> copyUsingClone(<span
            class="keyword">int</span>[] aArray , <span class="keyword">int</span> aNumIterations) {
    <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span
            class="literal">0</span> ; idx &lt; aNumIterations; ++idx) {

      <span class="keyword">int</span>[] copy = (<span class="keyword">int</span>[])aArray.clone();

    }
  }

  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> copyUsingArraycopy(<span
            class="keyword">int</span>[] aArray , <span class="keyword">int</span> aNumIterations) {
    <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span
            class="literal">0</span> ; idx &lt; aNumIterations; ++idx) {

      <span class="keyword">int</span> [] copy = <span class="keyword">new</span> <span
            class="keyword">int</span>[aArray.length];
      System.arraycopy( aArray, <span class="literal">0</span>, copy, <span
            class="literal">0</span>, aArray.length );

    }
  }

  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> copyUsingArraysCopyOf( <span
            class="keyword">int</span>[] aArray , <span class="keyword">int</span> aNumIterations) {
    <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span
            class="literal">0</span> ; idx &lt; aNumIterations; ++idx) {

      <span class="keyword">int</span>[] copy = Arrays.copyOf(aArray, aArray.length);

    }
  }


  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> copyUsingForLoop( <span
            class="keyword">int</span>[] aArray , <span class="keyword">int</span> aNumIterations) {
    <span class="keyword">for</span>(<span class="keyword">int</span> iterIdx = <span
            class="literal">0</span> ; iterIdx &lt; aNumIterations; ++iterIdx) {

      <span class="keyword">int</span> [] copy = <span class="keyword">new</span> <span
            class="keyword">int</span>[aArray.length];
      <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span
            class="literal">0</span>; idx &lt; aArray.length; ++idx) {
        copy[idx] = aArray[idx];
      }

    }
  }

  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> log(String aMessage){
    System.out.println(aMessage);  
  }
  
  <span class="comment">/**
  * (Los estilos del bucle for y System.arraycopy claramente tienen almacenamiento 
  * independiente, y no se ejercitan en este método).
  */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> demoIndependanceOfStorage() {
    <span class="comment">//un clon de una matriz unidimensional tiene almacenamiento independiente
</span>    <span class="keyword">int</span>[] numbers = {<span class="literal">1</span>,<span
            class="literal">1</span>,<span class="literal">1</span>,<span
            class="literal">1</span>};
    <span class="keyword">int</span>[] numbersClone = (<span
            class="keyword">int</span>[])numbers.clone();
    <span class="comment">//se establece el elemento numero 0 a 0, y se compara
</span>    numbersClone[<span class="literal">0</span>] = <span class="literal">0</span>;
    log(<span class="literal">"El clon alterado NO ha afectado al original:"</span>);
    log(<span class="literal">"numbersClone[0]: "</span> + numbersClone[<span
            class="literal">0</span>]);
    log(<span class="literal">"numbers[0]: "</span> +  numbers[<span
            class="literal">0</span>]);

    <span class="comment">//el clon de una matriz multidimensional *no* tiene
</span>    <span class="comment">//almacenamiento independiente
</span>    <span class="keyword">int</span>[][] matrix = { {<span
            class="literal">1</span>,<span class="literal">1</span>}, {<span
            class="literal">1</span>,<span class="literal">1</span>} };
    <span class="keyword">int</span>[][] matrixClone = (<span
            class="keyword">int</span>[][])matrix.clone();
    <span class="comment">//se establece el elemento 0,0 a 0, y se compara
</span>    matrixClone[<span class="literal">0</span>][<span class="literal">0</span>] = <span
            class="literal">0</span>;
    log(<span class="literal">"El clon alterado ha afectado al original:"</span>);
    log(<span class="literal">"elemento 0-0 de matrixClone:"</span> + matrixClone[<span
            class="literal">0</span>][<span class="literal">0</span>]);
    log(<span class="literal">"elememnto de matriz 0-0: "</span> + matrix[<span
            class="literal">0</span>][<span class="literal">0</span>]);

    <span class="comment">//el clon de una matriz de objetos también es solo superficial
</span>    Date[] dates = {<span class="keyword">new</span> Date()};
    log(<span class="literal">"Fecha original : "</span> + dates[<span
            class="literal">0</span>]);
    Date[] datesClone = (Date[])dates.clone();
    datesClone[<span class="literal">0</span>].setTime(<span
            class="literal">0</span>);
    log(<span class="literal">"El clon alterado ha afectado al original:"</span>);
    log(<span class="literal">"datesClone[0]:"</span> + datesClone[<span
            class="literal">0</span>]);
    log(<span class="literal">"dates[0]: "</span> + dates[<span
            class="literal">0</span>]);
  }
} 
    </pre>
    <br />
    <code>System.arraycopy</code> parece tener un rendimiento ligeramente mejor. Sin embargo, las diferencias entre los distintos 
    estilos son pequeñas y, a menudo, se considerarían como una microoptimización. (Como es habitual, tales juicios dependen del 
    contexto).
    <p>
      <code>&gt;java -cp . -Xint ArrayCopier performance 250000</code>
    </p>
    <pre>
Usando clone: 108.168 ms
Usando System.arraycopy: 125.334 ms
Usando Arrays.copyOf: 190.490 ms
Usando bucle for: 392.026 ms
    </pre>
    <p>
      El ejemplo anterior usa la opción 
      <code>
        <a
          href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html#nonstandard"
          title="Non-standard options for java interpreter">-Xint</a>
      </code> para desactivar el compilador Just In Time. Aquí, los códigos de bytes se interpretan en tiempo de ejecución, pero el 
      compilador HotSpot nunca los compila en código nativo. Esto proporciona un entorno uniforme para ejecutar pruebas de tiempo de 
      ejecución relativo, ya que no hay un período de "calentamiento".
    </p>
    <p>
      Ejecución de ejemplo que demuestra la independencia de almacenamiento o la falta de ella:
    </p>
    <p>
      <code>&gt;java -cp . ArrayCopier storage</code><br />
      <code>El clon alterado NO ha afectado al original:</code><br />
      <code>numbersClone[0]: 0</code><br />
      <code>numbers[0]: 1</code><br />
      <code>El clon alterado ha afectado al original:</code><br />
      <code>elemento 0-0 matrixClone:0</code><br />
      <code>elemento 0-0 matriz: 0</code><br />
      <code>Fecha original: Mon Sep 30 15:47:58 EDT 2002</code><br />
      <code>El clon alterado ha afectado al original:</code><br />
      <code>datesClone[0]:Wed Dec 31 19:00:00 EST 1969</code><br />
      <code>dates[0]: Wed Dec 31 19:00:00 EST 1969</code><br />
    </p>
    <p></p>
    <div class="topic-section" id="see-also-title">
      Vea También :
    </div>
    <div id="see-also" class="main-body">
      <a href="..\tareascomunes\tareascomunes_85.html">Velocidad de tiempo de ejecución</a> <br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>