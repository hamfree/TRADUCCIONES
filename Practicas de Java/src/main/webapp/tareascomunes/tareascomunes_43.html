<!DOCTYPE html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Recuperando recursos</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input name="q" size="15" maxlength="255" placeholder="" type="text" />
        <input name="btnG" value="Search" type="submit" /> 
        <input name="sitesearch" value="www.javapractices.com" type="hidden" />
      </form>
    </nav>
    <div class="page-title">Recuperando recursos</div>
    <br />
    Los recursos costosos deben reclamarse lo antes posible, mediante una llamada explícita a un método de limpieza definido para 
    este propósito. Si no se hace esto, el rendimiento del sistema puede degradarse. En el peor de los casos, el sistema puede 
    incluso fallar por completo.
    <p>
      Los recursos incluyen:
    </p>
    <ul>
      <li>flujos de entrada-salida</li>
      <li>conjuntos de resultados de bases de datos, sentencias, y conexiones</li>
      <li>subprocesos</li>
      <li>recursos gráficos</li>
      <li>sockets</li>
    </ul>
    Los recursos que se han creado localmente dentro de un método deben limpiarse dentro del mismo método, llamando a un método 
    apropiado para el recurso en sí, como <code>close</code> o <code>dispose</code>. (El nombre exacto de este método es 
    arbitrario, pero es habitualmente tienen esos convencionales nombres). Esto se hace habitualmente automáticamente, usando la 
    característica 
    <a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">try-with-resources</a>, agregado en 
    el KDJ 7.
    <p>
      Si try-with-resources no está disponible, entonces necesita limpiar los recursos explícitamente, llamando a un método de 
      limpieza en una cláusula <code>finally</code>.
    </p>
    <p>
      Para el caso de un recurso que es un <i>campo</i>, sin embargo, hay más trabajo que hacer:
    </p>
    <ul>
      <li>
        implementar un método de limpieza que el usuario debe llamar cuando termine con el objeto, con un nombre tal como 
        <code>close</code> o <code>dispose</code>
      </li>
      <li>el llamador debe ser capaz de preguntar a un objeto para ver si su método de limpieza ha sido ejecutado</li>
      <li>
        los métodos no <code>private</code> (distintos del propio método de limpieza) deberían lanzar una 
        <code>IllegalStateException</code> si el método de limpieza ha sido ya invocado
      </li>
      <li>
        como red de seguridad, implemente <code>finalize</code> para llamar también al método de limpieza; Si el usuario de la clase 
        no llama al método de limpieza, esto puede permitir la recuperación del recurso por parte del sistema.
      </li>
      <li><a href="../objetos/objects_24.html">nunca confíe</a> únicamenete en <code>finalize</code></li>
    </ul>
    Este ejemplo muestra una clase que retiene una conexión a una base de datos durante su vida. (Este ejemplo es artificial. En 
    realidada escribir dicha clase no debería ser necesario en la práctica, ya que las agrupaciones de conexión ya realizan dicha 
    limpieza en segundo plano. Se usa meramente para demostrar las ideas mencionadas arriba).
    <br />
    <pre>
<span class="keyword">import</span> java.sql.*;
<span class="keyword">import</span> java.text.*;
<span class="keyword">import</span> java.util.*;

<span class="comment">/**
* Esta clase tiene un ciclo de vida obligatorio: después de llamar a 
* destruir, no se puede llamar a ningún método útil en este objeto
* sin lanzar una IllegalStateException.
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> DbConnection {

  <span class="keyword">public</span> DbConnection () {
    <span class="comment">//construir una conexión y asignarla a un campo
</span>    <span class="comment">//omitido... fConnection = ConnectionPool.getInstance().getConnection();
</span>  }

  <span class="comment">/**
  * Asegura que los recursos de este objeto son limpiado de una manera ordenada.
  *
  * El usuario de esta clase debe llamar a destroy cuando termine con 
  * el objeto. Llamar a destroy una segunda vez se permite, pero es 
  * una no operación.
  */</span>
  <span class="keyword">public</span> <span class="keyword">void</span> destroy() <span
            class="keyword">throws</span> SQLException {
    <span class="keyword">if</span> (fIsDestroyed) {
       <span class="keyword">return</span>;
    }
    <span class="keyword">else</span>{
      <span class="keyword">if</span> (fConnection != <span
            class="keyword">null</span>) fConnection.close();
      fConnection = <span class="keyword">null</span>;
      <span class="comment">//marca que se ha llamado a destroy, y que 
</span>      <span class="comment">//ninguna llamada posterior en este objeto es válida
</span>      fIsDestroyed = <span class="keyword">true</span>;
    }
  }

  <span class="comment">/**
  * Obtiene algo de la base de datos.
  *
  * Esto es un ejemplo de un método no privado que debe asegurar que 
  * &lt;code&gt;destroy&lt;/code&gt; no ha sido ya llamado 
  * antes de proceder con la ejecución.
  */</span>
  <span class="keyword">synchronized</span> <span class="keyword">public</span> Object fetchBlah(String aId) <span
            class="keyword">throws</span> SQLException {
    validatePlaceInLifeCycle();
    <span class="comment">//...omitido
</span>    <span class="keyword">return</span> <span class="keyword">null</span>;
  }

  <span class="comment">/**
  * Si el usuario falla en llamar a &lt;code&gt;destroy&lt;/code&gt;, entonces implementa 
  * finalize actuará como una red de seguridad, pero esto no es infalible.
  */</span>
  <span class="keyword">protected</span> <span class="keyword">void</span> finalize() <span
            class="keyword">throws</span> Throwable{
    <span class="keyword">try</span>{
      destroy();
    }
    <span class="keyword">finally</span>{
      <span class="keyword">super</span>.finalize();
    }
  }

  <span class="comment">/**
  * Permite al usuario a determinar si &lt;code&gt;destroy&lt;/code&gt; ha sido llamado.
  */</span>
  <span class="keyword">public</span> <span class="keyword">boolean</span> isDestoyed() {
    <span class="keyword">return</span> fIsDestroyed;
  }

  <span class="comment">// PRIVADO
</span>
  <span class="comment">/**
  * La conexión que se construyó y gestionó por este objeto.
  * El usuario de esta clase debe llamar a destroy en orden a liberar este
  * recurso de Connection.
  */</span>
  <span class="keyword">private</span> Connection fConnection;

  <span class="comment">/**
  * Este objeto tiene un "ciclo de vida" específico, por lo que los métodos deben llamarse
  * en el orden: otros + destroy. fIs Destroyed realiza un seguimiento del ciclo de vida,
  * y los métodos no privados deben comprobar este valor al inicio de la ejecución.
  * Si se llama a destruir más de una vez, no se realiza ninguna operación.
  */</span>
  <span class="keyword">private</span> <span class="keyword">boolean</span> fIsDestroyed;

  <span class="comment">/**
  * Una vez ha sido llamado &lt;code&gt;destroy&lt;/code&gt;, los servicios de esta clase 
  * ya no están disponibles.
  *
  * @throws IllegalStateException si &lt;code&gt;destroy&lt;/code&gt; ha
  * sido ya llamada.
  */</span>
  <span class="keyword">private</span> <span class="keyword">void</span> validatePlaceInLifeCycle(){
    <span class="keyword">if</span> (fIsDestroyed) {
      String message = <span class="literal">"No se puede llamar al método después de que se haya llamado a destroy."</span>;
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(message);
    }
  }
} 
    </pre>
    <br />
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="../entradasalida/entradasalida_8.html">Cierre siempre los flujos</a><br />
      <a href="../objetos/objects_24.html">Nunca confíe en finalize</a><br /> 
      <a href="../excepciones/excepciones_25.html">Finally y catch</a><br /> 
      <a href="../bbdd/bbdd_127.html">Obtener la conexión a la base de datos</a><br /> 
      <a href="../hilos/hilos_250.html">Siempre cierre un ExecutorService</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>