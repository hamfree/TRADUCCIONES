<!doctype html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Cierre siempre los flujos</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css?3.001" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Search" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Cierre siempre los flujos</div>
    <br />
    When you use the
    <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/language/try-with-resources.html">try-with-resources</a> 
    statement correctly, then you will never have to close streams explicitly. (Indeed, that's the reason try-with-resources was 
    added in the first place.)
    <p>
      However, you may see still see code that either doesn't use a modern JDK, or fails to take advantage of try-with-resources.
    </p>
    <p>
      <b>JDK &lt; 7</b>
    </p>
    <p>
      Streams represent resources which you must always clean up explicitly, by calling the <code>close</code> method.
    </p>
    <p>
      Some <code>java.io</code> classes (apparently just the output classes) include a <code>flush</code> method. When a 
      <code>close</code> method is called on a such a class, it automatically performs a <code>flush</code>. There is no need to 
      explicitly call <code>flush</code> before calling <code>close</code>.
    </p>
    <p>
      One stream can be chained to another by passing it to the constructor of some second stream. When this second stream is 
      closed, then it automatically closes the original underlying stream as well.
    </p>
    <p>
      If multiple streams are chained together, then closing the one which was the last to be constructed, and is thus at the 
      highest level of abstraction, will automatically close all the underlying streams. So, one only has to call <code>close</code>
      on one stream in order to close (and flush, if applicable) an entire series of related streams.
    </p>
    <p>
      <b>Example</b> <br />
    </p>
    <pre>
<span class="keyword">import</span> java.io.*;
<span class="keyword">import</span> java.util.*;
<span class="keyword">import</span> java.util.logging.*;

<span class="comment">/** JDK before version 7. */</span>
<span class="keyword">public</span> <span class="keyword">class</span> ExerciseSerializable {

  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> main(String... aArguments) {
    <span class="comment">//create a Serializable List
</span>    List&lt;String&gt; quarks = Arrays.asList(
      <span class="literal">"up"</span>, <span class="literal">"down"</span>, <span
            class="literal">"strange"</span>, <span class="literal">"charm"</span>, <span
            class="literal">"top"</span>, <span class="literal">"bottom"</span>
    );

    <span class="comment">//serialize the List
</span>    <span class="comment">//note the use of abstract base class references
</span>
    <span class="keyword">try</span>{
      <span class="comment">//use buffering
</span>      OutputStream file = <span class="keyword">new</span> FileOutputStream(<span
            class="literal">"quarks.ser"</span>);
      OutputStream buffer = <span class="keyword">new</span> BufferedOutputStream(file);
      ObjectOutput output = <span class="keyword">new</span> ObjectOutputStream(buffer);
      <span class="keyword">try</span>{
        output.writeObject(quarks);
      }
      <span class="keyword">finally</span>{
        output.close();
      }
    }  
    <span class="keyword">catch</span>(IOException ex){
      fLogger.log(Level.SEVERE, <span class="literal">"Cannot perform output."</span>, ex);
    }

    <span class="comment">//deserialize the quarks.ser file
</span>    <span class="comment">//note the use of abstract base class references
</span>    
    <span class="keyword">try</span>{
      <span class="comment">//use buffering
</span>      InputStream file = <span class="keyword">new</span> FileInputStream(<span
            class="literal">"quarks.ser"</span>);
      InputStream buffer = <span class="keyword">new</span> BufferedInputStream(file);
      ObjectInput input = <span class="keyword">new</span> ObjectInputStream (buffer);
      <span class="keyword">try</span>{
        <span class="comment">//deserialize the List
</span>        List&lt;String&gt; recoveredQuarks = (List&lt;String&gt;)input.readObject();
        <span class="comment">//display its data
</span>        <span class="keyword">for</span>(String quark: recoveredQuarks){
          System.out.println(<span class="literal">"Recovered Quark: "</span> + quark);
        }
      }
      <span class="keyword">finally</span>{
        input.close();
      }
    }
    <span class="keyword">catch</span>(ClassNotFoundException ex){
      fLogger.log(Level.SEVERE, <span class="literal">"Cannot perform input. Class not found."</span>, ex);
    }
    <span class="keyword">catch</span>(IOException ex){
      fLogger.log(Level.SEVERE, <span class="literal">"Cannot perform input."</span>, ex);
    }
  }

  <span class="comment">// PRIVATE 
</span>
  <span class="comment">//Use Java's logging facilities to record exceptions.
</span>  <span class="comment">//The behavior of the logger can be configured through a
</span>  <span class="comment">//text file, or programmatically through the logging API.
</span>  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> Logger fLogger =
    Logger.getLogger(ExerciseSerializable.<span class="keyword">class</span>.getPackage().getName())
  ;
} 
    </pre>
    <br />
    <p></p>
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\excepciones\excepciones_25.html">Finally y catch</a><br /> 
      <a href="..\entradasalida\entradasalida_42.html">Leer y escribir ficheros de texto</a><br />
      <a href="..\tareascomunes\tareascomunes_43.html">Recuperando recursos</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>
