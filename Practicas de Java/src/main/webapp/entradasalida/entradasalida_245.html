<!doctype html>
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Prácticas y técnicas de programación en Java.">
    <meta name="keywords" content="java, programación java, Prácticas de Java, idioma java, estilo java, patrones de diseño java, 
          convenciones de codigo java">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prácticas de Java-&gt;Leer y escribir ficheros binarios</title>
    <link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet9.css?3.001" media="all">
    <link rel="icon" type="image/png" href="../img/favicon.png">
    <style>
      TD {
        border: 1px inset;
      }
    </style>
  </head>
  <body>
    <nav class="menu-bar" id="menu-bar">
      <a href="../index.html" title="Tabla de Contenido" style="float: left;">Inicio</a> &nbsp;&nbsp;
      <form method="GET" action="https://www.google.com/search" class="search-form" style="float: right;">
        <input type="text" name="q" size="15" maxlength="255" value="" placeholder=""/> 
        <input type="submit" name="btnG" value="Búsqueda" /> 
        <input type="hidden" name="sitesearch" value="www.javapractices.com" />
      </form>
    </nav>
    <div class="page-title">Leer y escribir ficheros binarios</div>
    <br />
    En el KDJ 7, las clases más importantes para ficheros binarios son:
    <ul>
      <li>
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/nio/file/Paths.html">Paths</a></code> y
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/nio/file/Path.html">Path</a></code> - ubicaciones / nombres 
        de archivos, pero no su contenido.
      </li>
      <li>
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/nio/file/Files.html">Files</a></code> - operaciones sobre el 
        contenido del fichero.
      </li>
      <li>
        El método <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/File.html#toPath()">File.toPath</a></code>, que 
        permite al código más viejo interactuar fácilmente con la IPA java.nio más nueva.
      </li>
    </ul>
    <p>
      Además, las clases siguientes también se usan comunmente con ficheros binarios, tanto para el KDJ 7 como para versiones 
      anteriores:
    </p>
    <table style="border-spacing: 1px;border-collapse: separate;">
      <tbody>
        <tr>
          <th>Entrada</th>
          <th>Salida</th>
        </tr>
        <tr>
          <td>
            <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/FileInputStream.html">FileInputStream</a></code>
          </td>
          <td>
            <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/FileOutputStream.html">FileOutputStream</a></code>
          </td>
        </tr>
        <tr>
          <td>
            <code>
              <a href="https://docs.oracle.com/javase/10/docs/api/java/io/BufferedInputStream.html">BufferedInputStream</a>
            </code>
          </td>
          <td>
            <code>
              <a href="https://docs.oracle.com/javase/10/docs/api/java/io/BufferedOutputStream.html">BufferedOutputStream</a>
            </code>
          </td>
        </tr>
        <tr>
          <td>
            <code>
              <a href="https://docs.oracle.com/javase/10/docs/api/java/io/ByteArrayInputStream.html">ByteArrayInputStream</a>
            </code>
          </td>
          <td>
            <code>
              <a href="https://docs.oracle.com/javase/10/docs/api/java/io/ByteArrayOutputStream.html">ByteArrayOutputStream</a>
            </code>
          </td>
        </tr>
        <tr>
          <td>
            <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/DataInput.html">DataInput</a></code>
          </td>
          <td>
            <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/DataOutput.html">DataOutput</a></code>
          </td>
        </tr>
      </tbody>
    </table>
    <p>
      Cuando lee y escribe ficheros binarios:
    </p>
    <ul>
      <li>es casi siempre una buena idea usar almacenamiento en búfer (el tamaño del búfer predeterminado es de 8K)</li>
      <li>es a menudo posible usar referencias a clases base abstractas, en vez de referencias a clases específicas concretas</li>
      <li>
        hay siempre una necesidad de prestar atención a las excepciones (en particular,
        <code><a href="https://docs.oracle.com/javase/10/docs/api/java/io/IOException.html">IOException</a></code> y
        <code>
          <a href="https://docs.oracle.com/javase/10/docs/api/java/io/FileNotFoundException.html">FileNotFoundException</a></code>)
      </li>
    </ul>
    <p>
      <b>Ejemplo - Pequeños Ficheros</b> <br />
    </p>
    <pre>
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.nio.file.Files;
<span class="keyword">import</span> java.nio.file.Path;
<span class="keyword">import</span> java.nio.file.Paths;

<span class="comment">/** KDJ 7+. */</span>
<span class="keyword">public</span> <span class="keyword">class</span> SmallBinaryFiles {
  
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> main(String... aArgs) <span
            class="keyword">throws</span> IOException{
    SmallBinaryFiles binary = <span class="keyword">new</span> SmallBinaryFiles();
    <span class="keyword">byte</span>[] bytes = binary.readSmallBinaryFile(FILE_NAME);
    log(<span class="literal">"Pequeño - tamaño del archivo leido:"</span> + bytes.length);
    binary.writeSmallBinaryFile(bytes, OUTPUT_FILE_NAME);
  }

  <span class="keyword">final</span> <span class="keyword">static</span> String FILE_NAME = <span
            class="literal">"C:\\Temp\\cottage.jpg"</span>;
  <span class="keyword">final</span> <span class="keyword">static</span> String OUTPUT_FILE_NAME = <span
            class="literal">"C:\\Temp\\cottage_output.jpg"</span>;
  
  <span class="keyword">byte</span>[] readSmallBinaryFile(String aFileName) <span
            class="keyword">throws</span> IOException {
    Path path = Paths.get(aFileName);
    <span class="keyword">return</span> Files.readAllBytes(path);
  }
  
  <span class="keyword">void</span> writeSmallBinaryFile(<span
            class="keyword">byte</span>[] aBytes, String aFileName) <span
            class="keyword">throws</span> IOException {
    Path path = Paths.get(aFileName);
    Files.write(path, aBytes); <span class="comment">//crea, sobreescribe
</span>  }
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> log(Object aMsg){
    System.out.println(String.valueOf(aMsg));
  }
  
}  
    </pre>
    <p></p>
    <p>
      Si try-with-resources del KDJ 7 no está disponible, entonces, necesita tener cuidado con el método <code>close</code>:
    </p>
    <ul>
      <li>Por lo general, es necesario llamarlo o, de lo contrario, se filtrarán recursos.</li>
      <li>
        Para flujos que no usan el disco o la red, tales como los flujos <code>ByteArrayXXX</code>, la operación <code>close</code> 
        es una no-operación. En estos casos, no necesita llamar a <code>close</code>.
      </li>
      <li>El método <code>close</code> automáticamente limpiará el flujo, si es necesario.</li>
      <li>Llamar a <code>close</code> en un flujo "envoltura" automáticamente llamará a <code>close</code> en su flujo subyacente.</li>
      <li>Cerrar un flujo por segunda vez es una no-operación.</li>
    </ul>
    <p>
      <b>Ejemplo - JDK &lt; 7</b>
    </p>
    <p>
      Este ejemplo lee y escribe datos binarios, moviéndolos del disco a la memoria, y de vuelta de nuevo.<br />
    </p>
    <pre>
<span class="keyword">import</span> java.io.BufferedInputStream;
<span class="keyword">import</span> java.io.BufferedOutputStream;
<span class="keyword">import</span> java.io.ByteArrayOutputStream;
<span class="keyword">import</span> java.io.File;
<span class="keyword">import</span> java.io.FileInputStream;
<span class="keyword">import</span> java.io.FileNotFoundException;
<span class="keyword">import</span> java.io.FileOutputStream;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.io.InputStream;
<span class="keyword">import</span> java.io.OutputStream;

<span class="comment">/**  
  Convierte datos binarios en formas diferentes.
 
 
 &lt;P&gt;Lee datos binarios en memoria, y los vuelve a escribir 
 (si está en realidad copiando un fichero, hay mejores formas de hacer esto).
 
 &lt;P&gt;El almacenamiento en búfer se usa cuando lee y escribe ficheros, para minimiza el número
 de interacciones con el disco.
*/</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span
            class="keyword">class</span> BytesStreamsAndFiles {

  <span class="comment">/** Cambie estos ajustes antes de ejecutar esta clase. */</span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> String INPUT_FILE_NAME = <span
            class="literal">"C:\\TEMP\\cottage.jpg"</span>;
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">final</span> String OUTPUT_FILE_NAME = <span
            class="literal">"C:\\TEMP\\cottage_copy.jpg"</span>;

  <span class="comment">/** Ejecuta el ejemplo. */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span
            class="keyword">void</span> main(String... aArgs) {
    BytesStreamsAndFiles test = <span class="keyword">new</span> BytesStreamsAndFiles();
    <span class="comment">//lee los bytes
</span>    <span class="keyword">byte</span>[] fileContents = test.read(INPUT_FILE_NAME);
    <span class="comment">//test.readAlternateImpl(INPUT_FILE_NAME);
</span>    <span class="comment">//escríbelo de nuevo en un nombre de archivo diferente
</span>    test.write(fileContents, OUTPUT_FILE_NAME);
  }
  
  <span class="comment">/** Lee el fichero binario dado, y devuelve sus contenidos como una matriz de bytes.*/</span> 
  <span class="keyword">byte</span>[] read(String aInputFileName){
    log(<span class="literal">"Leyendo el fichero binario llamado : "</span> + aInputFileName);
    File file = <span class="keyword">new</span> File(aInputFileName);
    log(<span class="literal">"Tamaño del fichero: "</span> + file.length());
    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span
            class="keyword">byte</span>[(<span class="keyword">int</span>)file.length()];
    <span class="keyword">try</span> {
      InputStream input = <span class="keyword">null</span>;
      <span class="keyword">try</span> {
        <span class="keyword">int</span> totalBytesRead = <span
            class="literal">0</span>;
        input = <span class="keyword">new</span> BufferedInputStream(<span
            class="keyword">new</span> FileInputStream(file));
        <span class="keyword">while</span>(totalBytesRead &lt; result.length){
          <span class="keyword">int</span> bytesRemaining = result.length - totalBytesRead;
          <span class="comment">//input.read() devuelve -1, 0, o más :
</span>          <span class="keyword">int</span> bytesRead = input.read(result, totalBytesRead, bytesRemaining); 
          <span class="keyword">if</span> (bytesRead &gt; <span
            class="literal">0</span>){
            totalBytesRead = totalBytesRead + bytesRead;
          }
        }
        <span class="comment">/*
          el estilo de arriba es un poco complicado: coloca bytes en la matriz 'result';
         'result' es un parámetro de salida;
         el bucle while usualmente tiene solo una única interacción.
        */</span>
        log(<span class="literal">"Número de bytes leídos: "</span> + totalBytesRead);
      }
      <span class="keyword">finally</span> {
        log(<span class="literal">"Cerrando el flujo de entrada."</span>);
        input.close();
      }
    }
    <span class="keyword">catch</span> (FileNotFoundException ex) {
      log(<span class="literal">"Fichero no encontrado."</span>);
    }
    <span class="keyword">catch</span> (IOException ex) {
      log(ex);
    }
    <span class="keyword">return</span> result;
  }
  
  <span class="comment">/**
   Escribe una matriz de bytes al fichero dado.
   Escribir datos binarios es significativamente más simple que leerlos.
  */</span>
  <span class="keyword">void</span> write(<span class="keyword">byte</span>[] aInput, String aOutputFileName){
    log(<span class="literal">"Escribiendo fichero binario..."</span>);
    <span class="keyword">try</span> {
      OutputStream output = <span class="keyword">null</span>;
      <span class="keyword">try</span> {
        output = <span class="keyword">new</span> BufferedOutputStream(<span
            class="keyword">new</span> FileOutputStream(aOutputFileName));
        output.write(aInput);
      }
      <span class="keyword">finally</span> {
        output.close();
      }
    }
    <span class="keyword">catch</span>(FileNotFoundException ex){
      log(<span class="literal">"Fichero no encontrado."</span>);
    }
    <span class="keyword">catch</span>(IOException ex){
      log(ex);
    }
  }
  
  <span class="comment">/** Lee el fichero binario dado, y devuelve sus contenidos como una matriz de bytes.*/</span> 
  <span class="keyword">byte</span>[] readAlternateImpl(String aInputFileName){
    log(<span class="literal">"Leyendo fichero binario llamado : "</span> + aInputFileName);
    File file = <span class="keyword">new</span> File(aInputFileName);
    log(<span class="literal">"Tamaño del fichero: "</span> + file.length());
    <span class="keyword">byte</span>[] result = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
      InputStream input =  <span class="keyword">new</span> BufferedInputStream(<span
            class="keyword">new</span> FileInputStream(file));
      result = readAndClose(input);
    }
    <span class="keyword">catch</span> (FileNotFoundException ex){
      log(ex);
    }
    <span class="keyword">return</span> result;
  }
  
  <span class="comment">/**
    Lee un flujo de entrada, y lo devuelve como una matriz de bytes.
    Algunas veces la fuente de los bytes es un flujo de entrada en vez de un fichero.
    Esta implementación cierra aInput después de leer.
  */</span>
  <span class="keyword">byte</span>[] readAndClose(InputStream aInput){
    <span class="comment">//lleva los datos de entrada a salida:    
</span>    <span class="keyword">byte</span>[] bucket = <span class="keyword">new</span> <span
            class="keyword">byte</span>[<span class="literal">32</span>*<span
            class="literal">1024</span>]; 
    ByteArrayOutputStream result = <span class="keyword">null</span>; 
    <span class="keyword">try</span>  {
      <span class="keyword">try</span> {
        <span class="comment">//¿Usa almacenamiento en búfer? No. El almacenamiento en búfer evita el costoso acceso al disco o la red;
</span>        <span class="comment">//el almacenamiento en búfer en un flujo en memoria no tiene sentido.
</span>        result = <span class="keyword">new</span> ByteArrayOutputStream(bucket.length);
        <span class="keyword">int</span> bytesRead = <span
            class="literal">0</span>;
        <span class="keyword">while</span>(bytesRead != -<span
            class="literal">1</span>){
          <span class="comment">//aInput.read() devuelve -1, 0, o más :
</span>          bytesRead = aInput.read(bucket);
          <span class="keyword">if</span>(bytesRead &gt; <span
            class="literal">0</span>){
            result.write(bucket, <span class="literal">0</span>, bytesRead);
          }
        }
      }
      <span class="keyword">finally</span> {
        aInput.close();
        <span class="comment">//result.close(); esta es una no-operación para ByteArrayOutputStream
</span>      }
    }
    <span class="keyword">catch</span> (IOException ex){
      log(ex);
    }
    <span class="keyword">return</span> result.toByteArray();
  }
  
  <span class="keyword">private</span> <span class="keyword">static</span> <span
            class="keyword">void</span> log(Object aThing){
    System.out.println(String.valueOf(aThing));
  }
} 
    </pre>
    <p></p>
    <p></p>
    <div class="topic-section" id="see-also-title">Vea También :</div>
    <div id="see-also" class="main-body">
      <a href="..\entradasalida\entradasalida_8.html">Cierre siempre los flujos</a><br />
      <a href="..\entradasalida\entradasalida_42.html">Leer y escribir ficheros de texto</a><br />
      <a href="..\practicascomunes\practicascomunes_123.html">Minimizar los efectos dominantes</a><br />
      <a href="..\entradasalida\entradasalida_246.html">Copiar un fichero</a><br />
    </div>
    <footer id="footer" class="legalese">
      <span id="app_name">Prácticas de Java</span> 
      <span id="app_version_number">3.001</span><br /> © 
      <span id="copyright">2018 Hirondelle Systems</span><br /> 
      <a href="http://www.javapractices.com/source/SourceAction.do">Código Fuente</a> | 
      <a href="mailto:webmaster@javapractices.com" rel="author">Contacto</a> | 
      <a href="http://creativecommons.org/licenses/by-nc-sa/1.0/" rel="license">Licencia</a> | 
      <a href="http://www.javapractices.com/apps/cjp.rss" rel="alternate" type="application/rss+xml">RSS</a>
      <!-- ukey="2AC36CD2" -->
      <!-- ckey="16DF3D87" -->
      <br /> Los trozos de código individual tienen una 
      <a href="http://www.javapractices.com/LICENSE.txt" rel="license">licencia BSD</a><br /> 
      Sobre 1,000,000 de IPs únicas el último año<br /> 
      Última actualización <time id="last_updated_on" datetime="2018-06-03">2018-06-03</time><br />
      - In Memoriam : Bill Dirani -
    </footer>
  </body>
</html>
