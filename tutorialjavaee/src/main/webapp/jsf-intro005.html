<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8"/>
    <title>El Modelo de Componentes de la Interfaz de Usuario</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="css/style.css" rel="stylesheet">
    <script src="https://use.fontawesome.com/96c4d89611.js"></script>
  </head>
  <body>
    <table id="doc-title" cellspacing="0" cellpadding="0">
      <tr>
        <td align="left" valign="top">
          <b>Plataforma Java, Edición Empresarial (Java EE) 8</b><br />
          <b>El Tutorial de Java EE</b>
        </td>
      </tr>
    </table>
    <hr />
    <table width="90%" id="top-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>
        <td align="left">
          <a href="jsf-intro004.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="jsf-intro006.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class=" vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <div class="sect1" id="BNAQD">
      <h2 id="user-interface-component-model">El Modelo de Componentes de la Interfaz de Usuario</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>
            Además de la descripción del ciclo de vida, una descripción general de la arquitectura JavaServer 
            Faces proporciona una mejor comprensión de la tecnología.
          </p>
        </div>
        <div class="paragraph">
          <p>
            Los componentes de JavaServer Faces son los componentes básicos de una vista de JavaServer Faces. 
            Un componente puede ser un componente de interfaz de usuario (IU) o un componente que no es de IU.
          </p>
        </div>
        <div class="paragraph">
          <p>
            Los componentes de la IU de JavaServer Faces son elementos configurables y reutilizables que 
            componen las interfaces de usuario de las aplicaciones JavaServer Faces. Un componente puede ser 
            simple, como un botón, o puede ser compuesto, como una tabla compuesta por varios componentes.
          </p>
        </div>
        <div class="paragraph">
          <p>
            La tecnología JavaServer Faces proporciona una arquitectura de componentes rica y flexible que 
            incluye lo siguiente:
          </p>
        </div>
        <div class="ulist">
          <ul>
            <li>
              <p>
                Un conjunto de clases <code>javax.faces.component.UIComponent</code> para especificar el 
                estado y el comportamiento de los componentes de la interfaz de usuario
              </p>
            </li>
            <li>
              <p>
                Un modelo de renderizado que define cómo renderizar los componentes de varias formas.
              </p>
            </li>
            <li>
              <p>
                Un modelo de conversión que define cómo registrar convertidores de datos en un componente.
              </p>
            </li>
            <li>
              <p>
                Un modelo de evento y escucha que define cómo manejar eventos de componentes.
              </p>
            </li>
            <li>
              <p>
                Un modelo de validación que define cómo registrar validadores en un componente.
              </p>
            </li>
          </ul>
        </div>
        <div class="paragraph">
          <p>
            Esta sección describe brevemente cada una de estas piezas de la arquitectura de componentes.
          </p>
        </div>
        <div class="sect2" id="BNAQE">
          <h3 id="user-interface-component-classes">
            Clases de Componentes de la Interfaz de Usuario
          </h3>
          <div class="paragraph">
            <p>
              La tecnología JavaServer Faces proporciona un conjunto de clases de componentes de IU e 
              interfaces de comportamiento asociadas que especifican toda la funcionalidad del componente de 
              IU, como mantener el estado del componente, mantener una referencia a los objetos e impulsar el 
              manejo y la representación de eventos para un conjunto de componentes estándar.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Las clases de componentes son completamente extensibles, lo que permite a los escritores de 
              componentes crear sus propios componentes personalizados. Consulte el 
              <a href="jsf-custom.html#BNAVG"> Capítulo 15, "Creación de componentes de IU personalizados y 
                otros objetos personalizados" </a> para obtener más información.
            </p>
          </div>
          <div class="paragraph">
            <p>
              La clase base abstracta para todos los componentes es 
              <code>javax.faces.component.UIComponent</code>. Las clases de componentes de la interfaz de 
              usuario de JavaServer Faces amplían la clase <code>UIComponentBase</code> (una subclase de 
              <code>UIComponent</code>), que define el estado y el comportamiento predeterminados de un 
              componente. El siguiente conjunto de clases de componentes se incluye con la tecnología 
              JavaServer Faces.
            </p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>
                  <code>UIColumn</code>: representa una sola columna de datos en un componente 
                  <code>UIData</code>.
                </p>
              </li>
              <li>
                <p><code>UICommand</code>: representa un control que dispara acciones cuando se activa.</p>
              </li>
              <li>
                <p>
                  <code>UIData</code>: representa un enlace de datos a una colección de datos representada por 
                  una instancia de <code> javax.faces.model.DataModel </code>.
                </p>
              </li>
              <li>
                <p>
                  <code>UIForm</code>: representa un formulario de entrada que se presentará al usuario. Sus 
                  componentes secundarios representan (entre otras cosas) los campos de entrada que se 
                  incluirán cuando se envíe el formulario. Este componente es análogo a la etiqueta 
                  <code>form</code> en HTML.
                </p>
              </li>
              <li>
                <p><code>UIGraphic</code>: muestra una imagen.</p>
              </li>
              <li>
                <p>
                  <code>UIInput</code>: toma la entrada de datos de un usuario. Esta clase es una subclase de 
                  <code>UIOutput</code>.
                </p>
              </li>
              <li>
                <p><code>UIMessage</code>: muestra un mensaje de error localizado.</p>
              </li>
              <li>
                <p><code>UIMessages</code>: muestra un conjunto de mensajes de error localizados.</p>
              </li>
              <li>
                <p><code>UIOutcomeTarget</code>: muestra un enlace en forma de enlace o botón.</p>
              </li>
              <li>
                <p><code>UIOutput</code>: Muestra la salida de datos en una página.</p>
              </li>
              <li>
                <p><code>UIPanel</code>: Gestiona el diseño de sus componentes secundarios.</p>
              </li>
              <li>
                <p><code>UIParameter</code>: Representa parámetros de sustitución.</p>
              </li>
              <li>
                <p>
                  <code>UISelectBoolean</code>: Permite a un usuario establecer un valor 
                  <code>booleano</code> en un control seleccionándolo o deseleccionando. Esta clase es una 
                  subclase de la clase <code>UIInput</code>.
                </p>
              </li>
              <li>
                <p><code>UISelectItem</code>: Representa un solo elemento en un conjunto de elementos.</p>
              </li>
              <li>
                <p><code>UISelectItems</code>: Representa un conjunto completo de elementos.</p>
              </li>
              <li>
                <p>
                  <code>UISelectMany</code>: Permite a un usuario seleccionar varios elementos de un grupo de 
                  elementos. Esta clase es una subclase de la clase <code>UIInput</code>.
                </p>
              </li>
              <li>
                <p>
                  <code>UISelectOne</code>: Permite a un usuario seleccionar un elemento de un grupo de 
                  elementos. Esta clase es una subclase de la clase <code>UIInput</code>.
                </p>
              </li>
              <li>
                <p>
                  <code>UIViewParameter</code>: Representa los parámetros de consulta en una solicitud. Esta 
                  clase es una subclase de la clase <code>UIInput</code>.
                </p>
              </li>
              <li>
                <p><code>UIViewRoot</code>: Representa la raíz del árbol de componentes.</p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>
              Además de extender <code>UIComponentBase</code>, las clases de componentes también implementan 
              una o más interfaces de comportamiento, cada una de las cuales define cierto comportamiento para 
              un conjunto de componentes cuyas clases implementan la interfaz.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Estas interfaces de comportamiento, todas definidas en el paquete 
              <code>javax.faces.component</code> a menos que se indique lo contrario, son las siguientes.
            </p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>
                  <code>ActionSource</code>: indica que el componente puede disparar un evento de acción. Esta 
                  interfaz está diseñada para su uso con componentes basados en la tecnología JavaServer 
                  Faces 1.1_01 y versiones anteriores. Esta interfaz está obsoleta en JavaServer Faces 2.
                </p>
              </li>
              <li>
                <p>
                  <code>ActionSource2</code>: Extiende <code>ActionSource</code> y, por lo tanto, proporciona 
                  la misma funcionalidad. Sin embargo, permite que los componentes utilicen el lenguaje de 
                  expresión (EL) cuando hacen referencia a métodos que manejan eventos de acción.
                </p>
              </li>
              <li>
                <p>
                  <code>EditableValueHolder</code>: Extiende <code>ValueHolder</code> y especifica 
                  características adicionales para componentes editables, como validación y emisión de eventos 
                  de cambio de valor.
                </p>
              </li>
              <li>
                <p>
                  <code>NamingContainer</code>: Exige que cada componente arraigado en este componente tenga 
                  una identificación única.
                </p>
              </li>
              <li>
                <p>
                  <code>StateHolder</code>: Indica que un componente tiene un estado que debe guardarse entre 
                  solicitudes.
                </p>
              </li>
              <li>
                <p>
                  <code>ValueHolder</code>: Indica que el componente mantiene un valor local, así como la 
                  opción de acceder a los datos en el nivel del modelo.
                </p>
              </li>
              <li>
                <p>
                  <code>javax.faces.event.SystemEventListenerHolder</code>: Mantiene una lista de instancias 
                  de <code>javax.faces.event.SystemEventListener</code> para cada tipo de 
                  <code>javax.faces.event.SystemEvent</code> definido por esa clase.
                </p>
              </li>
              <li>
                <p>
                  <code>javax.faces.component.behavior.ClientBehaviorHolder</code>: Agrega la capacidad de 
                  adjuntar instancias de <code>javax.faces.component.behavior.ClientBehavior</code>, como una 
                  secuencia de comandos reutilizable.
                </p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>
              <code>UICommand</code> implementa <code>ActionSource2</code> y <code>StateHolder</code>. 
              <code>UIOutput</code> y las clases de componentes que amplían <code>UIOutput</code> implementan 
              <code>StateHolder</code> y <code>ValueHolder</code>. <code>UIInput</code> y las clases de 
              componentes que amplían <code>UIInput</code> implementan <code>EditableValueHolder</code>, 
              <code>StateHolder</code> y <code>ValueHolder</code>. <code>UIComponentBase</code> implementa 
              <code>StateHolder</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Solo los escritores de componentes necesitarán usar las clases de componentes y las interfaces 
              de comportamiento directamente. Los autores de páginas y los desarrolladores de aplicaciones 
              utilizarán un componente estándar al incluir una etiqueta que lo represente en una página. La 
              mayoría de los componentes se pueden representar de diferentes formas en una página. Por 
              ejemplo, un componente <code>UICommand</code> se puede representar como un botón o un enlace.
            </p>
          </div>
          <div class="paragraph">
            <p>
              La siguiente sección explica cómo funciona el modelo de renderizado y cómo los autores de 
              páginas pueden elegir renderizar los componentes seleccionando las etiquetas apropiadas.
            </p>
          </div>
        </div>
        <div class="sect2" id="BNAQF">
          <h3 id="component-rendering-model">Modelo de Representación de Componentes</h3>
          <div class="paragraph">
            <p>
              La arquitectura del componente JavaServer Faces está diseñada de tal manera que la 
              funcionalidad de los componentes está definida por las clases de componentes, mientras que la 
              representación del componente puede ser definida por una clase de renderizador separada. Este 
              diseño tiene varios beneficios, incluidos los siguientes.
            </p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>
                  Los escritores de componentes pueden definir el comportamiento de un componente una vez, 
                  pero crean múltiples renderizadores, cada uno de los cuales define una forma diferente de 
                  renderizar el componente al mismo cliente o a diferentes clientes.
                </p>
              </li>
              <li>
                <p>
                  Los autores de páginas y los desarrolladores de aplicaciones pueden cambiar la apariencia de 
                  un componente en la página seleccionando la etiqueta que representa la combinación apropiada 
                  de componente y renderizador.
                </p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>
              Un kit de renderizado define cómo las clases de componentes se asignan a las etiquetas de 
              componentes que son apropiadas para un cliente en particular. La implementación de JavaServer 
              Faces incluye un kit de renderizado HTML estándar para renderizar a un cliente HTML.
            </p>
          </div>
          <div class="paragraph">
            <p>
              El kit de renderizado define un conjunto de clases <code>javax.faces.render.Renderer</code> para 
              cada componente que admite. Cada clase <code>Renderer</code> define una forma diferente de 
              renderizar el componente en particular a la salida definida por el kit de renderizado. Por 
              ejemplo, un componente <code>UISelectOne</code> tiene tres renderizadores diferentes. Uno de 
              ellos representa el componente como un grupo de opciones. Otro representa el componente como un 
              cuadro combinado. El tercero representa el componente como un cuadro de lista. De manera 
              similar, un componente <code>UICommand</code> se puede representar como un botón o un enlace, 
              usando la etiqueta <code>h:commandButton </code> o <code>h:commandLink</code>. La parte 
              <code>comando</code> de cada etiqueta corresponde a la clase <code>UICommand</code>, 
              especificando la funcionalidad, que es disparar una acción. La parte <code>Button</code> o 
              <code>Link</code> de cada etiqueta corresponde a una clase <code>Renderer</code> separada que 
              define cómo aparece el componente en la página.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Cada etiqueta personalizada definida en el kit de renderizado HTML estándar está compuesta por la 
              funcionalidad del componente (definida en la clase <code>UIComponent</code>) y los atributos de 
              renderizado (definidos por la clase <code>Renderer</code>).
            </p>
          </div>
          <div class="paragraph">
            <p>
              La sección <a href="jsf-page002.html#BNARF">Adición de componentes a una página mediante 
                etiquetas de biblioteca de etiquetas HTML</a> enumera todas las etiquetas de componentes 
              compatibles e ilustra cómo utilizar las etiquetas en un ejemplo.
            </p>
          </div>
          <div class="paragraph">
            <p>
              La implementación de JavaServer Faces proporciona una biblioteca de etiquetas personalizada para 
              representar componentes en HTML.
            </p>
          </div>
        </div>
        <div class="sect2" id="BNAQI">
          <h3 id="conversion-model">Modelo de Conversión</h3>
          <div class="paragraph">
            <p>
              Una aplicación JavaServer Faces puede asociar opcionalmente un componente con datos de objeto 
              del lado del servidor. Este objeto es un componente de JavaBeans, como un bean gestionado. Una 
              aplicación obtiene y establece los datos del objeto para un componente llamando a las 
              propiedades del objeto apropiadas para ese componente.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Cuando un componente está vinculado a un objeto, la aplicación tiene dos vistas de los datos del 
              componente.
            </p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>
                  La vista del modelo, en la que los datos se representan como tipos de datos, como 
                  <code>int</code> o <code>long</code>.
                </p>
              </li>
              <li>
                <p>
                  La vista de presentación, en la que los datos se representan de una manera que el usuario 
                  puede leer o modificar. Por ejemplo, un <code>java.util.Date</code> puede representarse como 
                  una cadena de texto con el formato <code>mm/dd/aa </code> o como un conjunto de tres cadenas 
                  de texto.
                </p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>
              La implementación de JavaServer Faces convierte automáticamente los datos del componente entre 
              estas dos vistas cuando la propiedad del bean asociada con el componente es de uno de los tipos 
              admitidos por los datos del componente. Por ejemplo, si un componente 
              <code>UISelectBoolean</code> está asociado con una propiedad de bean de tipo 
              <code>java.lang.Boolean</code>, la implementación de JavaServer Faces convertirá automáticamente 
              los datos del componente de <code>String</code> a <code>booleano</code>. Además, algunos datos 
              de componentes deben estar vinculados a propiedades de un tipo particular. Por ejemplo, un 
              componente <code>UISelectBoolean</code> debe estar vinculado a una propiedad de tipo 
              <code>boolean</code> o <code>java.lang.Boolean </code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              A veces, es posible que desee convertir los datos de un componente a un tipo que no sea un tipo 
              estándar, o puede que desee convertir el formato de los datos. Para facilitar esto, la 
              tecnología JavaServer Faces le permite registrar una implementación de 
              <code>javax.faces.convert.Converter</code> en componentes de <code>UIOutput</code> y componentes 
              cuyas clases son subclases de <code>UIOutput</code> . Si registra la implementación de 
              <code>Converter</code> en un componente, la implementación de <code>Converter</code> convierte 
              los datos del componente entre las dos vistas.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Puede utilizar los convertidores estándar suministrados con la implementación de JavaServer 
              Faces o crear su propio convertidor personalizado. La creación de convertidores personalizados 
              se trata en el <a href="jsf-custom.html#BNAVG">Capítulo 15, "Creación de componentes de IU 
                personalizados y otros objetos personalizados"</a>.
            </p>
          </div>
        </div>
        <div class="sect2" id="GIREH">
          <h3 id="event-and-listener-model">Modelo de Evento y Escucha</h3>
          <div class="paragraph">
            <p>
              El modelo de evento y escucha de JavaServer Faces es similar al modelo de evento de JavaBeans en 
              que tiene clases de eventos e interfaces de escucha fuertemente tipadas que una aplicación puede 
              usar para manejar eventos generados por componentes.
            </p>
          </div>
          <div class="paragraph">
            <p>
              La especificación JavaServer Faces define tres tipos de eventos: eventos de aplicación, eventos 
              del sistema y eventos del modelo de datos.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Los eventos de aplicación están vinculados a una aplicación en particular y son generados por un 
              <code>UIComponent</code>. Representan los eventos estándar disponibles en versiones anteriores 
              de la tecnología JavaServer Faces.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Un objeto de evento identifica el componente que generó el evento y almacena información sobre 
              el evento. Para ser notificado de un evento, una aplicación debe proporcionar una implementación 
              de la clase de escucha y debe registrarla en el componente que genera el evento. Cuando el 
              usuario activa un componente, como al hacer clic en un botón, se activa un evento. Esto hace que 
              la implementación de JavaServer Faces invoque el método de escucha que procesa el evento.
            </p>
          </div>
          <div class="paragraph">
            <p>
              JavaServer Faces admite dos tipos de eventos de aplicación: eventos de acción y eventos de 
              cambio de valor.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Un evento de acción (clase <code>javax.faces.event.ActionEvent</code>) ocurre cuando el usuario 
              activa un componente que implementa <code> ActionSource </code>. Estos componentes incluyen 
              botones y enlaces.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Un evento de cambio de valor (clase <code>javax.faces.event.ValueChangeEvent</code>) ocurre 
              cuando el usuario cambia el valor de un componente representado por <code>UIInput</code> o una 
              de sus subclases. Un ejemplo es seleccionar una casilla de verificación, una acción que da como 
              resultado que el valor del componente cambie a <code>true</code>. Los tipos de componentes que 
              pueden generar estos tipos de eventos son los componentes <code>UIInput</code>, 
              <code>UISelectOne</code>, <code>UISelectMany</code> y <code>UISelectBoolean</code>. Los eventos 
              de cambio de valor se activan solo si no se detectan errores de validación.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Dependiendo del valor de la propiedad <code>inmediata</code> (ver 
              <a href="jsf-page002.html#BNARI">El atributo inmediato</a>) del componente que emite el evento, 
              los eventos de acción pueden ser procesados durante la fase de Invocación de Solicitud o la fase 
              de Aplicación de Valores de Solicitud, y los eventos de cambio de valor se pueden procesar 
              durante la fase de Validación de Procesos o la fase de Aplicación de Valores de Solicitud.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Los eventos del sistema son generados por un <code>Object</code> en lugar de un 
              <code>UIComponent</code>. Se generan durante la ejecución de una aplicación en momentos 
              predefinidos. Son aplicables a toda la aplicación en lugar de a un componente específico.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Un evento de modelo de datos ocurre cuando se selecciona una nueva fila de un componente 
              <code>UIData</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Hay dos formas de hacer que su aplicación reaccione a eventos de acción o eventos de cambio de 
              valor que son emitidos por un componente estándar:
            </p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>
                  Implementar una clase de detector de eventos para manejar el evento y registrarlo en el 
                  componente anidando una etiqueta <code>f: valueChangeListener</code> o una etiqueta 
                  <code>f: actionListener</code> dentro de la etiqueta del componente.
                </p>
              </li>
              <li>
                <p>
                  Implementar un método de un bean administrado para manejar el evento y consultar el método 
                  con una expresión de método del atributo apropiado de la etiqueta del componente.
                </p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>
              Consulte <a href="jsf-custom007.html#BNAUT">Implementación de un detector de eventos</a> para 
              obtener información sobre cómo implementar un detector de eventos. Consulte 
              <a href="jsf-page-core002.html#BNASZ">Registro de oyentes en componentes</a> para obtener 
              información sobre cómo registrar el oyente en un componente.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Consulte 
              <a href="jsf-develop003.html#BNAVD">Cómo escribir un método para manejar un evento de acción</a> 
              y <a href="jsf-develop003.html#BNAVF">
                Cómo escribir un método para manejar un valor- Evento de Cambio
              </a> para obtener información sobre cómo implementar métodos de bean administrados que manejan 
              estos eventos.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Consulte 
              <a href="jsf-page-core004.html#BNATN">Cómo hacer referencia a un método de bean administrado</a> 
              para obtener información sobre cómo hacer referencia al método de bean administrado desde la 
              etiqueta del componente.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Al emitir eventos desde componentes personalizados, debe implementar la clase de evento adecuada 
              y poner en cola manualmente el evento en el componente, además de implementar una clase de 
              escucha de eventos o un método bean administrado que maneja el evento. 
              <a href="jsf-custom008.html#BNAWD">Manejo de eventos para componentes personalizados</a> explica 
              cómo hacer esto.
            </p>
          </div>
        </div>
        <div class="sect2" id="BNAQK">
          <h3 id="validation-model">Modelo de Validación</h3>
          <div class="paragraph">
            <p>
              La tecnología JavaServer Faces admite un mecanismo para validar los datos locales de los 
              componentes editables (como los campos de texto). Esta validación ocurre antes de que los datos 
              del modelo correspondiente se actualicen para que coincidan con el valor local.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Al igual que el modelo de conversión, el modelo de validación define un conjunto de clases 
              estándar para realizar comprobaciones de validación de datos comunes. La biblioteca de etiquetas 
              del núcleo de JavaServer Faces también define un conjunto de etiquetas que corresponden a las 
              implementaciones estándar de <code>javax.faces.validator.Validator</code>. Consulte 
              <a href="jsf-page-core003.html#BNATC">Uso de los validadores estándar</a> para obtener una lista 
              de todas las clases de validación estándar y las etiquetas correspondientes.
            </p>
          </div>
          <div class="paragraph">
            <p>
              La mayoría de las etiquetas tienen un conjunto de atributos para configurar las propiedades del 
              validador, como los valores mínimos y máximos permitidos para los datos del componente. El autor 
              de la página registra el validador en un componente anidando la etiqueta del validador dentro de 
              la etiqueta del componente.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Además de los validadores que están registrados en el componente, puede declarar un validador 
              predeterminado que está registrado en todos los componentes <code>UIInput</code> de la 
              aplicación. Para obtener más información sobre validadores predeterminados, consulte 
              <a href="jsf-configure007.html#GIREB">Uso de validadores predeterminados</a>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              El modelo de validación también le permite crear su propio validador personalizado y la etiqueta 
              correspondiente para realizar una validación personalizada. El modelo de validación proporciona 
              dos formas de implementar la validación personalizada.
            </p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>Implemente una interfaz <code>Validator</code> que realiza la validación.</p>
              </li>
              <li>
                <p>Implemente un método de bean administrado que realice la validación.</p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>
              Si está implementando una interfaz <code>Validator</code>, también debe hacer lo siguiente.
            </p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>
                  Registre la implementación de <code>Validator</code> con la aplicación.
                </p>
              </li>
              <li>
                <p>
                  Cree una etiqueta personalizada o use una etiqueta <code>f:validator</code> para registrar 
                  el validador en el componente.
                </p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>
              En el modelo de validación estándar descrito anteriormente, el validador se define para cada 
              componente de entrada en una página. El modelo de Validación de Beans permite aplicar el 
              validador a todos los campos de una página. Consulte 
              <a href="bean-validation.html#CHDGJIIA">Capítulo 23, "Introducción a la validación de Bean"</a> 
              y <a href="bean-validation-advanced.html#GKAHP">
                Capítulo 24, "Validación de Beans: Temas avanzados"
              </a> para obtener más información sobre la validación de Bean.
            </p>
          </div>
        </div>
      </div>
    </div>
    <hr />
    <table width="90%" id="bottom-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>		
        <td align="left">
          <a href="jsf-intro004.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="jsf-intro006.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class="vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <span id="copyright">
      <a href="img/cpyr.adoc">
        <img src="img/oracle.gif" height="10" alt="Logo de Oracle" />&nbsp;			
        <span>
          Copyright&nbsp;&copy;&nbsp;2017,&nbsp;Oracle&nbsp;y/o&nbsp;sus&nbsp;afiliados.&nbsp;Todos&nbsp;los&nbsp;
          derechos&nbsp;reservados.
        </span>
      </a>
    </span>
  </body>
</html>
