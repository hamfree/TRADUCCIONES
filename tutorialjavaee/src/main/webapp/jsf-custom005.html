<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8"/>
    <title>Creando Clases de Componentes Personalizados</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="css/style.css" rel="stylesheet">
    <script src="https://use.fontawesome.com/96c4d89611.js"></script>
  </head>
  <body>
    <table id="doc-title" cellspacing="0" cellpadding="0">
      <tr>
        <td align="left" valign="top">
          <b>Plataforma Java, Edición Empresarial (Java EE) 8</b><br />
          <b>El Tutorial de Java EE</b>
        </td>
      </tr>
    </table>
    <hr />
    <table width="90%" id="top-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>
        <td align="left">
          <a href="jsf-custom004.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="jsf-custom006.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class=" vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <div class="sect1" id="BNAVU">
      <h2 id="creating-custom-component-classes">Creando Clases de Componentes Personalizados</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>
            Como se explica en <a href="jsf-custom002.html#BNAVI">Cuándo usar un componente personalizado</a>, 
            una clase de componente define el estado y el comportamiento de un componente de la interfaz de 
            usuario. La información de estado incluye el tipo, identificador y valor local del componente. El 
            comportamiento definido por la clase de componente incluye lo siguiente:
          </p>
        </div>
        <div class="ulist">
          <ul>
            <li>
              <p>Decodificación (conversión del parámetro de solicitud al valor local del componente)</p>
            </li>
            <li>
              <p>Codificación (conversión del valor local en el marcado correspondiente)</p>
            </li>
            <li>
              <p>Guardar el estado del componente</p>
            </li>
            <li>
              <p>Actualizar el valor del bean con el valor local</p>
            </li>
            <li>
              <p>Procesamiento de validación sobre el valor local</p>
            </li>
            <li>
              <p>Encolar eventos</p>
            </li>
          </ul>
        </div>
        <div class="paragraph">
          <p>
            La clase <code>javax.faces.component.UIComponentBase</code> define el comportamiento 
            predeterminado de una clase de componente. Todas las clases que representan los componentes 
            estándar se extienden desde <code>UIComponentBase</code>. Estas clases agregan sus propias 
            definiciones de comportamiento, como lo hará su clase de componente personalizado.
          </p>
        </div>
        <div class="paragraph">
          <p>
            Su clase de componente personalizado debe extender <code>UIComponentBase</code> directamente o 
            extender una clase que represente uno de los componentes estándar. Estas clases se encuentran en 
            el paquete <code>javax.faces.component</code> y sus nombres comienzan con <code>UI</code>.
          </p>
        </div>
        <div class="paragraph">
          <p>
            Si su componente personalizado tiene el mismo propósito que un componente estándar, debe extender 
            ese componente estándar en lugar de extender directamente <code>UIComponentBase</code>. Por 
            ejemplo, suponga que desea crear un componente de menú editable. Tiene sentido que este componente 
            extienda <code>UISelectOne</code> en lugar de <code>UIComponentBase</code> porque puede reutilizar 
            el comportamiento ya definido en <code>UISelectOne</code>. La única funcionalidad nueva que 
            necesita definir es hacer que el menú sea editable.
          </p>
        </div>
        <div class="paragraph">
          <p>
            Ya sea que decida que su componente extienda <code>UIComponentBase</code> o un componente 
            estándar, es posible que también desee que su componente implemente una o más de estas interfaces 
            de comportamiento definidas en el paquete <code>javax.faces.component</code>:
          </p>
        </div>
        <div class="ulist">
          <ul>
            <li>
              <p>
                <code>ActionSource</code>: Indica que el componente puede disparar 
                <code>javax.faces.event.ActionEvent</code>
              </p>
            </li>
            <li>
              <p>
                <code>ActionSource2</code>: Extiende <code>ActionSource</code> y permite que las propiedades 
                de los componentes que hacen referencia a métodos que manejan eventos de acción usen 
                expresiones de método según lo definido por EL
              </p>
            </li>
            <li>
              <p>
                <code>EditableValueHolder</code>: Extiende <code>ValueHolder</code> y especifica 
                características adicionales para componentes editables, como validación y emisión de eventos 
                de cambio de valor.
              </p>
            </li>
            <li>
              <p>
                <code>NamingContainer</code>: Exige que cada componente arraigado en este componente tenga una 
                identificación única
              </p>
            </li>
            <li>
              <p>
                <code>StateHolder</code>: Indica que un componente tiene un estado que debe guardarse entre 
                solicitudes
              </p>
            </li>
            <li>
              <p>
                <code>ValueHolder</code>: Indica que el componente mantiene un valor local, así como la opción 
                de acceder a los datos en el nivel del modelo.
              </p>
            </li>
          </ul>
        </div>
        <div class="paragraph">
          <p>
            Si su componente extiende <code>UIComponentBase</code>, implementa automáticamente solo 
            <code>StateHolder</code>. Debido a que todos los componentes extienden directa o indirectamente 
            <code>UIComponentBase</code>, todos implementan <code>StateHolder</code>. Cualquier componente que 
            implemente <code>StateHolder</code> también implementa la interfaz <code>StateHelper</code>, que 
            extiende <code>StateHolder</code> y define un contrato similar a <code>Map</code> que facilita que 
            los componentes guarden y restauren un estado de vista parcial.
          </p>
        </div>
        <div class="paragraph">
          <p>
            Si su componente extiende uno de los otros componentes estándar, también podría implementar otras 
            interfaces de comportamiento además de <code>StateHolder</code>. Si su componente extiende 
            <code>UICommand</code>, implementa automáticamente <code>ActionSource2</code>. Si su componente 
            amplía <code>UIOutput</code> o una de las clases de componentes que amplían <code>UIOutput</code>, 
            implementa automáticamente <code>ValueHolder</code>. Si su componente extiende 
            <code>UIInput</code>, implementa automáticamente <code>EditableValueHolder</code> y 
            <code>ValueHolder</code>. Consulte la documentación de la API JavaServer Faces para averiguar qué 
            implementan las otras clases de componentes.
          </p>
        </div>
        <div class="paragraph">
          <p>
            También puede hacer que su componente implemente explícitamente una interfaz de comportamiento que 
            aún no tiene en virtud de extender un componente estándar en particular. Por ejemplo, si tiene un 
            componente que extiende <code>UIInput</code> y desea que active eventos de acción, debe hacer que 
            implemente explícitamente <code>ActionSource2</code> porque un componente <code>UIInput</code> no 
            implementa automáticamente esta interfaz.
          </p>
        </div>
        <div class="paragraph">
          <p>
            El ejemplo de mapa de imagen de la librería de Duke tiene dos clases de componentes: 
            <code>AreaComponent</code> y <code>MapComponent</code>. La clase <code>MapComponent</code> 
            extiende <code>UICommand</code> y, por lo tanto, implementa <code>ActionSource2</code>, lo que 
            significa que puede activar eventos de acción cuando un usuario hace clic en el mapa. La clase 
            <code>AreaComponent</code> extiende el componente estándar <code>UIOutput</code>. La anotación 
            <code>@FacesComponent</code> registra los componentes con la implementación de JavaServer Faces:
          </p>
        </div>
        <div class="listingblock">
          <div class="content">
            <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
@FacesComponent("DemoMap")
public class MapComponent extends UICommand {...}
@FacesComponent("DemoArea")
public class AreaComponent extends UIOutput {...}
            </code></pre>
          </div>
        </div>
        <div class="paragraph">
          <p>
            La clase <code>MapComponent</code> representa el componente correspondiente a la etiqueta 
            <code>bookstore:map</code>:
          </p>
        </div>
        <div class="listingblock">
          <div class="content">
            <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
&lt;bookstore:map id="bookMap"
               current="map1"
               immediate="true"
               action="bookstore"&gt;
    ...
&lt;/bookstore:map&gt;
            </code></pre>
          </div>
        </div>
        <div class="paragraph">
          <p>
            La clase <code>AreaComponent</code> representa el componente correspondiente a la etiqueta 
            <code>bookstore:area</code>:
          </p>
        </div>
        <div class="listingblock">
          <div class="content">
            <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
&lt;bookstore:area id="map1" value="#{Book201}"
                onmouseover="resources/images/book_201.jpg"
                onmouseout="resources/images/book_all.jpg"
                targetImage="mapImage"/&gt;
            </code></pre>
          </div>
        </div>
        <div class="paragraph">
          <p>
            <code>MapComponent</code> tiene una o más instancias de <code>AreaComponent</code> como elementos 
            secundarios. Su comportamiento consta de las siguientes acciones:
          </p>
        </div>
        <div class="ulist">
          <ul>
            <li>
              <p>Recuperando el valor del área actualmente seleccionada</p>
            </li>
            <li>
              <p>Definición de las propiedades correspondientes a los valores del componente.</p>
            </li>
            <li>
              <p>Generando un evento cuando el usuario hace clic en el mapa de la imagen</p>
            </li>
            <li>
              <p>Hacer cola para el evento</p>
            </li>
            <li>
              <p>Salvar su estado</p>
            </li>
            <li>
              <p>Representar la etiqueta HTML <code>map</code> y la etiqueta HTML <code>input</code></p>
            </li>
          </ul>
        </div>
        <div class="paragraph">
          <p>
            <code>MapComponent</code> delega la representación de las etiquetas HTML <code>map  </code> y 
              <code>input</code> a la clase <code>MapRenderer</code>.
          </p>
        </div>
        <div class="paragraph">
          <p>
            <code>AreaComponent</code> está vinculado a un bean que almacena la forma y las coordenadas de la 
            región del mapa de imagen. Verás cómo se accede a todos estos datos a través de la expresión de 
            valor en <a href="jsf-custom006.html#BNAWB"> Creando la Clase del Renderizador </a>. El 
            comportamiento de <code>AreaComponent</code> consiste en lo siguiente:
          </p>
        </div>
        <div class="ulist">
          <ul>
            <li>
              <p>Recuperar la forma y los datos de coordenadas del bean</p>
            </li>
            <li>
              <p>Establecer el valor de la etiqueta oculta en el <code> id </code> de este componente</p>
            </li>
            <li>
              <p>
                Representar la etiqueta <code>area</code>, incluido el JavaScript para las funciones 
                <code>onmouseover</code>, <code>onmouseout</code> y <code>onclick</code>
              </p>
            </li>
          </ul>
        </div>
        <div class="paragraph">
          <p>
            Aunque estas tareas las realiza realmente <code>AreaRenderer</code>, <code>AreaComponent</code> 
            debe delegar las tareas a <code>AreaRenderer</code>. Consulte 
            <a href="jsf-custom006.html#BNAWA">Delegación de Renderizado a un Renderizador</a> para obtener 
            más información.
          </p>
        </div>
        <div class="paragraph">
          <p>
            El resto de esta sección describe las tareas que realiza <code>MapComponent</code>, así como la 
            codificación y decodificación que delega a <code>MapRenderer</code>. 
            <a href="jsf-custom008.html#BNAWD">Gestionando Eventos para Componentes Personalizados</a> detalla 
            cómo <code>MapComponent</code> maneja los eventos.
          </p>
        </div>
        <div class="sect2" id="BNAVV">
          <h3 id="specifying-the-component-family">Especificando la Familia del Componente</h3>
          <div class="paragraph">
            <p>
              Si su clase de componente personalizado delega la representación, debe anular el método 
              <code>getFamily</code> de <code>UIComponent</code> para devolver el identificador de una familia 
              de componentes, que se utiliza para hacer referencia a un componente o conjunto de componentes 
              que pueden ser renderizados por un renderizador o un conjunto de renderizadores. La familia de 
              componentes se usa junto con el tipo de renderizador para buscar renderizadores que puedan 
              renderizar el componente:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
public String getFamily() {
    return ("Map");
}
              </code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              El identificador de la familia de componentes, <code>Map</code>, debe coincidir con el definido 
              por los elementos <code>component-family</code> incluidos en las configuraciones del componente 
              y del renderizador en el archivo de recursos de configuración de la aplicación. 
              <a href="jsf-configure011.html#BNAXH">
                Registrando un Renderizador Personalizado con un Kit Render
              </a> explica cómo definir la familia de componentes en la configuración del renderizador. 
              <a href="jsf-configure012.html#BNAXI"> Registrando un Componente Personalizado </a> explica cómo 
              definir la familia de componentes en la configuración de componentes.
            </p>
          </div>
        </div>
        <div class="sect2" id="BNAVW">
          <h3 id="performing-encoding">Realización de Codificación</h3>
          <div class="paragraph">
            <p>
                Durante la fase de Respuesta de Procesamiento, la implementación de JavaServer Faces procesa 
                los métodos de codificación de todos los componentes y sus renderizadores asociados en la 
                vista. Los métodos de codificación convierten el valor local actual del componente en el 
                marcado correspondiente que lo representa en la respuesta.
            </p>
          </div>
          <div class="paragraph">
            <p>
              La clase <code>UIComponentBase</code> define un conjunto de métodos para representar el marcado: 
              <code>encodeBegin</code>, <code>encodeChildren</code> y <code>encodeEnd </code>. Si el 
              componente tiene componentes secundarios, es posible que deba utilizar más de uno de estos 
              métodos para representar el componente; de lo contrario, todo el renderizado debería realizarse 
              en <code>encodeEnd </code>. Alternativamente, puede usar el método <code> encodeALL </code>, que 
              abarca todos los métodos.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Debido a que <code>MapComponent</code> es un componente principal de <code>AreaComponent</code>, 
              las etiquetas <code>area</code> deben representarse después de la etiqueta <code>map</code> 
              inicial y antes la etiqueta final <code>map</code>. Para lograr esto, la clase 
              <code>MapRenderer</code> representa la etiqueta <code>map</code> inicial en 
              <code>encodeBegin</code> y el resto de la etiqueta <code>map</code> en <code>encodeEnd</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              La implementación de JavaServer Faces invoca automáticamente el método <code>encodeEnd</code> 
              del renderizador de <code>AreaComponent</code> después de que invoca el método 
              <code>encodeBegin</code> de <code>MapRenderer</code> y antes de que invoca el método 
              <code>encodeEnd</code> de <code>MapRenderer</code>. Si un componente necesita realizar el 
              renderizado para sus hijos, lo hace en el método <code>encodeChildren</code>.
              
            </p>
          </div>
          <div class="paragraph">
            <p>
              Estos son los métodos <code>encodeBegin</code> y <code>encodeEnd</code> de 
              <code>MapRenderer</code>:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
@Override
public void encodeBegin(FacesContext context, UIComponent component)
        throws IOException {
    if ((context == null)|| (component == null)) {
        throw new NullPointerException();
    }
    MapComponent map = (MapComponent) component;
    ResponseWriter writer = context.getResponseWriter();
    writer.startElement("map", map);
    writer.writeAttribute("name", map.getId(), "id");
}
@Override
public void encodeEnd(FacesContext context, UIComponent component)
        throws IOException {
    if ((context == null) || (component == null)){
        throw new NullPointerException();
    }
    MapComponent map = (MapComponent) component;
    ResponseWriter writer = context.getResponseWriter();
    writer.startElement("input", map);
    writer.writeAttribute("type", "hidden", null);
    writer.writeAttribute("name", getName(context,map), "clientId");
    writer.endElement("input");
    writer.endElement("map");
}
              </code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Tenga en cuenta que <code>encodeBegin</code> representa solo la etiqueta <code>map</code> 
              inicial. El método <code>encodeEnd</code> representa la etiqueta <code>input</code> y la 
              etiqueta final <code>map</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Los métodos de codificación aceptan un argumento <code>UIComponent</code> y un argumento 
              <code>javax.faces.context.FacesContext</code>. La instancia de <code> FacesContext </code> 
              contiene toda la información asociada con la solicitud actual. El argumento 
              <code>UIComponent</code> es el componente que necesita ser renderizado.
            </p>
          </div>
          <div class="paragraph">
            <p>
              El resto del método representa el marcado en la instancia 
              <code>javax.faces.context.ResponseWriter</code>, que escribe el marcado en la respuesta actual. 
              Básicamente, esto implica pasar los nombres de las etiquetas HTML y los nombres de los atributos 
              a la instancia de <code> ResponseWriter </code> como cadenas, recuperar los valores de los atributos del componente y pasar estos valores a la instancia de <code> ResponseWriter </code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              El método <code>startElement</code> toma una <code>String</code> (el nombre de la etiqueta) y el 
              componente al que corresponde la etiqueta (en este caso, <code>map</code>). (Pasar esta 
              información a la instancia de <code>ResponseWriter</code> ayuda a las herramientas de tiempo de 
              diseño a saber qué partes del marcado generado están relacionadas con qué componentes).
            </p>
          </div>
          <div class="paragraph">
            <p>
              Después de llamar a <code>startElement</code>, puede llamar a <code>writeAttribute </code> para 
              representar los atributos de la etiqueta. El método <code>writeAttribute</code> toma el nombre 
              del atributo, su valor y el nombre de una propiedad o atributo del componente contenedor 
              correspondiente al atributo. El último parámetro puede ser nulo y no se representará.
            </p>
          </div>
          <div class="paragraph">
            <p>
              El valor del atributo <code>name</code> de la etiqueta <code>map</code> se recupera utilizando 
              el método <code>getId</code> de <code>UIComponent</code>, que devuelve el valor exclusivo del 
              componente. identificador. El valor del atributo <code>name</code> de la etiqueta 
              <code>input</code> se recupera utilizando el método 
              <code>getName(FacesContext, UIComponent)</code> de <code>MapRenderer</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Si desea que su componente realice su propio renderizado pero delegue a un renderizador si lo 
              hay, incluya las siguientes líneas en el método de codificación para verificar si hay un 
              renderizador asociado con este componente:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
if (getRendererType() != null) {
    super.encodeEnd(context);
    return;
}
              </code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Si hay un renderizador disponible, este método invoca el método <code>encodeEnd</code> de la 
              superclase, que hace el trabajo de encontrar el renderizador. La clase <code>MapComponent</code> 
              delega todo el renderizado en <code>MapRenderer</code>, por lo que no necesita buscar 
              renderizadores disponibles.
            </p>
          </div>
          <div class="paragraph">
            <p>
              En algunas clases de componentes personalizados que amplían componentes estándar, es posible que 
              deba implementar otros métodos además de <code>encodeEnd</code>. Por ejemplo, si necesita 
              recuperar el valor del componente de los parámetros de solicitud, también debe implementar el 
              método <code>decode</code>.
            </p>
          </div>
        </div>
        <div class="sect2" id="BNAVX">
          <h3 id="performing-decoding">Realización de Decodificación</h3>
          <div class="paragraph">
            <p>
              Durante la fase Aplicar valores de solicitud, la implementación de JavaServer Faces procesa los 
              métodos <code>decode</code> de todos los componentes del árbol. El método <code>decode</code> 
              extrae el valor local de un componente de los parámetros de la solicitud entrante y utiliza una 
              implementación de <code>javax.faces.convert.Converter</code> para convertir el valor en un tipo 
              que sea aceptable para la clase del componente.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Una clase de componente personalizado o su renderizador debe implementar el método 
              <code>decode</code> solo si debe recuperar el valor local o si necesita poner en cola los 
              eventos. El componente pone en cola el evento llamando a <code>queueEvent</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>Aquí está el método <code>decode</code> de <code>MapRenderer</code>:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
@Override
public void decode(FacesContext context, UIComponent component) {
    if ((context == null) || (component == null)) {
        throw new NullPointerException();
    }
    MapComponent map = (MapComponent) component;
    String key = getName(context, map);
    String value = (String) context.getExternalContext().
            getRequestParameterMap().get(key);
    if (value != null)
        map.setCurrent(value);
    }
}
              </code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              El método <code>decode</code> primero obtiene el nombre del campo oculto <code>input</code> 
              llamando a <code>getName(FacesContext, UIComponent)</code>. Luego usa ese nombre como clave para 
              el mapa de parámetros de solicitud para recuperar el valor actual del campo <code>input</code>. 
              Este valor representa el área actualmente seleccionada. Finalmente, establece el valor del 
              atributo <code>current</code> de la clase <code>MapComponent</code> en el valor del campo 
              <code>input</code>.
            </p>
          </div>
        </div>
        <div class="sect2" id="BNAVY">
          <h3 id="enabling-component-properties-to-accept-expressions">
            Habilitando las Propiedades del Componente para Aceptar Expresiones
          </h3>
          <div class="paragraph">
            <p>
              Casi todos los atributos de las etiquetas estándar de JavaServer Faces pueden aceptar 
              expresiones, ya sean expresiones de valor o expresiones de método. Se recomienda que también 
              habilite los atributos de su componente para aceptar expresiones porque le brinda mucha más 
              flexibilidad al escribir páginas de Facelets.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Para permitir que los atributos acepten expresiones, la clase de componente debe implementar 
              métodos getter y setter para las propiedades del componente. Estos métodos pueden utilizar las 
              facilidades que ofrece la interfaz <code>StateHelper</code> para almacenar y recuperar no solo 
              los valores de estas propiedades, sino también el estado de los componentes a través de 
              múltiples solicitudes.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Debido a que <code>MapComponent</code> extiende <code>UICommand</code>, la clase 
                <code>UICommand</code> ya hace el trabajo de obtener las instancias asociadas 
                <code>ValueExpression</code> y <code>MethodExpression</code> con cada uno de los atributos que 
                admite. De manera similar, la clase <code>UIOutput</code> que extiende 
                <code>AreaComponent</code> ya obtiene las instancias de <code>ValueExpression</code> para sus 
                atributos admitidos. Para ambos componentes, los métodos simple getter y setter almacenan y 
                recuperan los valores clave y el estado de los atributos, como se muestra en este fragmento de 
                código de <code>AreaComponent</code>:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
enum PropertyKeys {
    alt, coords, shape, targetImage;
}
public String getAlt() {
    return (String) getStateHelper().eval(PropertyKeys.alt, null);
}
public void setAlt(String alt) {
    getStateHelper().put(PropertyKeys.alt, alt);
}
...
              </code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Sin embargo, si tiene una clase de componente personalizado que extiende 
              <code>UIComponentBase</code>, deberá implementar los métodos que obtienen las instancias 
              <code>ValueExpression</code> y <code>MethodExpression</code> asociadas con aquellos atributos 
              que están habilitados para aceptar expresiones. Por ejemplo, podría incluir un método que 
              obtenga la instancia <code>ValueExpression</code> para el atributo <code>immediate</code>:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
public boolean isImmediate() {
    if (this.immediateSet) {
        return (this.immediate);
    }
    ValueExpression ve = getValueExpression("immediate");
    if (ve != null) {
        Boolean value = (Boolean) ve.getValue(
            getFacesContext().getELContext());
        return (value.booleanValue());
    } else {
        return (this.immediate);
    }
}
              </code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Las propiedades correspondientes a los atributos del componente que aceptan expresiones de 
              método deben aceptar y devolver un objeto <code>MethodExpression</code>. Por ejemplo, si 
              <code>MapComponent</code> extendió <code>UIComponentBase</code> en lugar de 
              <code>UICommand</code>, necesitaría proporcionar una propiedad <code>action</code> que devuelva 
              y acepta un objeto <code>MethodExpression</code>:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
public MethodExpression getAction() {
    return (this.action);
}
public void setAction(MethodExpression action) {
    this.action = action;
}
              </code></pre>
            </div>
          </div>
        </div>
        <div class="sect2" id="BNAVZ">
          <h3 id="saving-and-restoring-state">Guardar y Restaurar el Estado</h3>
          <div class="paragraph">
            <p>
              Como se describe en 
              <a href="#BNAVY">Habilitando las Propiedades del Componente para Aceptar Expresiones</a>, el 
              uso de las facilidades de la interfaz <code>StateHelper</code> le permite guardar el estado del 
              componente al mismo tiempo que establecer y recuperar valores de propiedad. La implementación de 
              <code>StateHelper</code> permite el ahorro de estado parcial; solo guarda los cambios en el 
              estado desde la solicitud inicial, no el estado completo, porque el estado completo se puede 
              restaurar durante la fase Restaurar Vista.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Las clases de componentes que implementan <code>StateHolder</code> pueden preferir implementar 
              los métodos <code>saveState(FacesContext)</code> y 
              <code>restoreState(FacesContext, Object)</code> para ayudar a la implementación de JavaServer 
              Faces a guardar y restaurar el estado de los componentes en varias solicitudes.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Para guardar un conjunto de valores, puede implementar el método 
              <code>saveState(FacesContext)</code>. Este método se llama durante la fase Respuesta de 
              Procesamiento, durante la cual se guarda el estado de la respuesta para procesarlo en 
              solicitudes posteriores. Aquí hay un método hipotético de <code>MapComponent</code>, que tiene 
              solo un atributo, <code>current</code>:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
@Override
public Object saveState(FacesContext context) {
    Object values[] = new Object[2];
    values[0] = super.saveState(context);
    values[1] = current;
    return (values);
}
              </code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Este método inicializa una matriz, que mantendrá el estado guardado. A continuación, guarda 
              todo el estado asociado con el componente.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Un componente que implementa <code>StateHolder</code> también puede proporcionar una 
              implementación para <code>restoreState(FacesContext, Object)</code>, que restaura el estado del 
              componente al guardado con el método <code>saveState(FacesContext)</code>. El método 
              <code>restoreState(FacesContext, Object)</code> se llama durante la fase Restaurar Vista, 
              durante la cual la implementación de JavaServer Faces comprueba si hay algún estado que se haya 
              guardado durante la última fase de Respuesta de  Procesamiento y que deba restaurarse en 
              preparación para la próxima devolución de datos.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Aquí hay un método <code>restoreState(FacesContext, Object)</code> hipotético de 
              <code>MapComponent</code>:
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="prettyprint highlight"><code class="language-oac_no_warn" data-lang="oac_no_warn">
public void restoreState(FacesContext context, Object state) {
    Object values[] = (Object[]) state;
    super.restoreState(context, values[0]);
    current = (String) values[1];
}
              </code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              Este método toma una instancia de <code>FacesContext</code> y de <code>Object</code>, que 
              representan la matriz que contiene el estado del componente. Este método establece las 
              propiedades del componente en los valores guardados en la matriz de <code>Object</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Ya sea que implemente o no estos métodos en su clase de componente, puede usar el parámetro de 
              contexto <code>javax.faces.STATE_SAVING_METHOD</code> para especificar en el descriptor de 
              implementación dónde desea que se guarde el estado: o <code>client</code> o <code>server</code>. 
              Si el estado se guarda en el cliente, el estado de toda la vista se representa en un campo 
              oculto en la página. De forma predeterminada, el estado se guarda en el servidor.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Las aplicaciones web del estudio de caso de Duke's Forest guardan su estado de vista en el 
              cliente.
            </p>
          </div>
          <div class="paragraph">
            <p>
              Guardar el estado en el cliente usa más ancho de banda y más recursos del cliente, mientras que 
              guardarlo en el servidor usa más recursos del servidor. También puede querer guardar el estado 
              del cliente si espera que sus usuarios deshabiliten las cookies.
            </p>
          </div>
        </div>
      </div>
    </div>
    <hr />
    <table width="90%" id="bottom-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>		
        <td align="left">
          <a href="jsf-custom004.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="jsf-custom006.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class="vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <span id="copyright">
      <a href="img/cpyr.adoc">
        <img src="img/oracle.gif" height="10" alt="Logo de Oracle" />&nbsp;			
        <span>
          Copyright&nbsp;&copy;&nbsp;2017,&nbsp;Oracle&nbsp;y/o&nbsp;sus&nbsp;afiliados.&nbsp;Todos&nbsp;los&nbsp;
          derechos&nbsp;reservados.
        </span>
      </a>
    </span>
  </body>
</html>
