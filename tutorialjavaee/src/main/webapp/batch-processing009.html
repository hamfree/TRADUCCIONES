<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8"/>
    <title>La Aplicación de Ejemplo phonebilling</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="css/style.css" rel="stylesheet">
    <script src="https://use.fontawesome.com/96c4d89611.js"></script>
  </head>
  <body>
    <table id="doc-title" cellspacing="0" cellpadding="0">
      <tr>
        <td align="left" valign="top">
          <b>Plataforma Java, Edición Empresarial (Java EE) 8</b><br />
          <b>El Tutorial de Java EE</b>
        </td>
      </tr>
    </table>
    <hr />
    <table width="90%" id="top-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>
        <td align="left">
          <a href="batch-processing008.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="batch-processing010.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class=" vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <div class="sect1" id="BCGFCACD">
      <h2 id="the-phonebilling-example-application">La Aplicación de Ejemplo phonebilling</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>
            La aplicación de ejemplo <code>phonebilling</code>, ubicada en el directorio 
            tut-install`/examples/batch/phonebilling/`, demuestra cómo usar el marco de trabajo por lotes en 
            Java EE para implementar un sistema de facturación telefónica. Esta aplicación de ejemplo procesa 
            un archivo de registro de llamadas telefónicas y crea una factura para cada cliente.
          </p>
        </div>
        <div class="paragraph">
          <p>Aquí se tratan los siguientes temas:</p>
        </div>
        <div class="ulist">
          <ul>
            <li>
              <p><a href="#BABDEIFG">Arquitectura de la Aplicación de Ejemplo phonebilling</a></p>
            </li>
            <li>
              <p><a href="#BABBGDAA">Ejecución de la Aplicación de Ejemplo phonebilling</a></p>
            </li>
          </ul>
        </div>
        <div class="sect2" id="BABDEIFG">
          <h3 id="architecture-of-the-phonebilling-example-application">
            Arquitectura de la Aplicación de Ejemplo phonebilling
          </h3>
          <div class="paragraph">
            <p>La aplicación de ejemplo <code>phonebilling</code> consta de los siguientes elementos.</p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>
                  Un archivo de definición de trabajo (<code>phonebilling.xml</code>) que usa el Lenguaje de 
                  Especificación de Trabajo (JSL) para definir un trabajo por lotes con dos pasos de 
                  fragmento. El primer paso lee los registros de llamadas de un archivo de registro y los 
                  asocia con una factura. El segundo paso calcula el monto adeudado y escribe cada factura en 
                  un archivo de texto.
                </p>
              </li>
              <li>
                <p>
                  Una clase Java (<code>CallRecordLogCreator</code>) que crea el archivo de registro para el 
                  trabajo por lotes. Este es un componente auxiliar que no demuestra ninguna funcionalidad 
                  clave en este ejemplo.
                </p>
              </li>
              <li>
                <p>
                  Dos entidades de la IPA de Java Persistence (JPA) (<code>CallRecord</code> y 
                  <code>PhoneBill</code>) que representan registros de llamadas y facturas de clientes. La 
                  aplicación utiliza un administrador de entidades JPA para almacenar instancias de estas 
                  entidades en una base de datos.
                </p>
              </li>
              <li>
                <p>
                  Tres artefactos por lotes (<code>CallRecordReader</code>, <code>CallRecordProcessor</code> y 
                  <code>CallRecordWriter</code>) que implementan el primer paso de la aplicación. Este paso 
                  lee los registros de llamadas del archivo de registro, los asocia con una factura y los 
                  almacena en una base de datos.
                </p>
              </li>
              <li>
                <p>
                  Cuatro artefactos por lotes (<code>BillReader</code>, <code>BillProcessor</code>, 
                  <code>BillWriter</code> y <code>BillPartitionMapper</code>) que implementan el segundo paso 
                  de la aplicación. Este paso es un paso particionado que obtiene cada factura de la base de 
                  datos, calcula el monto adeudado y lo escribe en un archivo de texto.
                </p>
              </li>
              <li>
                <p>
                  Dos páginas Facelets (<code>index.xhtml</code> y <code>jobstarted.xhtml</code>) que 
                  proporcionan el front-end de la aplicación por lotes. La primera página muestra el archivo 
                  de registro que procesará el trabajo por lotes y la segunda página permite al usuario 
                  comprobar el estado del trabajo y muestra la factura resultante para cada cliente.
                </p>
              </li>
              <li>
                <p>
                  Un bean administrado (<code>JsfBean</code>) al que se accede desde las páginas de Facelets. 
                  El bean envía el trabajo al tiempo de ejecución por lotes, verifica el estado del trabajo y 
                  lee los archivos de texto de cada factura.
                </p>
              </li>
            </ul>
          </div>
          <div class="sect3" id="sthref288">
            <h4 id="the-job-definition-file">El Archivo de Definición de Trabajo</h4>
            <div class="paragraph">
              <p>
                El archivo de definición de trabajo <code>phonebilling.xml</code> se encuentra en el 
                directorio <code>WEB-INF/classes/META-INF/batch-jobs/</code>. El archivo especifica tres 
                propiedades a nivel de trabajo y dos pasos:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;job id="phonebilling" xmlns="http://xmlns.jcp.org/xml/ns/javaee"
     version="1.0"&gt;
    &lt;properties&gt;
        &lt;property name="log_file_name" value="log1.txt"/&gt;
        &lt;property name="airtime_price" value="0.08"/&gt;
        &lt;property name="tax_rate" value="0.07"/&gt;
    &lt;/properties&gt;
    &lt;step id="callrecords" next="bills"&gt; ... &lt;/step&gt;
    &lt;step id="bills"&gt; ... &lt;/step&gt;
&lt;/job&gt;
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>El primer paso se define de la siguiente manera:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
&lt;step id="callrecords" next="bills"&gt;
    &lt;chunk checkpoint-policy="item" item-count="10"&gt;
        &lt;reader ref="CallRecordReader"&gt;&lt;/reader&gt;
        &lt;processor ref="CallRecordProcessor"&gt;&lt;/processor&gt;
        &lt;writer ref="CallRecordWriter"&gt;&lt;/writer&gt;
    &lt;/chunk&gt;
&lt;/step&gt;
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Este paso es un paso de fragmento normal que especifica los artefactos por lotes que 
                implementan cada fase del paso. Los nombres de los artefactos por lotes no son nombres de 
                clase completos, por lo que los artefactos por lotes son beans CDI anotados con 
                <code>@Named</code>.
              </p>
            </div>
            <div class="paragraph">
              <p>El segundo paso se define de la siguiente manera:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
&lt;step id="bills"&gt;
    &lt;chunk checkpoint-policy="item" item-count="2"&gt;
        &lt;reader ref="BillReader"&gt;
            &lt;properties&gt;
                &lt;property name="firstItem" value="#{partitionPlan['firstItem']}"/&gt;
                &lt;property name="numItems" value="#{partitionPlan['numItems']}"/&gt;
            &lt;/properties&gt;
        &lt;/reader&gt;
        &lt;processor ref="BillProcessor"&gt;&lt;/processor&gt;
        &lt;writer ref="BillWriter"&gt;&lt;/writer&gt;
    &lt;/chunk&gt;
    &lt;partition&gt;
        &lt;mapper ref="BillPartitionMapper"/&gt;
    &lt;/partition&gt;
    &lt;end on="COMPLETED"/&gt;
&lt;/step&gt;
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Este paso es un paso de fragmento particionado. El plan de partición se especifica a través 
                del artefacto <code>BillPartitionMapper</code> en lugar de utilizar el elemento 
                <code>plan</code>.
              </p>
            </div>
          </div>
          <div class="sect3" id="sthref289">
            <h4 id="the-callrecord-and-phonebill-entities">Las Entidades CallRecord y PhoneBill</h4>
            <div class="paragraph">
              <p>La entidad <code>CallRecord</code> se define de la siguiente manera:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Entity
public class CallRecord implements Serializable {
    @Id @GeneratedValue
    private Long id;
    @Temporal(TemporalType.DATE)
    private Date datetime;
    private String fromNumber;
    private String toNumber;
    private int minutes;
    private int seconds;
    private BigDecimal price;
    public CallRecord() { }
    public CallRecord(String datetime, String from,
            String to, int min, int sec)             throws ParseException { ... }
    public CallRecord(String jsonData) throws ParseException { ... }
    /* ... Getters and setters ... */
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El campo <code>id</code> es generado automáticamente por la implementación de JPA para 
                almacenar y recuperar objetos <code>CallRecord</code> hacia y desde una base de datos.
              </p>
            </div>
            <div class="paragraph">
              <p>
                El segundo constructor crea un objeto <code>CallRecord</code> a partir de una entrada de datos 
                JSON en el archivo de registro mediante la API de procesamiento de JSON. Las entradas de 
                registro tienen el siguiente aspecto:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
{"datetime":"03/01/2013 04:03","from":"555-0101",
"to":"555-0114","length":"03:39"}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>La entidad <code>PhoneBill</code> se define de la siguiente manera:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Entity
public class PhoneBill implements Serializable {
    @Id
    private String phoneNumber;
    @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.PERSIST)
    @OrderBy("datetime ASC")
    private List&lt;CallRecord&gt; calls;
    private BigDecimal amountBase;
    private BigDecimal taxRate;
    private BigDecimal tax;
    private BigDecimal amountTotal;
    public PhoneBill() { }
    public PhoneBill(String number) {
        this.phoneNumber = number;
        calls = new ArrayList&lt;&gt;();
    }
    public void addCall(CallRecord call) {
        calls.add(call);
    }
    public void calculate(BigDecimal taxRate) { ... }
    /* ... Getters and setters ... *
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                La anotación <code>OneToMany</code> define la relación entre una factura y sus registros de 
                llamadas. El atributo <code>FetchType.EAGER</code> especifica que la colección debe 
                recuperarse con anticipación. El atributo <code>CascadeType.PERSIST</code> indica que los 
                elementos de la lista de llamadas deben conservarse automáticamente cuando se conserva la 
                factura telefónica. La anotación <code>OrderBy</code> define un orden para recuperar los 
                elementos de la lista de llamadas de la base de datos.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Los artefactos por lotes usan instancias de estas dos entidades como elementos para leer, 
                procesar y escribir.
              </p>
            </div>
            <div class="paragraph">
              <p>
                Para obtener más información sobre la IPA de Persistencia de Java, consulte el 
                <a href="persistence-intro.html#BNBPZ">
                  Capítulo 40, "Introducción a la IPA de Persistencia de Java"
                </a>. Para obtener más información sobre la API de procesamiento JSON, consulte el 
                <a href="jsonp.html#GLRBB">Capítulo 20, "Procesado JSON"</a>.
              </p>
            </div>
          </div>
          <div class="sect3" id="sthref290">
            <h4 id="the-call-records-chunk-step">El Paso de Fragmento de los Registros de Llamadas</h4>
            <div class="paragraph">
              <p>
                El primer paso se compone de los artefactos por lotes <code>CallRecordReader</code>, 
                <code>CallRecordProcessor</code> y <code>CallRecordWriter</code>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                El artefacto <code>CallRecordReader</code> lee los registros de llamadas del archivo de 
                registro:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Dependent
@Named("CallRecordReader")
public class CallRecordReader implements ItemReader {
    private ItemNumberCheckpoint checkpoint;
    private String fileName;
    private BufferedReader breader;
    @Inject
    JobContext jobCtx;
    /* ... Override the open, close, readItem,
     *     and checkpointInfo methods ... */
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El método <code>open</code> lee la propiedad <code>log_filename</code> y abre el archivo de 
                registro con un lector almacenado en búfer:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
fileName = jobCtx.getProperties().getProperty("log_file_name");
breader = new BufferedReader(new FileReader(fileName));
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Si se proporciona un objeto de punto de control, el método <code>open</code> hace avanzar al 
                lector hasta el último punto de control. De lo contrario, este método crea un nuevo objeto de 
                punto de control. El objeto de punto de control realiza un seguimiento del número de línea 
                desde el último fragmento confirmado.
              </p>
            </div>
            <div class="paragraph">
              <p>
                El método <code>readItem</code> devuelve un nuevo objeto <code>CallRecord</code> o nulo al 
                final del archivo de registro:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Override
public Object readItem() throws Exception {
    /* Read a line from the log file and
     * create a CallRecord from JSON */
    String callEntryJson = breader.readLine();
    if (callEntryJson != null) {
        checkpoint.nextItem();
        return new CallRecord(callEntryJson);
    } else
        return null;
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El artefacto <code>CallRecordProcessor</code> obtiene el precio del tiempo en el aire de las 
                propiedades del trabajo, calcula el precio de cada llamada y devuelve el objeto de la llamada. 
                Este artefacto sobreescribe solo el método <code>processItem</code>.
              </p>
            </div>
            <div class="paragraph">
              <p>
                El artefacto <code>CallRecordWriter</code> asocia cada registro de llamadas con una factura y 
                almacena la factura en la base de datos. Este artefacto sobreescribe los métodos 
                <code>open</code>, <code>close</code>, <code>writeItems</code> y <code>checkpointInfo</code>. 
                El método <code>writeItems</code> se ve así:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Override 
public void writeItems(List&lt;Object&gt; callList) throws Exception {
    for (Object callObject : callList) {
        CallRecord call = (CallRecord) callObject;
        PhoneBill bill = em.find(PhoneBill.class, call.getFromNumber());
        if (bill == null) {
            /* No bill for this customer yet, create one */
            bill = new PhoneBill(call.getFromNumber());
            bill.addCall(call);
            em.persist(bill);
        } else {
            /* Add call to existing bill */
            bill.addCall(call);
        }
    }
}
                  </code>
                </pre>
              </div>
            </div>
          </div>
          <div class="sect3" id="BCGGGAHB">
            <h4 id="the-phone-billing-chunk-step">El Paso de Fragmento de la Facturación de Llamada</h4>
            <div class="paragraph">
              <p>
                El segundo paso se compone de los artefactos por lotes <code>BillReader</code>, 
                <code>BillProcessor</code>, <code>BillWriter</code> y <code>BillPartitionMapper</code>. Este 
                paso obtiene las facturas telefónicas de la base de datos, calcula el impuesto y el monto 
                total adeudado y escribe cada factura en un archivo de texto. Dado que el procesamiento de 
                cada factura es independiente de los demás, este paso se puede particionar y ejecutar en más 
                de un hilo.
              </p>
            </div>
            <div class="paragraph">
              <p>
                El artefacto <code>BillPartitionMapper</code> especifica el número de particiones y los 
                parámetros para cada partición. En este ejemplo, los parámetros representan el rango de 
                elementos que debe procesar cada partición. El artefacto obtiene el número de billetes de la 
                base de datos para calcular estos rangos. Proporciona un objeto de plan de partición que 
                sobreescribe los métodos <code>getPartitions</code> y <code>getPartitionProperties</code> de 
                la interfaz <code>PartitionPlan</code>. El método <code>getPartitions</code> se ve así:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Override
public Properties[] getPartitionProperties() {
    /* Assign an (approximately) equal number of elements
     * to each partition. */
    long totalItems = getBillCount();
    long partItems = (long) totalItems / getPartitions();
    long remItems = totalItems % getPartitions();
    /* Populate a Properties array. Each Properties element
     * in the array corresponds to a partition. */
    Properties[] props = new Properties[getPartitions()];
    for (int i = 0; i &lt; getPartitions(); i++) {
        props[i] = new Properties();
        props[i].setProperty("firstItem",
                String.valueOf(i * partItems));
        /* Last partition gets the remainder elements */
        if (i == getPartitions() - 1) {
            props[i].setProperty("numItems",
                    String.valueOf(partItems + remItems));
        } else {
            props[i].setProperty("numItems",
                    String.valueOf(partItems));
    }
    return props;
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El artefacto <code>BillReader</code> obtiene los parámetros de partición de la siguiente 
                manera:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
@Dependent
@Named("BillReader")
public class BillReader implements ItemReader {
    @Inject
    @BatchProperty(name = "firstItem")
    private String firstItemValue;
    @Inject
    @BatchProperty(name = "numItems")
    private String numItemsValue;
    private ItemNumberCheckpoint checkpoint;
    @PersistenceContext
    private EntityManager em;
    private Iterator iterator;
    @Override
    public void open(Serializable ckpt) throws Exception {
        /* Get the range of items to work on in this partition */
        long firstItem0 = Long.parseLong(firstItemValue);
        long numItems0 = Long.parseLong(numItemsValue);
        if (ckpt == null) {
            /* Create a checkpoint object for this partition */
            checkpoint = new ItemNumberCheckpoint();
            checkpoint.setItemNumber(firstItem0);
            checkpoint.setNumItems(numItems0);
        } else {
            checkpoint = (ItemNumberCheckpoint) ckpt;
        }
        /* Adjust range for this partition from the checkpoint */
        long firstItem = checkpoint.getItemNumber();
        long numItems = numItems0 - (firstItem - firstItem0);
        ...
    }
    ...
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Este artefacto también obtiene un iterador para leer elementos del administrador de entidades 
                JPA:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
/* Obtain an iterator for the bills in this partition */
String query = "SELECT b FROM PhoneBill b ORDER BY b.phoneNumber";
Query q = em.createQuery(query).setFirstResult((int) firstItem)
        .setMaxResults((int) numItems);
iterator = q.getResultList().iterator();
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El artefacto <code>BillProcessor</code> itera sobre la lista de registros de llamadas en una 
                factura y calcula el impuesto y el monto total adeudado para cada factura.
              </p>
            </div>
            <div class="paragraph">
              <p>
                El artefacto <code>BillWriter</code> escribe cada factura en un archivo de texto sin formato.
              </p>
            </div>
          </div>
          <div class="sect3" id="sthref291">
            <h4 id="the-javaserver-faces-pages">Las Páginas de JavaServer Faces</h4>
            <div class="paragraph">
              <p>
                La página <code>index.xhtml</code> contiene un área de texto que muestra el archivo de 
                registro de los registros de llamadas. La página proporciona un botón para que el usuario 
                envíe el trabajo por lotes y navegue a la página siguiente:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
&lt;body&gt;
    &lt;h1&gt;The Phone Billing Example Application&lt;/h1&gt;
    &lt;h2&gt;Log file&lt;/h2&gt;
    &lt;p&gt;The batch job analyzes the following log file:&lt;/p&gt;
    &lt;textarea cols="90" rows="25"
              readonly="true"&gt;#{jsfBean.createAndShowLog()}&lt;/textarea&gt;
    &lt;p&gt; &lt;/p&gt;
    &lt;h:form&gt;
        &lt;h:commandButton value="Start Batch Job"
                         action="#{jsfBean.startBatchJob()}" /&gt;
    &lt;/h:form&gt;
&lt;/body&gt;
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                Esta página llama a los métodos del bean administrado para mostrar el archivo de registro y 
                enviar el trabajo por lotes.
              </p>
            </div>
            <div class="paragraph">
              <p>
                La página <code>jobstarted.xhtml</code> proporciona un botón para verificar el estado actual 
                del trabajo por lotes y muestra las facturas cuando finaliza el trabajo:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
&lt;p&gt;Current Status of the Job: &lt;b&gt;#{jsfBean.jobStatus}&lt;/b&gt;&lt;/p&gt;
&lt;h:dataTable var="_row" value="#{jsfBean.rowList}"
             border="1" rendered="#{jsfBean.completed}"&gt;
    &lt;!-- ... show results from jsfBean.rowList ... --&gt;
&lt;/h:dataTable&gt;
&lt;!-- Render the check status button if the job has not finished --&gt;
&lt;h:form&gt;
    &lt;h:commandButton value="Check Status"
                     rendered="#{jsfBean.completed==false}"
                     action="jobstarted" /&gt;
&lt;/h:form&gt;
                  </code>
                </pre>
              </div>
            </div>
          </div>
          <div class="sect3" id="sthref292">
            <h4 id="the-managed-bean">El Bean Gestionado</h4>
            <div class="paragraph">
              <p>
                El bean administrado <code>JsfBean</code> envía el trabajo al tiempo de ejecución por lotes, 
                verifica el estado del trabajo y lee los archivos de texto para cada factura.
              </p>
            </div>
            <div class="paragraph">
              <p>
                El método <code>startBatchJob</code> del bean envía el trabajo al tiempo de ejecución del 
                lote:
              </p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
/* Submit the batch job to the batch runtime.
 * JSF Navigation method (return the name of the next page) */
public String startBatchJob() {
    jobOperator = BatchRuntime.getJobOperator();
    execID = jobOperator.start("phonebilling", null);
    return "jobstarted";
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>El método <code>getJobStatus</code> del bean comprueba el estado del trabajo:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <pre class="prettyprint highlight">
                  <code class="language-oac_no_warn" data-lang="oac_no_warn">
/* Get the status of the job from the batch runtime */
public String getJobStatus() {
    return jobOperator.getJobExecution(execID).getBatchStatus().toString();
}
                  </code>
                </pre>
              </div>
            </div>
            <div class="paragraph">
              <p>
                El método <code>getRowList</code> del bean crea una lista de facturas que se mostrarán en la 
                página JSF <code>jobstarted.xhtml</code> utilizando una tabla.
              </p>
            </div>
          </div>
        </div>
        <div class="sect2" id="BABBGDAA">
          <h3 id="running-the-phonebilling-example-application">
            Ejecución de la Aplicación de Ejemplo phonebilling
          </h3>
          <div class="paragraph">
            <p>
              Puede usar el EID de NetBeans o Maven para compilar, empaquetar, implementar y ejecutar la 
              aplicación de ejemplo <code>phonebilling</code>.
            </p>
          </div>
          <div class="paragraph">
            <p>Aquí se tratan los siguientes temas:</p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>
                  <a href="#BABIBBBG">
                    Para Ejecutar la Aplicación de Ejemplo de phonebilling Utilizando el EID NetBeans
                  </a>
                </p>
              </li>
              <li>
                <p>
                  <a href="#BABFHIIB">Para Ejecutar la Aplicación de Ejemplo phonebilling Usando Maven</a>
                </p>
              </li>
            </ul>
          </div>
          <div class="sect3" id="BABIBBBG">
            <h4 id="to-run-the-phonebilling-example-application-using-netbeans-ide">
              Para Ejecutar la Aplicación de Ejemplo de phonebilling Utilizando el EID NetBeans
            </h4>
            <div class="olist arabic">
              <ol class="arabic">
                <li>
                  <p>
                    Asegúrese de que el servidor GlassFish se haya iniciado (consulte 
                    <a href="usingexamples002.html#BNADI">Arrancando y Parando el Servidor GlassFish</a>).
                  </p>
                </li>
                <li>
                  <p>En el menú Archivo, elija Abrir proyecto.</p>
                </li>
                <li>
                  <p>En el cuadro de diálogo Abrir proyecto, vaya a:</p>
                  <div class="listingblock">
                    <div class="content">
                      <pre class="prettyprint highlight">
                        <code class="language-oac_no_warn" data-lang="oac_no_warn">
tut-install/examples/batch
                        </code>
                      </pre>
                    </div>
                  </div>
                </li>
                <li>
                  <p>Selecciona la carpeta <code>phonebilling</code>.</p>
                </li>
                <li>
                  <p>Haga clic en Abrir proyecto.</p>
                </li>
                <li>
                  <p>
                    En la pestaña Proyectos, haga clic con el botón derecho en el proyecto 
                    <code>phonebilling</code> y seleccione Ejecutar.
                  </p>
                  <div class="paragraph">
                    <p>
                      Este comando compila y empaqueta la aplicación en un archivo WAR, 
                      <code>phonebilling.war</code>, ubicado en el directorio <code>target/</code>; lo 
                      implementa en el servidor; y abre una ventana del navegador web en la siguiente URL:
                    </p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre class="prettyprint highlight">
                        <code class="language-oac_no_warn" data-lang="oac_no_warn">
http://localhost:8080/phonebilling/
                        </code>
                      </pre>
                    </div>
                  </div>
                </li>
              </ol>
            </div>
          </div>
          <div class="sect3" id="BABFHIIB">
            <h4 id="to-run-the-phonebilling-example-application-using-maven">
              Para Ejecutar la Aplicación de Ejemplo phonebilling Usando Maven
            </h4>
            <div class="olist arabic">
              <ol class="arabic">
                <li>
                  <p>
                    Asegúrese de que el servidor GlassFish se haya iniciado (consulte 
                    <a href="usingexamples002.html#BNADI">Arrancando y Parando el Servidor GlassFish</a>).
                  </p>
                </li>
                <li>
                  <p>En una ventana de terminal, vaya a:</p>
                  <div class="listingblock">
                    <div class="content">
                      <pre class="prettyprint highlight">
                        <code class="language-oac_no_warn" data-lang="oac_no_warn">
tut-install/examples/batch/phonebilling/
                        </code>
                      </pre>
                    </div>
                  </div>
                </li>
                <li>
                  <p>Ingrese el siguiente comando para implementar la aplicación:</p>
                  <div class="listingblock">
                    <div class="content">
                      <pre class="prettyprint highlight">
                        <code class="language-oac_no_warn" data-lang="oac_no_warn">
mvn install
                        </code>
                      </pre>
                    </div>
                  </div>
                </li>
                <li>
                  <p>Abra una ventana del navegador web en la siguiente URL:</p>
                  <div class="listingblock">
                    <div class="content">
                      <pre class="prettyprint highlight">
                        <code class="language-oac_no_warn" data-lang="oac_no_warn">
http://localhost:8080/phonebilling/
                        </code>
                      </pre>
                    </div>
                  </div>
                </li>
              </ol>
            </div>
          </div>
        </div>
      </div>
    </div>
    <hr />
    <table width="90%" id="bottom-nav" cellspacing="0" cellpadding="0">
      <colgroup>
        <col width="12%"/>
        <col width="12%"/>
        <col width="*"/>
      </colgroup>
      <tr>		
        <td align="left">
          <a href="batch-processing008.html">
            <span class=" vector-font"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Anterior</span>
          </a>
        </td>
        <td align="left">
          <a href="batch-processing010.html">
            <span class="vector-font"><i class="fa fa-arrow-circle-right vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Siguiente</span>
          </a>
        </td>
        <td align="right">
          <a href="toc.html">
            <span class="vector-font"><i class="fa fa-list vector-font" aria-hidden="true"></i></span>
            <span style="position:relative;top:-2px;">Contenidos</span>
          </a>
        </td>
      </tr>
    </table>
    <span id="copyright">
      <a href="img/cpyr.adoc">
        <img src="img/oracle.gif" height="10" alt="Logo de Oracle" />&nbsp;			
        <span>
          Copyright&nbsp;&copy;&nbsp;2017,&nbsp;Oracle&nbsp;y/o&nbsp;sus&nbsp;afiliados.&nbsp;Todos&nbsp;los&nbsp;
          derechos&nbsp;reservados.
        </span>
      </a>
    </span>
  </body>
</html>
